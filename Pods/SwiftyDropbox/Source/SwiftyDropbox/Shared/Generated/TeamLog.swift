///
/// Copyright (c) 2016 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

import Foundation

/// Datatypes and serializers for the team_log namespace
open class TeamLog {
    /// Indicates the method in which the action was performed.
    public enum AccessMethodLogInfo: CustomStringConvertible {
        /// End user session details.
        case endUser(TeamLog.SessionLogInfo)
        /// Sign in as session details.
        case signInAs(TeamLog.WebSessionLogInfo)
        /// Content manager session details.
        case contentManager(TeamLog.WebSessionLogInfo)
        /// Admin console session details.
        case adminConsole(TeamLog.WebSessionLogInfo)
        /// Api session details.
        case api(TeamLog.ApiSessionLogInfo)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AccessMethodLogInfoSerializer().serialize(self)))"
        }
    }
    open class AccessMethodLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AccessMethodLogInfo) -> JSON {
            switch value {
                case .endUser(let arg):
                    var d = ["end_user": TeamLog.SessionLogInfoSerializer().serialize(arg)]
                    d[".tag"] = .str("end_user")
                    return .dictionary(d)
                case .signInAs(let arg):
                    var d = Serialization.getFields(TeamLog.WebSessionLogInfoSerializer().serialize(arg))
                    d[".tag"] = .str("sign_in_as")
                    return .dictionary(d)
                case .contentManager(let arg):
                    var d = Serialization.getFields(TeamLog.WebSessionLogInfoSerializer().serialize(arg))
                    d[".tag"] = .str("content_manager")
                    return .dictionary(d)
                case .adminConsole(let arg):
                    var d = Serialization.getFields(TeamLog.WebSessionLogInfoSerializer().serialize(arg))
                    d[".tag"] = .str("admin_console")
                    return .dictionary(d)
                case .api(let arg):
                    var d = Serialization.getFields(TeamLog.ApiSessionLogInfoSerializer().serialize(arg))
                    d[".tag"] = .str("api")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> AccessMethodLogInfo {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "end_user":
                            let v = TeamLog.SessionLogInfoSerializer().deserialize(d["end_user"] ?? .null)
                            return AccessMethodLogInfo.endUser(v)
                        case "sign_in_as":
                            let v = TeamLog.WebSessionLogInfoSerializer().deserialize(json)
                            return AccessMethodLogInfo.signInAs(v)
                        case "content_manager":
                            let v = TeamLog.WebSessionLogInfoSerializer().deserialize(json)
                            return AccessMethodLogInfo.contentManager(v)
                        case "admin_console":
                            let v = TeamLog.WebSessionLogInfoSerializer().deserialize(json)
                            return AccessMethodLogInfo.adminConsole(v)
                        case "api":
                            let v = TeamLog.ApiSessionLogInfoSerializer().deserialize(json)
                            return AccessMethodLogInfo.api(v)
                        case "other":
                            return AccessMethodLogInfo.other
                        default:
                            return AccessMethodLogInfo.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The AccountCaptureAvailability union
    public enum AccountCaptureAvailability: CustomStringConvertible {
        /// An unspecified error.
        case unavailable
        /// An unspecified error.
        case available
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AccountCaptureAvailabilitySerializer().serialize(self)))"
        }
    }
    open class AccountCaptureAvailabilitySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AccountCaptureAvailability) -> JSON {
            switch value {
                case .unavailable:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unavailable")
                    return .dictionary(d)
                case .available:
                    var d = [String: JSON]()
                    d[".tag"] = .str("available")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> AccountCaptureAvailability {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "unavailable":
                            return AccountCaptureAvailability.unavailable
                        case "available":
                            return AccountCaptureAvailability.available
                        case "other":
                            return AccountCaptureAvailability.other
                        default:
                            return AccountCaptureAvailability.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Granted/revoked option to enable account capture on team domains.
    open class AccountCaptureChangeAvailabilityDetails: CustomStringConvertible {
        /// New account capture availabilty value.
        public let newValue: TeamLog.AccountCaptureAvailability
        /// Previous account capture availabilty value. Might be missing due to historical data gap.
        public let previousValue: TeamLog.AccountCaptureAvailability?
        public init(newValue: TeamLog.AccountCaptureAvailability, previousValue: TeamLog.AccountCaptureAvailability? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AccountCaptureChangeAvailabilityDetailsSerializer().serialize(self)))"
        }
    }
    open class AccountCaptureChangeAvailabilityDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AccountCaptureChangeAvailabilityDetails) -> JSON {
            let output = [ 
            "new_value": TeamLog.AccountCaptureAvailabilitySerializer().serialize(value.newValue),
            "previous_value": NullableSerializer(TeamLog.AccountCaptureAvailabilitySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> AccountCaptureChangeAvailabilityDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = TeamLog.AccountCaptureAvailabilitySerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(TeamLog.AccountCaptureAvailabilitySerializer()).deserialize(dict["previous_value"] ?? .null)
                    return AccountCaptureChangeAvailabilityDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The AccountCaptureChangeAvailabilityType struct
    open class AccountCaptureChangeAvailabilityType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AccountCaptureChangeAvailabilityTypeSerializer().serialize(self)))"
        }
    }
    open class AccountCaptureChangeAvailabilityTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AccountCaptureChangeAvailabilityType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> AccountCaptureChangeAvailabilityType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return AccountCaptureChangeAvailabilityType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed account capture setting on team domain.
    open class AccountCaptureChangePolicyDetails: CustomStringConvertible {
        /// New account capture policy.
        public let newValue: TeamLog.AccountCapturePolicy
        /// Previous account capture policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.AccountCapturePolicy?
        public init(newValue: TeamLog.AccountCapturePolicy, previousValue: TeamLog.AccountCapturePolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AccountCaptureChangePolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class AccountCaptureChangePolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AccountCaptureChangePolicyDetails) -> JSON {
            let output = [ 
            "new_value": TeamLog.AccountCapturePolicySerializer().serialize(value.newValue),
            "previous_value": NullableSerializer(TeamLog.AccountCapturePolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> AccountCaptureChangePolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = TeamLog.AccountCapturePolicySerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(TeamLog.AccountCapturePolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                    return AccountCaptureChangePolicyDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The AccountCaptureChangePolicyType struct
    open class AccountCaptureChangePolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AccountCaptureChangePolicyTypeSerializer().serialize(self)))"
        }
    }
    open class AccountCaptureChangePolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AccountCaptureChangePolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> AccountCaptureChangePolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return AccountCaptureChangePolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Account-captured user migrated account to team.
    open class AccountCaptureMigrateAccountDetails: CustomStringConvertible {
        /// Domain name.
        public let domainName: String
        public init(domainName: String) {
            stringValidator()(domainName)
            self.domainName = domainName
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AccountCaptureMigrateAccountDetailsSerializer().serialize(self)))"
        }
    }
    open class AccountCaptureMigrateAccountDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AccountCaptureMigrateAccountDetails) -> JSON {
            let output = [ 
            "domain_name": Serialization._StringSerializer.serialize(value.domainName),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> AccountCaptureMigrateAccountDetails {
            switch json {
                case .dictionary(let dict):
                    let domainName = Serialization._StringSerializer.deserialize(dict["domain_name"] ?? .null)
                    return AccountCaptureMigrateAccountDetails(domainName: domainName)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The AccountCaptureMigrateAccountType struct
    open class AccountCaptureMigrateAccountType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AccountCaptureMigrateAccountTypeSerializer().serialize(self)))"
        }
    }
    open class AccountCaptureMigrateAccountTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AccountCaptureMigrateAccountType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> AccountCaptureMigrateAccountType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return AccountCaptureMigrateAccountType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Sent proactive account capture email to all unmanaged members.
    open class AccountCaptureNotificationEmailsSentDetails: CustomStringConvertible {
        /// Domain name.
        public let domainName: String
        public init(domainName: String) {
            stringValidator()(domainName)
            self.domainName = domainName
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AccountCaptureNotificationEmailsSentDetailsSerializer().serialize(self)))"
        }
    }
    open class AccountCaptureNotificationEmailsSentDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AccountCaptureNotificationEmailsSentDetails) -> JSON {
            let output = [ 
            "domain_name": Serialization._StringSerializer.serialize(value.domainName),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> AccountCaptureNotificationEmailsSentDetails {
            switch json {
                case .dictionary(let dict):
                    let domainName = Serialization._StringSerializer.deserialize(dict["domain_name"] ?? .null)
                    return AccountCaptureNotificationEmailsSentDetails(domainName: domainName)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The AccountCaptureNotificationEmailsSentType struct
    open class AccountCaptureNotificationEmailsSentType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AccountCaptureNotificationEmailsSentTypeSerializer().serialize(self)))"
        }
    }
    open class AccountCaptureNotificationEmailsSentTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AccountCaptureNotificationEmailsSentType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> AccountCaptureNotificationEmailsSentType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return AccountCaptureNotificationEmailsSentType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The AccountCapturePolicy union
    public enum AccountCapturePolicy: CustomStringConvertible {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case invitedUsers
        /// An unspecified error.
        case allUsers
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AccountCapturePolicySerializer().serialize(self)))"
        }
    }
    open class AccountCapturePolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AccountCapturePolicy) -> JSON {
            switch value {
                case .disabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disabled")
                    return .dictionary(d)
                case .invitedUsers:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invited_users")
                    return .dictionary(d)
                case .allUsers:
                    var d = [String: JSON]()
                    d[".tag"] = .str("all_users")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> AccountCapturePolicy {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "disabled":
                            return AccountCapturePolicy.disabled
                        case "invited_users":
                            return AccountCapturePolicy.invitedUsers
                        case "all_users":
                            return AccountCapturePolicy.allUsers
                        case "other":
                            return AccountCapturePolicy.other
                        default:
                            return AccountCapturePolicy.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Account-captured user changed account email to personal email.
    open class AccountCaptureRelinquishAccountDetails: CustomStringConvertible {
        /// Domain name.
        public let domainName: String
        public init(domainName: String) {
            stringValidator()(domainName)
            self.domainName = domainName
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AccountCaptureRelinquishAccountDetailsSerializer().serialize(self)))"
        }
    }
    open class AccountCaptureRelinquishAccountDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AccountCaptureRelinquishAccountDetails) -> JSON {
            let output = [ 
            "domain_name": Serialization._StringSerializer.serialize(value.domainName),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> AccountCaptureRelinquishAccountDetails {
            switch json {
                case .dictionary(let dict):
                    let domainName = Serialization._StringSerializer.deserialize(dict["domain_name"] ?? .null)
                    return AccountCaptureRelinquishAccountDetails(domainName: domainName)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The AccountCaptureRelinquishAccountType struct
    open class AccountCaptureRelinquishAccountType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AccountCaptureRelinquishAccountTypeSerializer().serialize(self)))"
        }
    }
    open class AccountCaptureRelinquishAccountTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AccountCaptureRelinquishAccountType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> AccountCaptureRelinquishAccountType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return AccountCaptureRelinquishAccountType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Additional information indicating the action taken that caused status change.
    public enum ActionDetails: CustomStringConvertible {
        /// Additional information relevant when a new member joins the team.
        case teamJoinDetails(TeamLog.JoinTeamDetails)
        /// Define how the user was removed from the team.
        case removeAction(TeamLog.MemberRemoveActionType)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ActionDetailsSerializer().serialize(self)))"
        }
    }
    open class ActionDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ActionDetails) -> JSON {
            switch value {
                case .teamJoinDetails(let arg):
                    var d = Serialization.getFields(TeamLog.JoinTeamDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("team_join_details")
                    return .dictionary(d)
                case .removeAction(let arg):
                    var d = ["remove_action": TeamLog.MemberRemoveActionTypeSerializer().serialize(arg)]
                    d[".tag"] = .str("remove_action")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ActionDetails {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "team_join_details":
                            let v = TeamLog.JoinTeamDetailsSerializer().deserialize(json)
                            return ActionDetails.teamJoinDetails(v)
                        case "remove_action":
                            let v = TeamLog.MemberRemoveActionTypeSerializer().deserialize(d["remove_action"] ?? .null)
                            return ActionDetails.removeAction(v)
                        case "other":
                            return ActionDetails.other
                        default:
                            return ActionDetails.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The entity who performed the action.
    public enum ActorLogInfo: CustomStringConvertible {
        /// The user who did the action.
        case user(TeamLog.UserLogInfo)
        /// The admin who did the action.
        case admin(TeamLog.UserLogInfo)
        /// The application who did the action.
        case app(TeamLog.AppLogInfo)
        /// Action done by reseller.
        case reseller(TeamLog.ResellerLogInfo)
        /// Action done by Dropbox.
        case dropbox
        /// Anonymous actor.
        case anonymous
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ActorLogInfoSerializer().serialize(self)))"
        }
    }
    open class ActorLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ActorLogInfo) -> JSON {
            switch value {
                case .user(let arg):
                    var d = ["user": TeamLog.UserLogInfoSerializer().serialize(arg)]
                    d[".tag"] = .str("user")
                    return .dictionary(d)
                case .admin(let arg):
                    var d = ["admin": TeamLog.UserLogInfoSerializer().serialize(arg)]
                    d[".tag"] = .str("admin")
                    return .dictionary(d)
                case .app(let arg):
                    var d = ["app": TeamLog.AppLogInfoSerializer().serialize(arg)]
                    d[".tag"] = .str("app")
                    return .dictionary(d)
                case .reseller(let arg):
                    var d = Serialization.getFields(TeamLog.ResellerLogInfoSerializer().serialize(arg))
                    d[".tag"] = .str("reseller")
                    return .dictionary(d)
                case .dropbox:
                    var d = [String: JSON]()
                    d[".tag"] = .str("dropbox")
                    return .dictionary(d)
                case .anonymous:
                    var d = [String: JSON]()
                    d[".tag"] = .str("anonymous")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ActorLogInfo {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "user":
                            let v = TeamLog.UserLogInfoSerializer().deserialize(d["user"] ?? .null)
                            return ActorLogInfo.user(v)
                        case "admin":
                            let v = TeamLog.UserLogInfoSerializer().deserialize(d["admin"] ?? .null)
                            return ActorLogInfo.admin(v)
                        case "app":
                            let v = TeamLog.AppLogInfoSerializer().deserialize(d["app"] ?? .null)
                            return ActorLogInfo.app(v)
                        case "reseller":
                            let v = TeamLog.ResellerLogInfoSerializer().deserialize(json)
                            return ActorLogInfo.reseller(v)
                        case "dropbox":
                            return ActorLogInfo.dropbox
                        case "anonymous":
                            return ActorLogInfo.anonymous
                        case "other":
                            return ActorLogInfo.other
                        default:
                            return ActorLogInfo.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The AdminRole union
    public enum AdminRole: CustomStringConvertible {
        /// An unspecified error.
        case teamAdmin
        /// An unspecified error.
        case userManagementAdmin
        /// An unspecified error.
        case supportAdmin
        /// An unspecified error.
        case limitedAdmin
        /// An unspecified error.
        case memberOnly
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AdminRoleSerializer().serialize(self)))"
        }
    }
    open class AdminRoleSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AdminRole) -> JSON {
            switch value {
                case .teamAdmin:
                    var d = [String: JSON]()
                    d[".tag"] = .str("team_admin")
                    return .dictionary(d)
                case .userManagementAdmin:
                    var d = [String: JSON]()
                    d[".tag"] = .str("user_management_admin")
                    return .dictionary(d)
                case .supportAdmin:
                    var d = [String: JSON]()
                    d[".tag"] = .str("support_admin")
                    return .dictionary(d)
                case .limitedAdmin:
                    var d = [String: JSON]()
                    d[".tag"] = .str("limited_admin")
                    return .dictionary(d)
                case .memberOnly:
                    var d = [String: JSON]()
                    d[".tag"] = .str("member_only")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> AdminRole {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "team_admin":
                            return AdminRole.teamAdmin
                        case "user_management_admin":
                            return AdminRole.userManagementAdmin
                        case "support_admin":
                            return AdminRole.supportAdmin
                        case "limited_admin":
                            return AdminRole.limitedAdmin
                        case "member_only":
                            return AdminRole.memberOnly
                        case "other":
                            return AdminRole.other
                        default:
                            return AdminRole.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Disabled downloads.
    open class AllowDownloadDisabledDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AllowDownloadDisabledDetailsSerializer().serialize(self)))"
        }
    }
    open class AllowDownloadDisabledDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AllowDownloadDisabledDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> AllowDownloadDisabledDetails {
            switch json {
                case .dictionary(_):
                    return AllowDownloadDisabledDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The AllowDownloadDisabledType struct
    open class AllowDownloadDisabledType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AllowDownloadDisabledTypeSerializer().serialize(self)))"
        }
    }
    open class AllowDownloadDisabledTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AllowDownloadDisabledType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> AllowDownloadDisabledType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return AllowDownloadDisabledType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Enabled downloads.
    open class AllowDownloadEnabledDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AllowDownloadEnabledDetailsSerializer().serialize(self)))"
        }
    }
    open class AllowDownloadEnabledDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AllowDownloadEnabledDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> AllowDownloadEnabledDetails {
            switch json {
                case .dictionary(_):
                    return AllowDownloadEnabledDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The AllowDownloadEnabledType struct
    open class AllowDownloadEnabledType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AllowDownloadEnabledTypeSerializer().serialize(self)))"
        }
    }
    open class AllowDownloadEnabledTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AllowDownloadEnabledType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> AllowDownloadEnabledType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return AllowDownloadEnabledType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Api session.
    open class ApiSessionLogInfo: CustomStringConvertible {
        /// Api request ID.
        public let requestId: String
        public init(requestId: String) {
            stringValidator()(requestId)
            self.requestId = requestId
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ApiSessionLogInfoSerializer().serialize(self)))"
        }
    }
    open class ApiSessionLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ApiSessionLogInfo) -> JSON {
            let output = [ 
            "request_id": Serialization._StringSerializer.serialize(value.requestId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ApiSessionLogInfo {
            switch json {
                case .dictionary(let dict):
                    let requestId = Serialization._StringSerializer.deserialize(dict["request_id"] ?? .null)
                    return ApiSessionLogInfo(requestId: requestId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Linked app for team.
    open class AppLinkTeamDetails: CustomStringConvertible {
        /// Relevant application details.
        public let appInfo: TeamLog.AppLogInfo
        public init(appInfo: TeamLog.AppLogInfo) {
            self.appInfo = appInfo
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AppLinkTeamDetailsSerializer().serialize(self)))"
        }
    }
    open class AppLinkTeamDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AppLinkTeamDetails) -> JSON {
            let output = [ 
            "app_info": TeamLog.AppLogInfoSerializer().serialize(value.appInfo),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> AppLinkTeamDetails {
            switch json {
                case .dictionary(let dict):
                    let appInfo = TeamLog.AppLogInfoSerializer().deserialize(dict["app_info"] ?? .null)
                    return AppLinkTeamDetails(appInfo: appInfo)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The AppLinkTeamType struct
    open class AppLinkTeamType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AppLinkTeamTypeSerializer().serialize(self)))"
        }
    }
    open class AppLinkTeamTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AppLinkTeamType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> AppLinkTeamType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return AppLinkTeamType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Linked app for member.
    open class AppLinkUserDetails: CustomStringConvertible {
        /// Relevant application details.
        public let appInfo: TeamLog.AppLogInfo
        public init(appInfo: TeamLog.AppLogInfo) {
            self.appInfo = appInfo
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AppLinkUserDetailsSerializer().serialize(self)))"
        }
    }
    open class AppLinkUserDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AppLinkUserDetails) -> JSON {
            let output = [ 
            "app_info": TeamLog.AppLogInfoSerializer().serialize(value.appInfo),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> AppLinkUserDetails {
            switch json {
                case .dictionary(let dict):
                    let appInfo = TeamLog.AppLogInfoSerializer().deserialize(dict["app_info"] ?? .null)
                    return AppLinkUserDetails(appInfo: appInfo)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The AppLinkUserType struct
    open class AppLinkUserType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AppLinkUserTypeSerializer().serialize(self)))"
        }
    }
    open class AppLinkUserTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AppLinkUserType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> AppLinkUserType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return AppLinkUserType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// App's logged information.
    open class AppLogInfo: CustomStringConvertible {
        /// App unique ID. Might be missing due to historical data gap.
        public let appId: String?
        /// App display name. Might be missing due to historical data gap.
        public let displayName: String?
        public init(appId: String? = nil, displayName: String? = nil) {
            nullableValidator(stringValidator())(appId)
            self.appId = appId
            nullableValidator(stringValidator())(displayName)
            self.displayName = displayName
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AppLogInfoSerializer().serialize(self)))"
        }
    }
    open class AppLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AppLogInfo) -> JSON {
            var output = [ 
            "app_id": NullableSerializer(Serialization._StringSerializer).serialize(value.appId),
            "display_name": NullableSerializer(Serialization._StringSerializer).serialize(value.displayName),
            ]
            switch value {
                case let userOrTeamLinkedApp as TeamLog.UserOrTeamLinkedAppLogInfo:
                    for (k, v) in Serialization.getFields(TeamLog.UserOrTeamLinkedAppLogInfoSerializer().serialize(userOrTeamLinkedApp)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("user_or_team_linked_app")
                case let userLinkedApp as TeamLog.UserLinkedAppLogInfo:
                    for (k, v) in Serialization.getFields(TeamLog.UserLinkedAppLogInfoSerializer().serialize(userLinkedApp)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("user_linked_app")
                case let teamLinkedApp as TeamLog.TeamLinkedAppLogInfo:
                    for (k, v) in Serialization.getFields(TeamLog.TeamLinkedAppLogInfoSerializer().serialize(teamLinkedApp)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("team_linked_app")
                default: fatalError("Tried to serialize unexpected subtype")
            }
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> AppLogInfo {
            switch json {
                case .dictionary(let dict):
                    let tag = Serialization.getTag(dict)
                    switch tag {
                        case "user_or_team_linked_app":
                            return TeamLog.UserOrTeamLinkedAppLogInfoSerializer().deserialize(json)
                        case "user_linked_app":
                            return TeamLog.UserLinkedAppLogInfoSerializer().deserialize(json)
                        case "team_linked_app":
                            return TeamLog.TeamLinkedAppLogInfoSerializer().deserialize(json)
                        default:
                            let appId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["app_id"] ?? .null)
                            let displayName = NullableSerializer(Serialization._StringSerializer).deserialize(dict["display_name"] ?? .null)
                            return AppLogInfo(appId: appId, displayName: displayName)
                    }
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Unlinked app for team.
    open class AppUnlinkTeamDetails: CustomStringConvertible {
        /// Relevant application details.
        public let appInfo: TeamLog.AppLogInfo
        public init(appInfo: TeamLog.AppLogInfo) {
            self.appInfo = appInfo
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AppUnlinkTeamDetailsSerializer().serialize(self)))"
        }
    }
    open class AppUnlinkTeamDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AppUnlinkTeamDetails) -> JSON {
            let output = [ 
            "app_info": TeamLog.AppLogInfoSerializer().serialize(value.appInfo),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> AppUnlinkTeamDetails {
            switch json {
                case .dictionary(let dict):
                    let appInfo = TeamLog.AppLogInfoSerializer().deserialize(dict["app_info"] ?? .null)
                    return AppUnlinkTeamDetails(appInfo: appInfo)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The AppUnlinkTeamType struct
    open class AppUnlinkTeamType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AppUnlinkTeamTypeSerializer().serialize(self)))"
        }
    }
    open class AppUnlinkTeamTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AppUnlinkTeamType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> AppUnlinkTeamType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return AppUnlinkTeamType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Unlinked app for member.
    open class AppUnlinkUserDetails: CustomStringConvertible {
        /// Relevant application details.
        public let appInfo: TeamLog.AppLogInfo
        public init(appInfo: TeamLog.AppLogInfo) {
            self.appInfo = appInfo
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AppUnlinkUserDetailsSerializer().serialize(self)))"
        }
    }
    open class AppUnlinkUserDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AppUnlinkUserDetails) -> JSON {
            let output = [ 
            "app_info": TeamLog.AppLogInfoSerializer().serialize(value.appInfo),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> AppUnlinkUserDetails {
            switch json {
                case .dictionary(let dict):
                    let appInfo = TeamLog.AppLogInfoSerializer().deserialize(dict["app_info"] ?? .null)
                    return AppUnlinkUserDetails(appInfo: appInfo)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The AppUnlinkUserType struct
    open class AppUnlinkUserType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AppUnlinkUserTypeSerializer().serialize(self)))"
        }
    }
    open class AppUnlinkUserTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AppUnlinkUserType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> AppUnlinkUserType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return AppUnlinkUserType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Asset details.
    public enum AssetLogInfo: CustomStringConvertible {
        /// File's details.
        case file(TeamLog.FileLogInfo)
        /// Folder's details.
        case folder(TeamLog.FolderLogInfo)
        /// Paper docuement's details.
        case paperDocument(TeamLog.PaperDocumentLogInfo)
        /// Paper folder's details.
        case paperFolder(TeamLog.PaperFolderLogInfo)
        /// Showcase document's details.
        case showcaseDocument(TeamLog.ShowcaseDocumentLogInfo)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AssetLogInfoSerializer().serialize(self)))"
        }
    }
    open class AssetLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AssetLogInfo) -> JSON {
            switch value {
                case .file(let arg):
                    var d = Serialization.getFields(TeamLog.FileLogInfoSerializer().serialize(arg))
                    d[".tag"] = .str("file")
                    return .dictionary(d)
                case .folder(let arg):
                    var d = Serialization.getFields(TeamLog.FolderLogInfoSerializer().serialize(arg))
                    d[".tag"] = .str("folder")
                    return .dictionary(d)
                case .paperDocument(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocumentLogInfoSerializer().serialize(arg))
                    d[".tag"] = .str("paper_document")
                    return .dictionary(d)
                case .paperFolder(let arg):
                    var d = Serialization.getFields(TeamLog.PaperFolderLogInfoSerializer().serialize(arg))
                    d[".tag"] = .str("paper_folder")
                    return .dictionary(d)
                case .showcaseDocument(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseDocumentLogInfoSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_document")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> AssetLogInfo {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "file":
                            let v = TeamLog.FileLogInfoSerializer().deserialize(json)
                            return AssetLogInfo.file(v)
                        case "folder":
                            let v = TeamLog.FolderLogInfoSerializer().deserialize(json)
                            return AssetLogInfo.folder(v)
                        case "paper_document":
                            let v = TeamLog.PaperDocumentLogInfoSerializer().deserialize(json)
                            return AssetLogInfo.paperDocument(v)
                        case "paper_folder":
                            let v = TeamLog.PaperFolderLogInfoSerializer().deserialize(json)
                            return AssetLogInfo.paperFolder(v)
                        case "showcase_document":
                            let v = TeamLog.ShowcaseDocumentLogInfoSerializer().deserialize(json)
                            return AssetLogInfo.showcaseDocument(v)
                        case "other":
                            return AssetLogInfo.other
                        default:
                            return AssetLogInfo.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Policy for controlling if team members can activate camera uploads
    public enum CameraUploadsPolicy: CustomStringConvertible {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CameraUploadsPolicySerializer().serialize(self)))"
        }
    }
    open class CameraUploadsPolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CameraUploadsPolicy) -> JSON {
            switch value {
                case .disabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disabled")
                    return .dictionary(d)
                case .enabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("enabled")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> CameraUploadsPolicy {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "disabled":
                            return CameraUploadsPolicy.disabled
                        case "enabled":
                            return CameraUploadsPolicy.enabled
                        case "other":
                            return CameraUploadsPolicy.other
                        default:
                            return CameraUploadsPolicy.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Changed camera uploads setting for team.
    open class CameraUploadsPolicyChangedDetails: CustomStringConvertible {
        /// New camera uploads setting.
        public let newValue: TeamLog.CameraUploadsPolicy
        /// Previous camera uploads setting.
        public let previousValue: TeamLog.CameraUploadsPolicy
        public init(newValue: TeamLog.CameraUploadsPolicy, previousValue: TeamLog.CameraUploadsPolicy) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CameraUploadsPolicyChangedDetailsSerializer().serialize(self)))"
        }
    }
    open class CameraUploadsPolicyChangedDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CameraUploadsPolicyChangedDetails) -> JSON {
            let output = [ 
            "new_value": TeamLog.CameraUploadsPolicySerializer().serialize(value.newValue),
            "previous_value": TeamLog.CameraUploadsPolicySerializer().serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> CameraUploadsPolicyChangedDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = TeamLog.CameraUploadsPolicySerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = TeamLog.CameraUploadsPolicySerializer().deserialize(dict["previous_value"] ?? .null)
                    return CameraUploadsPolicyChangedDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The CameraUploadsPolicyChangedType struct
    open class CameraUploadsPolicyChangedType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CameraUploadsPolicyChangedTypeSerializer().serialize(self)))"
        }
    }
    open class CameraUploadsPolicyChangedTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CameraUploadsPolicyChangedType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> CameraUploadsPolicyChangedType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return CameraUploadsPolicyChangedType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Certificate details.
    open class Certificate: CustomStringConvertible {
        /// Certificate subject.
        public let subject: String
        /// Certificate issuer.
        public let issuer: String
        /// Certificate issue date.
        public let issueDate: String
        /// Certificate expiration date.
        public let expirationDate: String
        /// Certificate serial number.
        public let serialNumber: String
        /// Certificate sha1 fingerprint.
        public let sha1Fingerprint: String
        /// Certificate common name.
        public let commonName: String?
        public init(subject: String, issuer: String, issueDate: String, expirationDate: String, serialNumber: String, sha1Fingerprint: String, commonName: String? = nil) {
            stringValidator()(subject)
            self.subject = subject
            stringValidator()(issuer)
            self.issuer = issuer
            stringValidator()(issueDate)
            self.issueDate = issueDate
            stringValidator()(expirationDate)
            self.expirationDate = expirationDate
            stringValidator()(serialNumber)
            self.serialNumber = serialNumber
            stringValidator()(sha1Fingerprint)
            self.sha1Fingerprint = sha1Fingerprint
            nullableValidator(stringValidator())(commonName)
            self.commonName = commonName
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CertificateSerializer().serialize(self)))"
        }
    }
    open class CertificateSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: Certificate) -> JSON {
            let output = [ 
            "subject": Serialization._StringSerializer.serialize(value.subject),
            "issuer": Serialization._StringSerializer.serialize(value.issuer),
            "issue_date": Serialization._StringSerializer.serialize(value.issueDate),
            "expiration_date": Serialization._StringSerializer.serialize(value.expirationDate),
            "serial_number": Serialization._StringSerializer.serialize(value.serialNumber),
            "sha1_fingerprint": Serialization._StringSerializer.serialize(value.sha1Fingerprint),
            "common_name": NullableSerializer(Serialization._StringSerializer).serialize(value.commonName),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> Certificate {
            switch json {
                case .dictionary(let dict):
                    let subject = Serialization._StringSerializer.deserialize(dict["subject"] ?? .null)
                    let issuer = Serialization._StringSerializer.deserialize(dict["issuer"] ?? .null)
                    let issueDate = Serialization._StringSerializer.deserialize(dict["issue_date"] ?? .null)
                    let expirationDate = Serialization._StringSerializer.deserialize(dict["expiration_date"] ?? .null)
                    let serialNumber = Serialization._StringSerializer.deserialize(dict["serial_number"] ?? .null)
                    let sha1Fingerprint = Serialization._StringSerializer.deserialize(dict["sha1_fingerprint"] ?? .null)
                    let commonName = NullableSerializer(Serialization._StringSerializer).deserialize(dict["common_name"] ?? .null)
                    return Certificate(subject: subject, issuer: issuer, issueDate: issueDate, expirationDate: expirationDate, serialNumber: serialNumber, sha1Fingerprint: sha1Fingerprint, commonName: commonName)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Shared album.
    open class CollectionShareDetails: CustomStringConvertible {
        /// Album name.
        public let albumName: String
        public init(albumName: String) {
            stringValidator()(albumName)
            self.albumName = albumName
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CollectionShareDetailsSerializer().serialize(self)))"
        }
    }
    open class CollectionShareDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CollectionShareDetails) -> JSON {
            let output = [ 
            "album_name": Serialization._StringSerializer.serialize(value.albumName),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> CollectionShareDetails {
            switch json {
                case .dictionary(let dict):
                    let albumName = Serialization._StringSerializer.deserialize(dict["album_name"] ?? .null)
                    return CollectionShareDetails(albumName: albumName)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The CollectionShareType struct
    open class CollectionShareType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CollectionShareTypeSerializer().serialize(self)))"
        }
    }
    open class CollectionShareTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CollectionShareType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> CollectionShareType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return CollectionShareType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Policy for pemanent content deletion
    public enum ContentPermanentDeletePolicy: CustomStringConvertible {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ContentPermanentDeletePolicySerializer().serialize(self)))"
        }
    }
    open class ContentPermanentDeletePolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ContentPermanentDeletePolicy) -> JSON {
            switch value {
                case .disabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disabled")
                    return .dictionary(d)
                case .enabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("enabled")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ContentPermanentDeletePolicy {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "disabled":
                            return ContentPermanentDeletePolicy.disabled
                        case "enabled":
                            return ContentPermanentDeletePolicy.enabled
                        case "other":
                            return ContentPermanentDeletePolicy.other
                        default:
                            return ContentPermanentDeletePolicy.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The primary entity on which the action was done.
    public enum ContextLogInfo: CustomStringConvertible {
        /// Action was done on behalf of a team member.
        case teamMember(TeamLog.TeamMemberLogInfo)
        /// Action was done on behalf of a non team member.
        case nonTeamMember(TeamLog.NonTeamMemberLogInfo)
        /// Anonymous context.
        case anonymous
        /// Action was done on behalf of the team.
        case team
        /// Action was done on behalf of a trusted non team member.
        case trustedNonTeamMember(TeamLog.TrustedNonTeamMemberLogInfo)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ContextLogInfoSerializer().serialize(self)))"
        }
    }
    open class ContextLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ContextLogInfo) -> JSON {
            switch value {
                case .teamMember(let arg):
                    var d = Serialization.getFields(TeamLog.TeamMemberLogInfoSerializer().serialize(arg))
                    d[".tag"] = .str("team_member")
                    return .dictionary(d)
                case .nonTeamMember(let arg):
                    var d = Serialization.getFields(TeamLog.NonTeamMemberLogInfoSerializer().serialize(arg))
                    d[".tag"] = .str("non_team_member")
                    return .dictionary(d)
                case .anonymous:
                    var d = [String: JSON]()
                    d[".tag"] = .str("anonymous")
                    return .dictionary(d)
                case .team:
                    var d = [String: JSON]()
                    d[".tag"] = .str("team")
                    return .dictionary(d)
                case .trustedNonTeamMember(let arg):
                    var d = Serialization.getFields(TeamLog.TrustedNonTeamMemberLogInfoSerializer().serialize(arg))
                    d[".tag"] = .str("trusted_non_team_member")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ContextLogInfo {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "team_member":
                            let v = TeamLog.TeamMemberLogInfoSerializer().deserialize(json)
                            return ContextLogInfo.teamMember(v)
                        case "non_team_member":
                            let v = TeamLog.NonTeamMemberLogInfoSerializer().deserialize(json)
                            return ContextLogInfo.nonTeamMember(v)
                        case "anonymous":
                            return ContextLogInfo.anonymous
                        case "team":
                            return ContextLogInfo.team
                        case "trusted_non_team_member":
                            let v = TeamLog.TrustedNonTeamMemberLogInfoSerializer().deserialize(json)
                            return ContextLogInfo.trustedNonTeamMember(v)
                        case "other":
                            return ContextLogInfo.other
                        default:
                            return ContextLogInfo.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Created folders.
    open class CreateFolderDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CreateFolderDetailsSerializer().serialize(self)))"
        }
    }
    open class CreateFolderDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CreateFolderDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> CreateFolderDetails {
            switch json {
                case .dictionary(_):
                    return CreateFolderDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The CreateFolderType struct
    open class CreateFolderType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CreateFolderTypeSerializer().serialize(self)))"
        }
    }
    open class CreateFolderTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CreateFolderType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> CreateFolderType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return CreateFolderType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Set restrictions on data center locations where team data resides.
    open class DataPlacementRestrictionChangePolicyDetails: CustomStringConvertible {
        /// Previous placement restriction.
        public let previousValue: TeamLog.PlacementRestriction
        /// New placement restriction.
        public let newValue: TeamLog.PlacementRestriction
        public init(previousValue: TeamLog.PlacementRestriction, newValue: TeamLog.PlacementRestriction) {
            self.previousValue = previousValue
            self.newValue = newValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DataPlacementRestrictionChangePolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class DataPlacementRestrictionChangePolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DataPlacementRestrictionChangePolicyDetails) -> JSON {
            let output = [ 
            "previous_value": TeamLog.PlacementRestrictionSerializer().serialize(value.previousValue),
            "new_value": TeamLog.PlacementRestrictionSerializer().serialize(value.newValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DataPlacementRestrictionChangePolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let previousValue = TeamLog.PlacementRestrictionSerializer().deserialize(dict["previous_value"] ?? .null)
                    let newValue = TeamLog.PlacementRestrictionSerializer().deserialize(dict["new_value"] ?? .null)
                    return DataPlacementRestrictionChangePolicyDetails(previousValue: previousValue, newValue: newValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DataPlacementRestrictionChangePolicyType struct
    open class DataPlacementRestrictionChangePolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DataPlacementRestrictionChangePolicyTypeSerializer().serialize(self)))"
        }
    }
    open class DataPlacementRestrictionChangePolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DataPlacementRestrictionChangePolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DataPlacementRestrictionChangePolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return DataPlacementRestrictionChangePolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Completed restrictions on data center locations where team data resides.
    open class DataPlacementRestrictionSatisfyPolicyDetails: CustomStringConvertible {
        /// Placement restriction.
        public let placementRestriction: TeamLog.PlacementRestriction
        public init(placementRestriction: TeamLog.PlacementRestriction) {
            self.placementRestriction = placementRestriction
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DataPlacementRestrictionSatisfyPolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class DataPlacementRestrictionSatisfyPolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DataPlacementRestrictionSatisfyPolicyDetails) -> JSON {
            let output = [ 
            "placement_restriction": TeamLog.PlacementRestrictionSerializer().serialize(value.placementRestriction),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DataPlacementRestrictionSatisfyPolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let placementRestriction = TeamLog.PlacementRestrictionSerializer().deserialize(dict["placement_restriction"] ?? .null)
                    return DataPlacementRestrictionSatisfyPolicyDetails(placementRestriction: placementRestriction)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DataPlacementRestrictionSatisfyPolicyType struct
    open class DataPlacementRestrictionSatisfyPolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DataPlacementRestrictionSatisfyPolicyTypeSerializer().serialize(self)))"
        }
    }
    open class DataPlacementRestrictionSatisfyPolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DataPlacementRestrictionSatisfyPolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DataPlacementRestrictionSatisfyPolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return DataPlacementRestrictionSatisfyPolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Device's session logged information.
    open class DeviceSessionLogInfo: CustomStringConvertible {
        /// The IP address of the last activity from this session. Might be missing due to historical data gap.
        public let ipAddress: String?
        /// The time this session was created. Might be missing due to historical data gap.
        public let created: Date?
        /// The time of the last activity from this session. Might be missing due to historical data gap.
        public let updated: Date?
        public init(ipAddress: String? = nil, created: Date? = nil, updated: Date? = nil) {
            nullableValidator(stringValidator())(ipAddress)
            self.ipAddress = ipAddress
            self.created = created
            self.updated = updated
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeviceSessionLogInfoSerializer().serialize(self)))"
        }
    }
    open class DeviceSessionLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeviceSessionLogInfo) -> JSON {
            var output = [ 
            "ip_address": NullableSerializer(Serialization._StringSerializer).serialize(value.ipAddress),
            "created": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.created),
            "updated": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.updated),
            ]
            switch value {
                case let desktopDeviceSession as TeamLog.DesktopDeviceSessionLogInfo:
                    for (k, v) in Serialization.getFields(TeamLog.DesktopDeviceSessionLogInfoSerializer().serialize(desktopDeviceSession)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("desktop_device_session")
                case let mobileDeviceSession as TeamLog.MobileDeviceSessionLogInfo:
                    for (k, v) in Serialization.getFields(TeamLog.MobileDeviceSessionLogInfoSerializer().serialize(mobileDeviceSession)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("mobile_device_session")
                case let webDeviceSession as TeamLog.WebDeviceSessionLogInfo:
                    for (k, v) in Serialization.getFields(TeamLog.WebDeviceSessionLogInfoSerializer().serialize(webDeviceSession)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("web_device_session")
                case let legacyDeviceSession as TeamLog.LegacyDeviceSessionLogInfo:
                    for (k, v) in Serialization.getFields(TeamLog.LegacyDeviceSessionLogInfoSerializer().serialize(legacyDeviceSession)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("legacy_device_session")
                default: fatalError("Tried to serialize unexpected subtype")
            }
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeviceSessionLogInfo {
            switch json {
                case .dictionary(let dict):
                    let tag = Serialization.getTag(dict)
                    switch tag {
                        case "desktop_device_session":
                            return TeamLog.DesktopDeviceSessionLogInfoSerializer().deserialize(json)
                        case "mobile_device_session":
                            return TeamLog.MobileDeviceSessionLogInfoSerializer().deserialize(json)
                        case "web_device_session":
                            return TeamLog.WebDeviceSessionLogInfoSerializer().deserialize(json)
                        case "legacy_device_session":
                            return TeamLog.LegacyDeviceSessionLogInfoSerializer().deserialize(json)
                        default:
                            let ipAddress = NullableSerializer(Serialization._StringSerializer).deserialize(dict["ip_address"] ?? .null)
                            let created = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["created"] ?? .null)
                            let updated = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["updated"] ?? .null)
                            return DeviceSessionLogInfo(ipAddress: ipAddress, created: created, updated: updated)
                    }
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Information about linked Dropbox desktop client sessions
    open class DesktopDeviceSessionLogInfo: TeamLog.DeviceSessionLogInfo {
        /// Desktop session unique id. Might be missing due to historical data gap.
        public let sessionInfo: TeamLog.DesktopSessionLogInfo?
        /// Name of the hosting desktop.
        public let hostName: String
        /// The Dropbox desktop client type.
        public let clientType: Team.DesktopPlatform
        /// The Dropbox client version.
        public let clientVersion: String?
        /// Information on the hosting platform.
        public let platform: String
        /// Whether itu2019s possible to delete all of the account files upon unlinking.
        public let isDeleteOnUnlinkSupported: Bool
        public init(hostName: String, clientType: Team.DesktopPlatform, platform: String, isDeleteOnUnlinkSupported: Bool, ipAddress: String? = nil, created: Date? = nil, updated: Date? = nil, sessionInfo: TeamLog.DesktopSessionLogInfo? = nil, clientVersion: String? = nil) {
            self.sessionInfo = sessionInfo
            stringValidator()(hostName)
            self.hostName = hostName
            self.clientType = clientType
            nullableValidator(stringValidator())(clientVersion)
            self.clientVersion = clientVersion
            stringValidator()(platform)
            self.platform = platform
            self.isDeleteOnUnlinkSupported = isDeleteOnUnlinkSupported
            super.init(ipAddress: ipAddress, created: created, updated: updated)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DesktopDeviceSessionLogInfoSerializer().serialize(self)))"
        }
    }
    open class DesktopDeviceSessionLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DesktopDeviceSessionLogInfo) -> JSON {
            let output = [ 
            "host_name": Serialization._StringSerializer.serialize(value.hostName),
            "client_type": Team.DesktopPlatformSerializer().serialize(value.clientType),
            "platform": Serialization._StringSerializer.serialize(value.platform),
            "is_delete_on_unlink_supported": Serialization._BoolSerializer.serialize(value.isDeleteOnUnlinkSupported),
            "ip_address": NullableSerializer(Serialization._StringSerializer).serialize(value.ipAddress),
            "created": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.created),
            "updated": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.updated),
            "session_info": NullableSerializer(TeamLog.DesktopSessionLogInfoSerializer()).serialize(value.sessionInfo),
            "client_version": NullableSerializer(Serialization._StringSerializer).serialize(value.clientVersion),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DesktopDeviceSessionLogInfo {
            switch json {
                case .dictionary(let dict):
                    let hostName = Serialization._StringSerializer.deserialize(dict["host_name"] ?? .null)
                    let clientType = Team.DesktopPlatformSerializer().deserialize(dict["client_type"] ?? .null)
                    let platform = Serialization._StringSerializer.deserialize(dict["platform"] ?? .null)
                    let isDeleteOnUnlinkSupported = Serialization._BoolSerializer.deserialize(dict["is_delete_on_unlink_supported"] ?? .null)
                    let ipAddress = NullableSerializer(Serialization._StringSerializer).deserialize(dict["ip_address"] ?? .null)
                    let created = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["created"] ?? .null)
                    let updated = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["updated"] ?? .null)
                    let sessionInfo = NullableSerializer(TeamLog.DesktopSessionLogInfoSerializer()).deserialize(dict["session_info"] ?? .null)
                    let clientVersion = NullableSerializer(Serialization._StringSerializer).deserialize(dict["client_version"] ?? .null)
                    return DesktopDeviceSessionLogInfo(hostName: hostName, clientType: clientType, platform: platform, isDeleteOnUnlinkSupported: isDeleteOnUnlinkSupported, ipAddress: ipAddress, created: created, updated: updated, sessionInfo: sessionInfo, clientVersion: clientVersion)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Session's logged information.
    open class SessionLogInfo: CustomStringConvertible {
        /// Session ID. Might be missing due to historical data gap.
        public let sessionId: String?
        public init(sessionId: String? = nil) {
            nullableValidator(stringValidator())(sessionId)
            self.sessionId = sessionId
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SessionLogInfoSerializer().serialize(self)))"
        }
    }
    open class SessionLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SessionLogInfo) -> JSON {
            var output = [ 
            "session_id": NullableSerializer(Serialization._StringSerializer).serialize(value.sessionId),
            ]
            switch value {
                case let web as TeamLog.WebSessionLogInfo:
                    for (k, v) in Serialization.getFields(TeamLog.WebSessionLogInfoSerializer().serialize(web)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("web")
                case let desktop as TeamLog.DesktopSessionLogInfo:
                    for (k, v) in Serialization.getFields(TeamLog.DesktopSessionLogInfoSerializer().serialize(desktop)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("desktop")
                case let mobile as TeamLog.MobileSessionLogInfo:
                    for (k, v) in Serialization.getFields(TeamLog.MobileSessionLogInfoSerializer().serialize(mobile)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("mobile")
                default: fatalError("Tried to serialize unexpected subtype")
            }
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SessionLogInfo {
            switch json {
                case .dictionary(let dict):
                    let tag = Serialization.getTag(dict)
                    switch tag {
                        case "web":
                            return TeamLog.WebSessionLogInfoSerializer().deserialize(json)
                        case "desktop":
                            return TeamLog.DesktopSessionLogInfoSerializer().deserialize(json)
                        case "mobile":
                            return TeamLog.MobileSessionLogInfoSerializer().deserialize(json)
                        default:
                            let sessionId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["session_id"] ?? .null)
                            return SessionLogInfo(sessionId: sessionId)
                    }
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Desktop session.
    open class DesktopSessionLogInfo: TeamLog.SessionLogInfo {
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DesktopSessionLogInfoSerializer().serialize(self)))"
        }
    }
    open class DesktopSessionLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DesktopSessionLogInfo) -> JSON {
            let output = [ 
            "session_id": NullableSerializer(Serialization._StringSerializer).serialize(value.sessionId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DesktopSessionLogInfo {
            switch json {
                case .dictionary(let dict):
                    let sessionId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["session_id"] ?? .null)
                    return DesktopSessionLogInfo(sessionId: sessionId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Set/removed limit on number of computers member can link to team Dropbox account.
    open class DeviceApprovalsChangeDesktopPolicyDetails: CustomStringConvertible {
        /// New desktop device approvals policy. Might be missing due to historical data gap.
        public let newValue: TeamLog.DeviceApprovalsPolicy?
        /// Previous desktop device approvals policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.DeviceApprovalsPolicy?
        public init(newValue: TeamLog.DeviceApprovalsPolicy? = nil, previousValue: TeamLog.DeviceApprovalsPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeviceApprovalsChangeDesktopPolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class DeviceApprovalsChangeDesktopPolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeviceApprovalsChangeDesktopPolicyDetails) -> JSON {
            let output = [ 
            "new_value": NullableSerializer(TeamLog.DeviceApprovalsPolicySerializer()).serialize(value.newValue),
            "previous_value": NullableSerializer(TeamLog.DeviceApprovalsPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeviceApprovalsChangeDesktopPolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = NullableSerializer(TeamLog.DeviceApprovalsPolicySerializer()).deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(TeamLog.DeviceApprovalsPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                    return DeviceApprovalsChangeDesktopPolicyDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DeviceApprovalsChangeDesktopPolicyType struct
    open class DeviceApprovalsChangeDesktopPolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeviceApprovalsChangeDesktopPolicyTypeSerializer().serialize(self)))"
        }
    }
    open class DeviceApprovalsChangeDesktopPolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeviceApprovalsChangeDesktopPolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeviceApprovalsChangeDesktopPolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return DeviceApprovalsChangeDesktopPolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Set/removed limit on number of mobile devices member can link to team Dropbox account.
    open class DeviceApprovalsChangeMobilePolicyDetails: CustomStringConvertible {
        /// New mobile device approvals policy. Might be missing due to historical data gap.
        public let newValue: TeamLog.DeviceApprovalsPolicy?
        /// Previous mobile device approvals policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.DeviceApprovalsPolicy?
        public init(newValue: TeamLog.DeviceApprovalsPolicy? = nil, previousValue: TeamLog.DeviceApprovalsPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeviceApprovalsChangeMobilePolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class DeviceApprovalsChangeMobilePolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeviceApprovalsChangeMobilePolicyDetails) -> JSON {
            let output = [ 
            "new_value": NullableSerializer(TeamLog.DeviceApprovalsPolicySerializer()).serialize(value.newValue),
            "previous_value": NullableSerializer(TeamLog.DeviceApprovalsPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeviceApprovalsChangeMobilePolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = NullableSerializer(TeamLog.DeviceApprovalsPolicySerializer()).deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(TeamLog.DeviceApprovalsPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                    return DeviceApprovalsChangeMobilePolicyDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DeviceApprovalsChangeMobilePolicyType struct
    open class DeviceApprovalsChangeMobilePolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeviceApprovalsChangeMobilePolicyTypeSerializer().serialize(self)))"
        }
    }
    open class DeviceApprovalsChangeMobilePolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeviceApprovalsChangeMobilePolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeviceApprovalsChangeMobilePolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return DeviceApprovalsChangeMobilePolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed device approvals setting when member is over limit.
    open class DeviceApprovalsChangeOverageActionDetails: CustomStringConvertible {
        /// New over the limits policy. Might be missing due to historical data gap.
        public let newValue: TeamPolicies.RolloutMethod?
        /// Previous over the limit policy. Might be missing due to historical data gap.
        public let previousValue: TeamPolicies.RolloutMethod?
        public init(newValue: TeamPolicies.RolloutMethod? = nil, previousValue: TeamPolicies.RolloutMethod? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeviceApprovalsChangeOverageActionDetailsSerializer().serialize(self)))"
        }
    }
    open class DeviceApprovalsChangeOverageActionDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeviceApprovalsChangeOverageActionDetails) -> JSON {
            let output = [ 
            "new_value": NullableSerializer(TeamPolicies.RolloutMethodSerializer()).serialize(value.newValue),
            "previous_value": NullableSerializer(TeamPolicies.RolloutMethodSerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeviceApprovalsChangeOverageActionDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = NullableSerializer(TeamPolicies.RolloutMethodSerializer()).deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(TeamPolicies.RolloutMethodSerializer()).deserialize(dict["previous_value"] ?? .null)
                    return DeviceApprovalsChangeOverageActionDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DeviceApprovalsChangeOverageActionType struct
    open class DeviceApprovalsChangeOverageActionType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeviceApprovalsChangeOverageActionTypeSerializer().serialize(self)))"
        }
    }
    open class DeviceApprovalsChangeOverageActionTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeviceApprovalsChangeOverageActionType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeviceApprovalsChangeOverageActionType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return DeviceApprovalsChangeOverageActionType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed device approvals setting when member unlinks approved device.
    open class DeviceApprovalsChangeUnlinkActionDetails: CustomStringConvertible {
        /// New device unlink policy. Might be missing due to historical data gap.
        public let newValue: TeamLog.DeviceUnlinkPolicy?
        /// Previous device unlink policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.DeviceUnlinkPolicy?
        public init(newValue: TeamLog.DeviceUnlinkPolicy? = nil, previousValue: TeamLog.DeviceUnlinkPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeviceApprovalsChangeUnlinkActionDetailsSerializer().serialize(self)))"
        }
    }
    open class DeviceApprovalsChangeUnlinkActionDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeviceApprovalsChangeUnlinkActionDetails) -> JSON {
            let output = [ 
            "new_value": NullableSerializer(TeamLog.DeviceUnlinkPolicySerializer()).serialize(value.newValue),
            "previous_value": NullableSerializer(TeamLog.DeviceUnlinkPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeviceApprovalsChangeUnlinkActionDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = NullableSerializer(TeamLog.DeviceUnlinkPolicySerializer()).deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(TeamLog.DeviceUnlinkPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                    return DeviceApprovalsChangeUnlinkActionDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DeviceApprovalsChangeUnlinkActionType struct
    open class DeviceApprovalsChangeUnlinkActionType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeviceApprovalsChangeUnlinkActionTypeSerializer().serialize(self)))"
        }
    }
    open class DeviceApprovalsChangeUnlinkActionTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeviceApprovalsChangeUnlinkActionType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeviceApprovalsChangeUnlinkActionType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return DeviceApprovalsChangeUnlinkActionType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DeviceApprovalsPolicy union
    public enum DeviceApprovalsPolicy: CustomStringConvertible {
        /// An unspecified error.
        case unlimited
        /// An unspecified error.
        case limited
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeviceApprovalsPolicySerializer().serialize(self)))"
        }
    }
    open class DeviceApprovalsPolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeviceApprovalsPolicy) -> JSON {
            switch value {
                case .unlimited:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unlimited")
                    return .dictionary(d)
                case .limited:
                    var d = [String: JSON]()
                    d[".tag"] = .str("limited")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> DeviceApprovalsPolicy {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "unlimited":
                            return DeviceApprovalsPolicy.unlimited
                        case "limited":
                            return DeviceApprovalsPolicy.limited
                        case "other":
                            return DeviceApprovalsPolicy.other
                        default:
                            return DeviceApprovalsPolicy.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Changed IP address associated with active desktop session.
    open class DeviceChangeIpDesktopDetails: CustomStringConvertible {
        /// Device's session logged information.
        public let deviceSessionInfo: TeamLog.DeviceSessionLogInfo
        public init(deviceSessionInfo: TeamLog.DeviceSessionLogInfo) {
            self.deviceSessionInfo = deviceSessionInfo
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeviceChangeIpDesktopDetailsSerializer().serialize(self)))"
        }
    }
    open class DeviceChangeIpDesktopDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeviceChangeIpDesktopDetails) -> JSON {
            let output = [ 
            "device_session_info": TeamLog.DeviceSessionLogInfoSerializer().serialize(value.deviceSessionInfo),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeviceChangeIpDesktopDetails {
            switch json {
                case .dictionary(let dict):
                    let deviceSessionInfo = TeamLog.DeviceSessionLogInfoSerializer().deserialize(dict["device_session_info"] ?? .null)
                    return DeviceChangeIpDesktopDetails(deviceSessionInfo: deviceSessionInfo)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DeviceChangeIpDesktopType struct
    open class DeviceChangeIpDesktopType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeviceChangeIpDesktopTypeSerializer().serialize(self)))"
        }
    }
    open class DeviceChangeIpDesktopTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeviceChangeIpDesktopType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeviceChangeIpDesktopType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return DeviceChangeIpDesktopType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed IP address associated with active mobile session.
    open class DeviceChangeIpMobileDetails: CustomStringConvertible {
        /// Device's session logged information.
        public let deviceSessionInfo: TeamLog.DeviceSessionLogInfo?
        public init(deviceSessionInfo: TeamLog.DeviceSessionLogInfo? = nil) {
            self.deviceSessionInfo = deviceSessionInfo
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeviceChangeIpMobileDetailsSerializer().serialize(self)))"
        }
    }
    open class DeviceChangeIpMobileDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeviceChangeIpMobileDetails) -> JSON {
            let output = [ 
            "device_session_info": NullableSerializer(TeamLog.DeviceSessionLogInfoSerializer()).serialize(value.deviceSessionInfo),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeviceChangeIpMobileDetails {
            switch json {
                case .dictionary(let dict):
                    let deviceSessionInfo = NullableSerializer(TeamLog.DeviceSessionLogInfoSerializer()).deserialize(dict["device_session_info"] ?? .null)
                    return DeviceChangeIpMobileDetails(deviceSessionInfo: deviceSessionInfo)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DeviceChangeIpMobileType struct
    open class DeviceChangeIpMobileType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeviceChangeIpMobileTypeSerializer().serialize(self)))"
        }
    }
    open class DeviceChangeIpMobileTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeviceChangeIpMobileType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeviceChangeIpMobileType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return DeviceChangeIpMobileType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed IP address associated with active web session.
    open class DeviceChangeIpWebDetails: CustomStringConvertible {
        /// Web browser name.
        public let userAgent: String
        public init(userAgent: String) {
            stringValidator()(userAgent)
            self.userAgent = userAgent
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeviceChangeIpWebDetailsSerializer().serialize(self)))"
        }
    }
    open class DeviceChangeIpWebDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeviceChangeIpWebDetails) -> JSON {
            let output = [ 
            "user_agent": Serialization._StringSerializer.serialize(value.userAgent),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeviceChangeIpWebDetails {
            switch json {
                case .dictionary(let dict):
                    let userAgent = Serialization._StringSerializer.deserialize(dict["user_agent"] ?? .null)
                    return DeviceChangeIpWebDetails(userAgent: userAgent)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DeviceChangeIpWebType struct
    open class DeviceChangeIpWebType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeviceChangeIpWebTypeSerializer().serialize(self)))"
        }
    }
    open class DeviceChangeIpWebTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeviceChangeIpWebType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeviceChangeIpWebType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return DeviceChangeIpWebType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Failed to delete all files from unlinked device.
    open class DeviceDeleteOnUnlinkFailDetails: CustomStringConvertible {
        /// Session unique id. Might be missing due to historical data gap.
        public let sessionInfo: TeamLog.SessionLogInfo?
        /// The device name. Might be missing due to historical data gap.
        public let displayName: String?
        /// The number of times that remote file deletion failed.
        public let numFailures: Int64
        public init(numFailures: Int64, sessionInfo: TeamLog.SessionLogInfo? = nil, displayName: String? = nil) {
            self.sessionInfo = sessionInfo
            nullableValidator(stringValidator())(displayName)
            self.displayName = displayName
            comparableValidator()(numFailures)
            self.numFailures = numFailures
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeviceDeleteOnUnlinkFailDetailsSerializer().serialize(self)))"
        }
    }
    open class DeviceDeleteOnUnlinkFailDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeviceDeleteOnUnlinkFailDetails) -> JSON {
            let output = [ 
            "num_failures": Serialization._Int64Serializer.serialize(value.numFailures),
            "session_info": NullableSerializer(TeamLog.SessionLogInfoSerializer()).serialize(value.sessionInfo),
            "display_name": NullableSerializer(Serialization._StringSerializer).serialize(value.displayName),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeviceDeleteOnUnlinkFailDetails {
            switch json {
                case .dictionary(let dict):
                    let numFailures = Serialization._Int64Serializer.deserialize(dict["num_failures"] ?? .null)
                    let sessionInfo = NullableSerializer(TeamLog.SessionLogInfoSerializer()).deserialize(dict["session_info"] ?? .null)
                    let displayName = NullableSerializer(Serialization._StringSerializer).deserialize(dict["display_name"] ?? .null)
                    return DeviceDeleteOnUnlinkFailDetails(numFailures: numFailures, sessionInfo: sessionInfo, displayName: displayName)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DeviceDeleteOnUnlinkFailType struct
    open class DeviceDeleteOnUnlinkFailType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeviceDeleteOnUnlinkFailTypeSerializer().serialize(self)))"
        }
    }
    open class DeviceDeleteOnUnlinkFailTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeviceDeleteOnUnlinkFailType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeviceDeleteOnUnlinkFailType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return DeviceDeleteOnUnlinkFailType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Deleted all files from unlinked device.
    open class DeviceDeleteOnUnlinkSuccessDetails: CustomStringConvertible {
        /// Session unique id. Might be missing due to historical data gap.
        public let sessionInfo: TeamLog.SessionLogInfo?
        /// The device name. Might be missing due to historical data gap.
        public let displayName: String?
        public init(sessionInfo: TeamLog.SessionLogInfo? = nil, displayName: String? = nil) {
            self.sessionInfo = sessionInfo
            nullableValidator(stringValidator())(displayName)
            self.displayName = displayName
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeviceDeleteOnUnlinkSuccessDetailsSerializer().serialize(self)))"
        }
    }
    open class DeviceDeleteOnUnlinkSuccessDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeviceDeleteOnUnlinkSuccessDetails) -> JSON {
            let output = [ 
            "session_info": NullableSerializer(TeamLog.SessionLogInfoSerializer()).serialize(value.sessionInfo),
            "display_name": NullableSerializer(Serialization._StringSerializer).serialize(value.displayName),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeviceDeleteOnUnlinkSuccessDetails {
            switch json {
                case .dictionary(let dict):
                    let sessionInfo = NullableSerializer(TeamLog.SessionLogInfoSerializer()).deserialize(dict["session_info"] ?? .null)
                    let displayName = NullableSerializer(Serialization._StringSerializer).deserialize(dict["display_name"] ?? .null)
                    return DeviceDeleteOnUnlinkSuccessDetails(sessionInfo: sessionInfo, displayName: displayName)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DeviceDeleteOnUnlinkSuccessType struct
    open class DeviceDeleteOnUnlinkSuccessType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeviceDeleteOnUnlinkSuccessTypeSerializer().serialize(self)))"
        }
    }
    open class DeviceDeleteOnUnlinkSuccessTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeviceDeleteOnUnlinkSuccessType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeviceDeleteOnUnlinkSuccessType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return DeviceDeleteOnUnlinkSuccessType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Failed to link device.
    open class DeviceLinkFailDetails: CustomStringConvertible {
        /// IP address. Might be missing due to historical data gap.
        public let ipAddress: String?
        /// A description of the device used while user approval blocked.
        public let deviceType: TeamLog.DeviceType
        public init(deviceType: TeamLog.DeviceType, ipAddress: String? = nil) {
            nullableValidator(stringValidator())(ipAddress)
            self.ipAddress = ipAddress
            self.deviceType = deviceType
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeviceLinkFailDetailsSerializer().serialize(self)))"
        }
    }
    open class DeviceLinkFailDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeviceLinkFailDetails) -> JSON {
            let output = [ 
            "device_type": TeamLog.DeviceTypeSerializer().serialize(value.deviceType),
            "ip_address": NullableSerializer(Serialization._StringSerializer).serialize(value.ipAddress),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeviceLinkFailDetails {
            switch json {
                case .dictionary(let dict):
                    let deviceType = TeamLog.DeviceTypeSerializer().deserialize(dict["device_type"] ?? .null)
                    let ipAddress = NullableSerializer(Serialization._StringSerializer).deserialize(dict["ip_address"] ?? .null)
                    return DeviceLinkFailDetails(deviceType: deviceType, ipAddress: ipAddress)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DeviceLinkFailType struct
    open class DeviceLinkFailType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeviceLinkFailTypeSerializer().serialize(self)))"
        }
    }
    open class DeviceLinkFailTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeviceLinkFailType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeviceLinkFailType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return DeviceLinkFailType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Linked device.
    open class DeviceLinkSuccessDetails: CustomStringConvertible {
        /// Device's session logged information.
        public let deviceSessionInfo: TeamLog.DeviceSessionLogInfo?
        public init(deviceSessionInfo: TeamLog.DeviceSessionLogInfo? = nil) {
            self.deviceSessionInfo = deviceSessionInfo
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeviceLinkSuccessDetailsSerializer().serialize(self)))"
        }
    }
    open class DeviceLinkSuccessDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeviceLinkSuccessDetails) -> JSON {
            let output = [ 
            "device_session_info": NullableSerializer(TeamLog.DeviceSessionLogInfoSerializer()).serialize(value.deviceSessionInfo),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeviceLinkSuccessDetails {
            switch json {
                case .dictionary(let dict):
                    let deviceSessionInfo = NullableSerializer(TeamLog.DeviceSessionLogInfoSerializer()).deserialize(dict["device_session_info"] ?? .null)
                    return DeviceLinkSuccessDetails(deviceSessionInfo: deviceSessionInfo)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DeviceLinkSuccessType struct
    open class DeviceLinkSuccessType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeviceLinkSuccessTypeSerializer().serialize(self)))"
        }
    }
    open class DeviceLinkSuccessTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeviceLinkSuccessType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeviceLinkSuccessType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return DeviceLinkSuccessType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Disabled device management.
    open class DeviceManagementDisabledDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeviceManagementDisabledDetailsSerializer().serialize(self)))"
        }
    }
    open class DeviceManagementDisabledDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeviceManagementDisabledDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeviceManagementDisabledDetails {
            switch json {
                case .dictionary(_):
                    return DeviceManagementDisabledDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DeviceManagementDisabledType struct
    open class DeviceManagementDisabledType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeviceManagementDisabledTypeSerializer().serialize(self)))"
        }
    }
    open class DeviceManagementDisabledTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeviceManagementDisabledType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeviceManagementDisabledType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return DeviceManagementDisabledType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Enabled device management.
    open class DeviceManagementEnabledDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeviceManagementEnabledDetailsSerializer().serialize(self)))"
        }
    }
    open class DeviceManagementEnabledDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeviceManagementEnabledDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeviceManagementEnabledDetails {
            switch json {
                case .dictionary(_):
                    return DeviceManagementEnabledDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DeviceManagementEnabledType struct
    open class DeviceManagementEnabledType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeviceManagementEnabledTypeSerializer().serialize(self)))"
        }
    }
    open class DeviceManagementEnabledTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeviceManagementEnabledType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeviceManagementEnabledType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return DeviceManagementEnabledType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DeviceType union
    public enum DeviceType: CustomStringConvertible {
        /// An unspecified error.
        case desktop
        /// An unspecified error.
        case mobile
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeviceTypeSerializer().serialize(self)))"
        }
    }
    open class DeviceTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeviceType) -> JSON {
            switch value {
                case .desktop:
                    var d = [String: JSON]()
                    d[".tag"] = .str("desktop")
                    return .dictionary(d)
                case .mobile:
                    var d = [String: JSON]()
                    d[".tag"] = .str("mobile")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> DeviceType {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "desktop":
                            return DeviceType.desktop
                        case "mobile":
                            return DeviceType.mobile
                        case "other":
                            return DeviceType.other
                        default:
                            return DeviceType.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Disconnected device.
    open class DeviceUnlinkDetails: CustomStringConvertible {
        /// Session unique id.
        public let sessionInfo: TeamLog.SessionLogInfo?
        /// The device name. Might be missing due to historical data gap.
        public let displayName: String?
        /// True if the user requested to delete data after device unlink, false otherwise.
        public let deleteData: Bool
        public init(deleteData: Bool, sessionInfo: TeamLog.SessionLogInfo? = nil, displayName: String? = nil) {
            self.sessionInfo = sessionInfo
            nullableValidator(stringValidator())(displayName)
            self.displayName = displayName
            self.deleteData = deleteData
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeviceUnlinkDetailsSerializer().serialize(self)))"
        }
    }
    open class DeviceUnlinkDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeviceUnlinkDetails) -> JSON {
            let output = [ 
            "delete_data": Serialization._BoolSerializer.serialize(value.deleteData),
            "session_info": NullableSerializer(TeamLog.SessionLogInfoSerializer()).serialize(value.sessionInfo),
            "display_name": NullableSerializer(Serialization._StringSerializer).serialize(value.displayName),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeviceUnlinkDetails {
            switch json {
                case .dictionary(let dict):
                    let deleteData = Serialization._BoolSerializer.deserialize(dict["delete_data"] ?? .null)
                    let sessionInfo = NullableSerializer(TeamLog.SessionLogInfoSerializer()).deserialize(dict["session_info"] ?? .null)
                    let displayName = NullableSerializer(Serialization._StringSerializer).deserialize(dict["display_name"] ?? .null)
                    return DeviceUnlinkDetails(deleteData: deleteData, sessionInfo: sessionInfo, displayName: displayName)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DeviceUnlinkPolicy union
    public enum DeviceUnlinkPolicy: CustomStringConvertible {
        /// An unspecified error.
        case remove
        /// An unspecified error.
        case keep
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeviceUnlinkPolicySerializer().serialize(self)))"
        }
    }
    open class DeviceUnlinkPolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeviceUnlinkPolicy) -> JSON {
            switch value {
                case .remove:
                    var d = [String: JSON]()
                    d[".tag"] = .str("remove")
                    return .dictionary(d)
                case .keep:
                    var d = [String: JSON]()
                    d[".tag"] = .str("keep")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> DeviceUnlinkPolicy {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "remove":
                            return DeviceUnlinkPolicy.remove
                        case "keep":
                            return DeviceUnlinkPolicy.keep
                        case "other":
                            return DeviceUnlinkPolicy.other
                        default:
                            return DeviceUnlinkPolicy.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The DeviceUnlinkType struct
    open class DeviceUnlinkType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeviceUnlinkTypeSerializer().serialize(self)))"
        }
    }
    open class DeviceUnlinkTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeviceUnlinkType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeviceUnlinkType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return DeviceUnlinkType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Added members to directory restrictions list.
    open class DirectoryRestrictionsAddMembersDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DirectoryRestrictionsAddMembersDetailsSerializer().serialize(self)))"
        }
    }
    open class DirectoryRestrictionsAddMembersDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DirectoryRestrictionsAddMembersDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DirectoryRestrictionsAddMembersDetails {
            switch json {
                case .dictionary(_):
                    return DirectoryRestrictionsAddMembersDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DirectoryRestrictionsAddMembersType struct
    open class DirectoryRestrictionsAddMembersType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DirectoryRestrictionsAddMembersTypeSerializer().serialize(self)))"
        }
    }
    open class DirectoryRestrictionsAddMembersTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DirectoryRestrictionsAddMembersType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DirectoryRestrictionsAddMembersType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return DirectoryRestrictionsAddMembersType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Removed members from directory restrictions list.
    open class DirectoryRestrictionsRemoveMembersDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DirectoryRestrictionsRemoveMembersDetailsSerializer().serialize(self)))"
        }
    }
    open class DirectoryRestrictionsRemoveMembersDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DirectoryRestrictionsRemoveMembersDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DirectoryRestrictionsRemoveMembersDetails {
            switch json {
                case .dictionary(_):
                    return DirectoryRestrictionsRemoveMembersDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DirectoryRestrictionsRemoveMembersType struct
    open class DirectoryRestrictionsRemoveMembersType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DirectoryRestrictionsRemoveMembersTypeSerializer().serialize(self)))"
        }
    }
    open class DirectoryRestrictionsRemoveMembersTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DirectoryRestrictionsRemoveMembersType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DirectoryRestrictionsRemoveMembersType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return DirectoryRestrictionsRemoveMembersType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Disabled domain invites.
    open class DisabledDomainInvitesDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DisabledDomainInvitesDetailsSerializer().serialize(self)))"
        }
    }
    open class DisabledDomainInvitesDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DisabledDomainInvitesDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DisabledDomainInvitesDetails {
            switch json {
                case .dictionary(_):
                    return DisabledDomainInvitesDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DisabledDomainInvitesType struct
    open class DisabledDomainInvitesType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DisabledDomainInvitesTypeSerializer().serialize(self)))"
        }
    }
    open class DisabledDomainInvitesTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DisabledDomainInvitesType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DisabledDomainInvitesType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return DisabledDomainInvitesType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Approved user's request to join team.
    open class DomainInvitesApproveRequestToJoinTeamDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DomainInvitesApproveRequestToJoinTeamDetailsSerializer().serialize(self)))"
        }
    }
    open class DomainInvitesApproveRequestToJoinTeamDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DomainInvitesApproveRequestToJoinTeamDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DomainInvitesApproveRequestToJoinTeamDetails {
            switch json {
                case .dictionary(_):
                    return DomainInvitesApproveRequestToJoinTeamDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DomainInvitesApproveRequestToJoinTeamType struct
    open class DomainInvitesApproveRequestToJoinTeamType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DomainInvitesApproveRequestToJoinTeamTypeSerializer().serialize(self)))"
        }
    }
    open class DomainInvitesApproveRequestToJoinTeamTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DomainInvitesApproveRequestToJoinTeamType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DomainInvitesApproveRequestToJoinTeamType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return DomainInvitesApproveRequestToJoinTeamType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Declined user's request to join team.
    open class DomainInvitesDeclineRequestToJoinTeamDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DomainInvitesDeclineRequestToJoinTeamDetailsSerializer().serialize(self)))"
        }
    }
    open class DomainInvitesDeclineRequestToJoinTeamDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DomainInvitesDeclineRequestToJoinTeamDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DomainInvitesDeclineRequestToJoinTeamDetails {
            switch json {
                case .dictionary(_):
                    return DomainInvitesDeclineRequestToJoinTeamDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DomainInvitesDeclineRequestToJoinTeamType struct
    open class DomainInvitesDeclineRequestToJoinTeamType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DomainInvitesDeclineRequestToJoinTeamTypeSerializer().serialize(self)))"
        }
    }
    open class DomainInvitesDeclineRequestToJoinTeamTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DomainInvitesDeclineRequestToJoinTeamType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DomainInvitesDeclineRequestToJoinTeamType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return DomainInvitesDeclineRequestToJoinTeamType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Sent domain invites to existing domain accounts.
    open class DomainInvitesEmailExistingUsersDetails: CustomStringConvertible {
        /// Domain names.
        public let domainName: String
        /// Number of recipients.
        public let numRecipients: UInt64
        public init(domainName: String, numRecipients: UInt64) {
            stringValidator()(domainName)
            self.domainName = domainName
            comparableValidator()(numRecipients)
            self.numRecipients = numRecipients
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DomainInvitesEmailExistingUsersDetailsSerializer().serialize(self)))"
        }
    }
    open class DomainInvitesEmailExistingUsersDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DomainInvitesEmailExistingUsersDetails) -> JSON {
            let output = [ 
            "domain_name": Serialization._StringSerializer.serialize(value.domainName),
            "num_recipients": Serialization._UInt64Serializer.serialize(value.numRecipients),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DomainInvitesEmailExistingUsersDetails {
            switch json {
                case .dictionary(let dict):
                    let domainName = Serialization._StringSerializer.deserialize(dict["domain_name"] ?? .null)
                    let numRecipients = Serialization._UInt64Serializer.deserialize(dict["num_recipients"] ?? .null)
                    return DomainInvitesEmailExistingUsersDetails(domainName: domainName, numRecipients: numRecipients)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DomainInvitesEmailExistingUsersType struct
    open class DomainInvitesEmailExistingUsersType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DomainInvitesEmailExistingUsersTypeSerializer().serialize(self)))"
        }
    }
    open class DomainInvitesEmailExistingUsersTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DomainInvitesEmailExistingUsersType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DomainInvitesEmailExistingUsersType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return DomainInvitesEmailExistingUsersType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Requested to join team.
    open class DomainInvitesRequestToJoinTeamDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DomainInvitesRequestToJoinTeamDetailsSerializer().serialize(self)))"
        }
    }
    open class DomainInvitesRequestToJoinTeamDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DomainInvitesRequestToJoinTeamDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DomainInvitesRequestToJoinTeamDetails {
            switch json {
                case .dictionary(_):
                    return DomainInvitesRequestToJoinTeamDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DomainInvitesRequestToJoinTeamType struct
    open class DomainInvitesRequestToJoinTeamType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DomainInvitesRequestToJoinTeamTypeSerializer().serialize(self)))"
        }
    }
    open class DomainInvitesRequestToJoinTeamTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DomainInvitesRequestToJoinTeamType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DomainInvitesRequestToJoinTeamType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return DomainInvitesRequestToJoinTeamType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Disabled "Automatically invite new users".
    open class DomainInvitesSetInviteNewUserPrefToNoDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DomainInvitesSetInviteNewUserPrefToNoDetailsSerializer().serialize(self)))"
        }
    }
    open class DomainInvitesSetInviteNewUserPrefToNoDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DomainInvitesSetInviteNewUserPrefToNoDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DomainInvitesSetInviteNewUserPrefToNoDetails {
            switch json {
                case .dictionary(_):
                    return DomainInvitesSetInviteNewUserPrefToNoDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DomainInvitesSetInviteNewUserPrefToNoType struct
    open class DomainInvitesSetInviteNewUserPrefToNoType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DomainInvitesSetInviteNewUserPrefToNoTypeSerializer().serialize(self)))"
        }
    }
    open class DomainInvitesSetInviteNewUserPrefToNoTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DomainInvitesSetInviteNewUserPrefToNoType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DomainInvitesSetInviteNewUserPrefToNoType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return DomainInvitesSetInviteNewUserPrefToNoType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Enabled "Automatically invite new users".
    open class DomainInvitesSetInviteNewUserPrefToYesDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DomainInvitesSetInviteNewUserPrefToYesDetailsSerializer().serialize(self)))"
        }
    }
    open class DomainInvitesSetInviteNewUserPrefToYesDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DomainInvitesSetInviteNewUserPrefToYesDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DomainInvitesSetInviteNewUserPrefToYesDetails {
            switch json {
                case .dictionary(_):
                    return DomainInvitesSetInviteNewUserPrefToYesDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DomainInvitesSetInviteNewUserPrefToYesType struct
    open class DomainInvitesSetInviteNewUserPrefToYesType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DomainInvitesSetInviteNewUserPrefToYesTypeSerializer().serialize(self)))"
        }
    }
    open class DomainInvitesSetInviteNewUserPrefToYesTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DomainInvitesSetInviteNewUserPrefToYesType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DomainInvitesSetInviteNewUserPrefToYesType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return DomainInvitesSetInviteNewUserPrefToYesType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Failed to verify team domain.
    open class DomainVerificationAddDomainFailDetails: CustomStringConvertible {
        /// Domain name.
        public let domainName: String
        /// Domain name verification method. Might be missing due to historical data gap.
        public let verificationMethod: String?
        public init(domainName: String, verificationMethod: String? = nil) {
            stringValidator()(domainName)
            self.domainName = domainName
            nullableValidator(stringValidator())(verificationMethod)
            self.verificationMethod = verificationMethod
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DomainVerificationAddDomainFailDetailsSerializer().serialize(self)))"
        }
    }
    open class DomainVerificationAddDomainFailDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DomainVerificationAddDomainFailDetails) -> JSON {
            let output = [ 
            "domain_name": Serialization._StringSerializer.serialize(value.domainName),
            "verification_method": NullableSerializer(Serialization._StringSerializer).serialize(value.verificationMethod),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DomainVerificationAddDomainFailDetails {
            switch json {
                case .dictionary(let dict):
                    let domainName = Serialization._StringSerializer.deserialize(dict["domain_name"] ?? .null)
                    let verificationMethod = NullableSerializer(Serialization._StringSerializer).deserialize(dict["verification_method"] ?? .null)
                    return DomainVerificationAddDomainFailDetails(domainName: domainName, verificationMethod: verificationMethod)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DomainVerificationAddDomainFailType struct
    open class DomainVerificationAddDomainFailType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DomainVerificationAddDomainFailTypeSerializer().serialize(self)))"
        }
    }
    open class DomainVerificationAddDomainFailTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DomainVerificationAddDomainFailType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DomainVerificationAddDomainFailType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return DomainVerificationAddDomainFailType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Verified team domain.
    open class DomainVerificationAddDomainSuccessDetails: CustomStringConvertible {
        /// Domain names.
        public let domainNames: Array<String>
        /// Domain name verification method. Might be missing due to historical data gap.
        public let verificationMethod: String?
        public init(domainNames: Array<String>, verificationMethod: String? = nil) {
            arrayValidator(itemValidator: stringValidator())(domainNames)
            self.domainNames = domainNames
            nullableValidator(stringValidator())(verificationMethod)
            self.verificationMethod = verificationMethod
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DomainVerificationAddDomainSuccessDetailsSerializer().serialize(self)))"
        }
    }
    open class DomainVerificationAddDomainSuccessDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DomainVerificationAddDomainSuccessDetails) -> JSON {
            let output = [ 
            "domain_names": ArraySerializer(Serialization._StringSerializer).serialize(value.domainNames),
            "verification_method": NullableSerializer(Serialization._StringSerializer).serialize(value.verificationMethod),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DomainVerificationAddDomainSuccessDetails {
            switch json {
                case .dictionary(let dict):
                    let domainNames = ArraySerializer(Serialization._StringSerializer).deserialize(dict["domain_names"] ?? .null)
                    let verificationMethod = NullableSerializer(Serialization._StringSerializer).deserialize(dict["verification_method"] ?? .null)
                    return DomainVerificationAddDomainSuccessDetails(domainNames: domainNames, verificationMethod: verificationMethod)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DomainVerificationAddDomainSuccessType struct
    open class DomainVerificationAddDomainSuccessType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DomainVerificationAddDomainSuccessTypeSerializer().serialize(self)))"
        }
    }
    open class DomainVerificationAddDomainSuccessTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DomainVerificationAddDomainSuccessType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DomainVerificationAddDomainSuccessType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return DomainVerificationAddDomainSuccessType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Removed domain from list of verified team domains.
    open class DomainVerificationRemoveDomainDetails: CustomStringConvertible {
        /// Domain names.
        public let domainNames: Array<String>
        public init(domainNames: Array<String>) {
            arrayValidator(itemValidator: stringValidator())(domainNames)
            self.domainNames = domainNames
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DomainVerificationRemoveDomainDetailsSerializer().serialize(self)))"
        }
    }
    open class DomainVerificationRemoveDomainDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DomainVerificationRemoveDomainDetails) -> JSON {
            let output = [ 
            "domain_names": ArraySerializer(Serialization._StringSerializer).serialize(value.domainNames),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DomainVerificationRemoveDomainDetails {
            switch json {
                case .dictionary(let dict):
                    let domainNames = ArraySerializer(Serialization._StringSerializer).deserialize(dict["domain_names"] ?? .null)
                    return DomainVerificationRemoveDomainDetails(domainNames: domainNames)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DomainVerificationRemoveDomainType struct
    open class DomainVerificationRemoveDomainType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DomainVerificationRemoveDomainTypeSerializer().serialize(self)))"
        }
    }
    open class DomainVerificationRemoveDomainTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DomainVerificationRemoveDomainType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DomainVerificationRemoveDomainType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return DomainVerificationRemoveDomainType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Shared content downloads policy
    public enum DownloadPolicyType: CustomStringConvertible {
        /// An unspecified error.
        case allow
        /// An unspecified error.
        case disallow
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DownloadPolicyTypeSerializer().serialize(self)))"
        }
    }
    open class DownloadPolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DownloadPolicyType) -> JSON {
            switch value {
                case .allow:
                    var d = [String: JSON]()
                    d[".tag"] = .str("allow")
                    return .dictionary(d)
                case .disallow:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disallow")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> DownloadPolicyType {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "allow":
                            return DownloadPolicyType.allow
                        case "disallow":
                            return DownloadPolicyType.disallow
                        case "other":
                            return DownloadPolicyType.other
                        default:
                            return DownloadPolicyType.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Represents a time duration: unit and amount
    open class DurationLogInfo: CustomStringConvertible {
        /// Time unit.
        public let unit: TeamLog.TimeUnit
        /// Amount of time.
        public let amount: UInt64
        public init(unit: TeamLog.TimeUnit, amount: UInt64) {
            self.unit = unit
            comparableValidator()(amount)
            self.amount = amount
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DurationLogInfoSerializer().serialize(self)))"
        }
    }
    open class DurationLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DurationLogInfo) -> JSON {
            let output = [ 
            "unit": TeamLog.TimeUnitSerializer().serialize(value.unit),
            "amount": Serialization._UInt64Serializer.serialize(value.amount),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DurationLogInfo {
            switch json {
                case .dictionary(let dict):
                    let unit = TeamLog.TimeUnitSerializer().deserialize(dict["unit"] ?? .null)
                    let amount = Serialization._UInt64Serializer.deserialize(dict["amount"] ?? .null)
                    return DurationLogInfo(unit: unit, amount: amount)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Added members to EMM exception list.
    open class EmmAddExceptionDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(EmmAddExceptionDetailsSerializer().serialize(self)))"
        }
    }
    open class EmmAddExceptionDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: EmmAddExceptionDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> EmmAddExceptionDetails {
            switch json {
                case .dictionary(_):
                    return EmmAddExceptionDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The EmmAddExceptionType struct
    open class EmmAddExceptionType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(EmmAddExceptionTypeSerializer().serialize(self)))"
        }
    }
    open class EmmAddExceptionTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: EmmAddExceptionType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> EmmAddExceptionType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return EmmAddExceptionType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Enabled/disabled enterprise mobility management for members.
    open class EmmChangePolicyDetails: CustomStringConvertible {
        /// New enterprise mobility management policy.
        public let newValue: TeamPolicies.EmmState
        /// Previous enterprise mobility management policy. Might be missing due to historical data gap.
        public let previousValue: TeamPolicies.EmmState?
        public init(newValue: TeamPolicies.EmmState, previousValue: TeamPolicies.EmmState? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(EmmChangePolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class EmmChangePolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: EmmChangePolicyDetails) -> JSON {
            let output = [ 
            "new_value": TeamPolicies.EmmStateSerializer().serialize(value.newValue),
            "previous_value": NullableSerializer(TeamPolicies.EmmStateSerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> EmmChangePolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = TeamPolicies.EmmStateSerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(TeamPolicies.EmmStateSerializer()).deserialize(dict["previous_value"] ?? .null)
                    return EmmChangePolicyDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The EmmChangePolicyType struct
    open class EmmChangePolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(EmmChangePolicyTypeSerializer().serialize(self)))"
        }
    }
    open class EmmChangePolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: EmmChangePolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> EmmChangePolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return EmmChangePolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Created EMM-excluded users report.
    open class EmmCreateExceptionsReportDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(EmmCreateExceptionsReportDetailsSerializer().serialize(self)))"
        }
    }
    open class EmmCreateExceptionsReportDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: EmmCreateExceptionsReportDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> EmmCreateExceptionsReportDetails {
            switch json {
                case .dictionary(_):
                    return EmmCreateExceptionsReportDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The EmmCreateExceptionsReportType struct
    open class EmmCreateExceptionsReportType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(EmmCreateExceptionsReportTypeSerializer().serialize(self)))"
        }
    }
    open class EmmCreateExceptionsReportTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: EmmCreateExceptionsReportType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> EmmCreateExceptionsReportType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return EmmCreateExceptionsReportType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Created EMM mobile app usage report.
    open class EmmCreateUsageReportDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(EmmCreateUsageReportDetailsSerializer().serialize(self)))"
        }
    }
    open class EmmCreateUsageReportDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: EmmCreateUsageReportDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> EmmCreateUsageReportDetails {
            switch json {
                case .dictionary(_):
                    return EmmCreateUsageReportDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The EmmCreateUsageReportType struct
    open class EmmCreateUsageReportType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(EmmCreateUsageReportTypeSerializer().serialize(self)))"
        }
    }
    open class EmmCreateUsageReportTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: EmmCreateUsageReportType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> EmmCreateUsageReportType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return EmmCreateUsageReportType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Failed to sign in via EMM.
    open class EmmErrorDetails: CustomStringConvertible {
        /// Error details.
        public let errorDetails: TeamLog.FailureDetailsLogInfo
        public init(errorDetails: TeamLog.FailureDetailsLogInfo) {
            self.errorDetails = errorDetails
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(EmmErrorDetailsSerializer().serialize(self)))"
        }
    }
    open class EmmErrorDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: EmmErrorDetails) -> JSON {
            let output = [ 
            "error_details": TeamLog.FailureDetailsLogInfoSerializer().serialize(value.errorDetails),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> EmmErrorDetails {
            switch json {
                case .dictionary(let dict):
                    let errorDetails = TeamLog.FailureDetailsLogInfoSerializer().deserialize(dict["error_details"] ?? .null)
                    return EmmErrorDetails(errorDetails: errorDetails)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The EmmErrorType struct
    open class EmmErrorType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(EmmErrorTypeSerializer().serialize(self)))"
        }
    }
    open class EmmErrorTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: EmmErrorType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> EmmErrorType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return EmmErrorType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Refreshed auth token used for setting up enterprise mobility management.
    open class EmmRefreshAuthTokenDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(EmmRefreshAuthTokenDetailsSerializer().serialize(self)))"
        }
    }
    open class EmmRefreshAuthTokenDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: EmmRefreshAuthTokenDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> EmmRefreshAuthTokenDetails {
            switch json {
                case .dictionary(_):
                    return EmmRefreshAuthTokenDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The EmmRefreshAuthTokenType struct
    open class EmmRefreshAuthTokenType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(EmmRefreshAuthTokenTypeSerializer().serialize(self)))"
        }
    }
    open class EmmRefreshAuthTokenTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: EmmRefreshAuthTokenType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> EmmRefreshAuthTokenType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return EmmRefreshAuthTokenType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Removed members from EMM exception list.
    open class EmmRemoveExceptionDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(EmmRemoveExceptionDetailsSerializer().serialize(self)))"
        }
    }
    open class EmmRemoveExceptionDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: EmmRemoveExceptionDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> EmmRemoveExceptionDetails {
            switch json {
                case .dictionary(_):
                    return EmmRemoveExceptionDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The EmmRemoveExceptionType struct
    open class EmmRemoveExceptionType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(EmmRemoveExceptionTypeSerializer().serialize(self)))"
        }
    }
    open class EmmRemoveExceptionTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: EmmRemoveExceptionType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> EmmRemoveExceptionType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return EmmRemoveExceptionType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Enabled domain invites.
    open class EnabledDomainInvitesDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(EnabledDomainInvitesDetailsSerializer().serialize(self)))"
        }
    }
    open class EnabledDomainInvitesDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: EnabledDomainInvitesDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> EnabledDomainInvitesDetails {
            switch json {
                case .dictionary(_):
                    return EnabledDomainInvitesDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The EnabledDomainInvitesType struct
    open class EnabledDomainInvitesType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(EnabledDomainInvitesTypeSerializer().serialize(self)))"
        }
    }
    open class EnabledDomainInvitesTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: EnabledDomainInvitesType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> EnabledDomainInvitesType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return EnabledDomainInvitesType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Category of events in event audit log.
    public enum EventCategory: CustomStringConvertible {
        /// Events that apply to management of linked apps.
        case apps
        /// Events that have to do with comments on files and Paper documents.
        case comments
        /// Events that apply to linked devices on mobile, desktop and Web platforms.
        case devices
        /// Events that involve domain management feature: domain verification, invite enforcement and account capture.
        case domains
        /// Events that have to do with filesystem operations on files and folders: copy, move, delete, etc.
        case fileOperations
        /// Events that apply to the file requests feature.
        case fileRequests
        /// Events that involve group management.
        case groups
        /// Events that involve users signing in to or out of Dropbox.
        case logins
        /// Events that involve team member management.
        case members
        /// Events that apply to Dropbox Paper.
        case paper
        /// Events that involve using, changing or resetting passwords.
        case passwords
        /// Events that concern generation of admin reports, including team activity and device usage.
        case reports
        /// Events that apply to all types of sharing and collaboration.
        case sharing
        /// Events that apply to Dropbox Showcase.
        case showcase
        /// Events that involve using or configuring single sign-on as well as administrative policies concerning single
        /// sign-on.
        case sso
        /// Events that involve team folder management.
        case teamFolders
        /// Events that involve a change in team-wide policies.
        case teamPolicies
        /// Events that involve a change in the team profile.
        case teamProfile
        /// Events that involve using or configuring two factor authentication as well as administrative policies
        /// concerning two factor authentication.
        case tfa
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(EventCategorySerializer().serialize(self)))"
        }
    }
    open class EventCategorySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: EventCategory) -> JSON {
            switch value {
                case .apps:
                    var d = [String: JSON]()
                    d[".tag"] = .str("apps")
                    return .dictionary(d)
                case .comments:
                    var d = [String: JSON]()
                    d[".tag"] = .str("comments")
                    return .dictionary(d)
                case .devices:
                    var d = [String: JSON]()
                    d[".tag"] = .str("devices")
                    return .dictionary(d)
                case .domains:
                    var d = [String: JSON]()
                    d[".tag"] = .str("domains")
                    return .dictionary(d)
                case .fileOperations:
                    var d = [String: JSON]()
                    d[".tag"] = .str("file_operations")
                    return .dictionary(d)
                case .fileRequests:
                    var d = [String: JSON]()
                    d[".tag"] = .str("file_requests")
                    return .dictionary(d)
                case .groups:
                    var d = [String: JSON]()
                    d[".tag"] = .str("groups")
                    return .dictionary(d)
                case .logins:
                    var d = [String: JSON]()
                    d[".tag"] = .str("logins")
                    return .dictionary(d)
                case .members:
                    var d = [String: JSON]()
                    d[".tag"] = .str("members")
                    return .dictionary(d)
                case .paper:
                    var d = [String: JSON]()
                    d[".tag"] = .str("paper")
                    return .dictionary(d)
                case .passwords:
                    var d = [String: JSON]()
                    d[".tag"] = .str("passwords")
                    return .dictionary(d)
                case .reports:
                    var d = [String: JSON]()
                    d[".tag"] = .str("reports")
                    return .dictionary(d)
                case .sharing:
                    var d = [String: JSON]()
                    d[".tag"] = .str("sharing")
                    return .dictionary(d)
                case .showcase:
                    var d = [String: JSON]()
                    d[".tag"] = .str("showcase")
                    return .dictionary(d)
                case .sso:
                    var d = [String: JSON]()
                    d[".tag"] = .str("sso")
                    return .dictionary(d)
                case .teamFolders:
                    var d = [String: JSON]()
                    d[".tag"] = .str("team_folders")
                    return .dictionary(d)
                case .teamPolicies:
                    var d = [String: JSON]()
                    d[".tag"] = .str("team_policies")
                    return .dictionary(d)
                case .teamProfile:
                    var d = [String: JSON]()
                    d[".tag"] = .str("team_profile")
                    return .dictionary(d)
                case .tfa:
                    var d = [String: JSON]()
                    d[".tag"] = .str("tfa")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> EventCategory {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "apps":
                            return EventCategory.apps
                        case "comments":
                            return EventCategory.comments
                        case "devices":
                            return EventCategory.devices
                        case "domains":
                            return EventCategory.domains
                        case "file_operations":
                            return EventCategory.fileOperations
                        case "file_requests":
                            return EventCategory.fileRequests
                        case "groups":
                            return EventCategory.groups
                        case "logins":
                            return EventCategory.logins
                        case "members":
                            return EventCategory.members
                        case "paper":
                            return EventCategory.paper
                        case "passwords":
                            return EventCategory.passwords
                        case "reports":
                            return EventCategory.reports
                        case "sharing":
                            return EventCategory.sharing
                        case "showcase":
                            return EventCategory.showcase
                        case "sso":
                            return EventCategory.sso
                        case "team_folders":
                            return EventCategory.teamFolders
                        case "team_policies":
                            return EventCategory.teamPolicies
                        case "team_profile":
                            return EventCategory.teamProfile
                        case "tfa":
                            return EventCategory.tfa
                        case "other":
                            return EventCategory.other
                        default:
                            return EventCategory.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Additional fields depending on the event type.
    public enum EventDetails: CustomStringConvertible {
        /// An unspecified error.
        case appLinkTeamDetails(TeamLog.AppLinkTeamDetails)
        /// An unspecified error.
        case appLinkUserDetails(TeamLog.AppLinkUserDetails)
        /// An unspecified error.
        case appUnlinkTeamDetails(TeamLog.AppUnlinkTeamDetails)
        /// An unspecified error.
        case appUnlinkUserDetails(TeamLog.AppUnlinkUserDetails)
        /// An unspecified error.
        case fileAddCommentDetails(TeamLog.FileAddCommentDetails)
        /// An unspecified error.
        case fileChangeCommentSubscriptionDetails(TeamLog.FileChangeCommentSubscriptionDetails)
        /// An unspecified error.
        case fileDeleteCommentDetails(TeamLog.FileDeleteCommentDetails)
        /// An unspecified error.
        case fileEditCommentDetails(TeamLog.FileEditCommentDetails)
        /// An unspecified error.
        case fileLikeCommentDetails(TeamLog.FileLikeCommentDetails)
        /// An unspecified error.
        case fileResolveCommentDetails(TeamLog.FileResolveCommentDetails)
        /// An unspecified error.
        case fileUnlikeCommentDetails(TeamLog.FileUnlikeCommentDetails)
        /// An unspecified error.
        case fileUnresolveCommentDetails(TeamLog.FileUnresolveCommentDetails)
        /// An unspecified error.
        case deviceChangeIpDesktopDetails(TeamLog.DeviceChangeIpDesktopDetails)
        /// An unspecified error.
        case deviceChangeIpMobileDetails(TeamLog.DeviceChangeIpMobileDetails)
        /// An unspecified error.
        case deviceChangeIpWebDetails(TeamLog.DeviceChangeIpWebDetails)
        /// An unspecified error.
        case deviceDeleteOnUnlinkFailDetails(TeamLog.DeviceDeleteOnUnlinkFailDetails)
        /// An unspecified error.
        case deviceDeleteOnUnlinkSuccessDetails(TeamLog.DeviceDeleteOnUnlinkSuccessDetails)
        /// An unspecified error.
        case deviceLinkFailDetails(TeamLog.DeviceLinkFailDetails)
        /// An unspecified error.
        case deviceLinkSuccessDetails(TeamLog.DeviceLinkSuccessDetails)
        /// An unspecified error.
        case deviceManagementDisabledDetails(TeamLog.DeviceManagementDisabledDetails)
        /// An unspecified error.
        case deviceManagementEnabledDetails(TeamLog.DeviceManagementEnabledDetails)
        /// An unspecified error.
        case deviceUnlinkDetails(TeamLog.DeviceUnlinkDetails)
        /// An unspecified error.
        case emmRefreshAuthTokenDetails(TeamLog.EmmRefreshAuthTokenDetails)
        /// An unspecified error.
        case accountCaptureChangeAvailabilityDetails(TeamLog.AccountCaptureChangeAvailabilityDetails)
        /// An unspecified error.
        case accountCaptureMigrateAccountDetails(TeamLog.AccountCaptureMigrateAccountDetails)
        /// An unspecified error.
        case accountCaptureNotificationEmailsSentDetails(TeamLog.AccountCaptureNotificationEmailsSentDetails)
        /// An unspecified error.
        case accountCaptureRelinquishAccountDetails(TeamLog.AccountCaptureRelinquishAccountDetails)
        /// An unspecified error.
        case disabledDomainInvitesDetails(TeamLog.DisabledDomainInvitesDetails)
        /// An unspecified error.
        case domainInvitesApproveRequestToJoinTeamDetails(TeamLog.DomainInvitesApproveRequestToJoinTeamDetails)
        /// An unspecified error.
        case domainInvitesDeclineRequestToJoinTeamDetails(TeamLog.DomainInvitesDeclineRequestToJoinTeamDetails)
        /// An unspecified error.
        case domainInvitesEmailExistingUsersDetails(TeamLog.DomainInvitesEmailExistingUsersDetails)
        /// An unspecified error.
        case domainInvitesRequestToJoinTeamDetails(TeamLog.DomainInvitesRequestToJoinTeamDetails)
        /// An unspecified error.
        case domainInvitesSetInviteNewUserPrefToNoDetails(TeamLog.DomainInvitesSetInviteNewUserPrefToNoDetails)
        /// An unspecified error.
        case domainInvitesSetInviteNewUserPrefToYesDetails(TeamLog.DomainInvitesSetInviteNewUserPrefToYesDetails)
        /// An unspecified error.
        case domainVerificationAddDomainFailDetails(TeamLog.DomainVerificationAddDomainFailDetails)
        /// An unspecified error.
        case domainVerificationAddDomainSuccessDetails(TeamLog.DomainVerificationAddDomainSuccessDetails)
        /// An unspecified error.
        case domainVerificationRemoveDomainDetails(TeamLog.DomainVerificationRemoveDomainDetails)
        /// An unspecified error.
        case enabledDomainInvitesDetails(TeamLog.EnabledDomainInvitesDetails)
        /// An unspecified error.
        case createFolderDetails(TeamLog.CreateFolderDetails)
        /// An unspecified error.
        case fileAddDetails(TeamLog.FileAddDetails)
        /// An unspecified error.
        case fileCopyDetails(TeamLog.FileCopyDetails)
        /// An unspecified error.
        case fileDeleteDetails(TeamLog.FileDeleteDetails)
        /// An unspecified error.
        case fileDownloadDetails(TeamLog.FileDownloadDetails)
        /// An unspecified error.
        case fileEditDetails(TeamLog.FileEditDetails)
        /// An unspecified error.
        case fileGetCopyReferenceDetails(TeamLog.FileGetCopyReferenceDetails)
        /// An unspecified error.
        case fileMoveDetails(TeamLog.FileMoveDetails)
        /// An unspecified error.
        case filePermanentlyDeleteDetails(TeamLog.FilePermanentlyDeleteDetails)
        /// An unspecified error.
        case filePreviewDetails(TeamLog.FilePreviewDetails)
        /// An unspecified error.
        case fileRenameDetails(TeamLog.FileRenameDetails)
        /// An unspecified error.
        case fileRestoreDetails(TeamLog.FileRestoreDetails)
        /// An unspecified error.
        case fileRevertDetails(TeamLog.FileRevertDetails)
        /// An unspecified error.
        case fileRollbackChangesDetails(TeamLog.FileRollbackChangesDetails)
        /// An unspecified error.
        case fileSaveCopyReferenceDetails(TeamLog.FileSaveCopyReferenceDetails)
        /// An unspecified error.
        case fileRequestChangeDetails(TeamLog.FileRequestChangeDetails)
        /// An unspecified error.
        case fileRequestCloseDetails(TeamLog.FileRequestCloseDetails)
        /// An unspecified error.
        case fileRequestCreateDetails(TeamLog.FileRequestCreateDetails)
        /// An unspecified error.
        case fileRequestReceiveFileDetails(TeamLog.FileRequestReceiveFileDetails)
        /// An unspecified error.
        case groupAddExternalIdDetails(TeamLog.GroupAddExternalIdDetails)
        /// An unspecified error.
        case groupAddMemberDetails(TeamLog.GroupAddMemberDetails)
        /// An unspecified error.
        case groupChangeExternalIdDetails(TeamLog.GroupChangeExternalIdDetails)
        /// An unspecified error.
        case groupChangeManagementTypeDetails(TeamLog.GroupChangeManagementTypeDetails)
        /// An unspecified error.
        case groupChangeMemberRoleDetails(TeamLog.GroupChangeMemberRoleDetails)
        /// An unspecified error.
        case groupCreateDetails(TeamLog.GroupCreateDetails)
        /// An unspecified error.
        case groupDeleteDetails(TeamLog.GroupDeleteDetails)
        /// An unspecified error.
        case groupDescriptionUpdatedDetails(TeamLog.GroupDescriptionUpdatedDetails)
        /// An unspecified error.
        case groupJoinPolicyUpdatedDetails(TeamLog.GroupJoinPolicyUpdatedDetails)
        /// An unspecified error.
        case groupMovedDetails(TeamLog.GroupMovedDetails)
        /// An unspecified error.
        case groupRemoveExternalIdDetails(TeamLog.GroupRemoveExternalIdDetails)
        /// An unspecified error.
        case groupRemoveMemberDetails(TeamLog.GroupRemoveMemberDetails)
        /// An unspecified error.
        case groupRenameDetails(TeamLog.GroupRenameDetails)
        /// An unspecified error.
        case emmErrorDetails(TeamLog.EmmErrorDetails)
        /// An unspecified error.
        case loginFailDetails(TeamLog.LoginFailDetails)
        /// An unspecified error.
        case loginSuccessDetails(TeamLog.LoginSuccessDetails)
        /// An unspecified error.
        case logoutDetails(TeamLog.LogoutDetails)
        /// An unspecified error.
        case resellerSupportSessionEndDetails(TeamLog.ResellerSupportSessionEndDetails)
        /// An unspecified error.
        case resellerSupportSessionStartDetails(TeamLog.ResellerSupportSessionStartDetails)
        /// An unspecified error.
        case signInAsSessionEndDetails(TeamLog.SignInAsSessionEndDetails)
        /// An unspecified error.
        case signInAsSessionStartDetails(TeamLog.SignInAsSessionStartDetails)
        /// An unspecified error.
        case ssoErrorDetails(TeamLog.SsoErrorDetails)
        /// An unspecified error.
        case memberAddNameDetails(TeamLog.MemberAddNameDetails)
        /// An unspecified error.
        case memberChangeAdminRoleDetails(TeamLog.MemberChangeAdminRoleDetails)
        /// An unspecified error.
        case memberChangeEmailDetails(TeamLog.MemberChangeEmailDetails)
        /// An unspecified error.
        case memberChangeMembershipTypeDetails(TeamLog.MemberChangeMembershipTypeDetails)
        /// An unspecified error.
        case memberChangeNameDetails(TeamLog.MemberChangeNameDetails)
        /// An unspecified error.
        case memberChangeStatusDetails(TeamLog.MemberChangeStatusDetails)
        /// An unspecified error.
        case memberDeleteManualContactsDetails(TeamLog.MemberDeleteManualContactsDetails)
        /// An unspecified error.
        case memberPermanentlyDeleteAccountContentsDetails(TeamLog.MemberPermanentlyDeleteAccountContentsDetails)
        /// An unspecified error.
        case memberSpaceLimitsAddCustomQuotaDetails(TeamLog.MemberSpaceLimitsAddCustomQuotaDetails)
        /// An unspecified error.
        case memberSpaceLimitsChangeCustomQuotaDetails(TeamLog.MemberSpaceLimitsChangeCustomQuotaDetails)
        /// An unspecified error.
        case memberSpaceLimitsChangeStatusDetails(TeamLog.MemberSpaceLimitsChangeStatusDetails)
        /// An unspecified error.
        case memberSpaceLimitsRemoveCustomQuotaDetails(TeamLog.MemberSpaceLimitsRemoveCustomQuotaDetails)
        /// An unspecified error.
        case memberSuggestDetails(TeamLog.MemberSuggestDetails)
        /// An unspecified error.
        case memberTransferAccountContentsDetails(TeamLog.MemberTransferAccountContentsDetails)
        /// An unspecified error.
        case secondaryMailsPolicyChangedDetails(TeamLog.SecondaryMailsPolicyChangedDetails)
        /// An unspecified error.
        case paperContentAddMemberDetails(TeamLog.PaperContentAddMemberDetails)
        /// An unspecified error.
        case paperContentAddToFolderDetails(TeamLog.PaperContentAddToFolderDetails)
        /// An unspecified error.
        case paperContentArchiveDetails(TeamLog.PaperContentArchiveDetails)
        /// An unspecified error.
        case paperContentCreateDetails(TeamLog.PaperContentCreateDetails)
        /// An unspecified error.
        case paperContentPermanentlyDeleteDetails(TeamLog.PaperContentPermanentlyDeleteDetails)
        /// An unspecified error.
        case paperContentRemoveFromFolderDetails(TeamLog.PaperContentRemoveFromFolderDetails)
        /// An unspecified error.
        case paperContentRemoveMemberDetails(TeamLog.PaperContentRemoveMemberDetails)
        /// An unspecified error.
        case paperContentRenameDetails(TeamLog.PaperContentRenameDetails)
        /// An unspecified error.
        case paperContentRestoreDetails(TeamLog.PaperContentRestoreDetails)
        /// An unspecified error.
        case paperDocAddCommentDetails(TeamLog.PaperDocAddCommentDetails)
        /// An unspecified error.
        case paperDocChangeMemberRoleDetails(TeamLog.PaperDocChangeMemberRoleDetails)
        /// An unspecified error.
        case paperDocChangeSharingPolicyDetails(TeamLog.PaperDocChangeSharingPolicyDetails)
        /// An unspecified error.
        case paperDocChangeSubscriptionDetails(TeamLog.PaperDocChangeSubscriptionDetails)
        /// An unspecified error.
        case paperDocDeletedDetails(TeamLog.PaperDocDeletedDetails)
        /// An unspecified error.
        case paperDocDeleteCommentDetails(TeamLog.PaperDocDeleteCommentDetails)
        /// An unspecified error.
        case paperDocDownloadDetails(TeamLog.PaperDocDownloadDetails)
        /// An unspecified error.
        case paperDocEditDetails(TeamLog.PaperDocEditDetails)
        /// An unspecified error.
        case paperDocEditCommentDetails(TeamLog.PaperDocEditCommentDetails)
        /// An unspecified error.
        case paperDocFollowedDetails(TeamLog.PaperDocFollowedDetails)
        /// An unspecified error.
        case paperDocMentionDetails(TeamLog.PaperDocMentionDetails)
        /// An unspecified error.
        case paperDocOwnershipChangedDetails(TeamLog.PaperDocOwnershipChangedDetails)
        /// An unspecified error.
        case paperDocRequestAccessDetails(TeamLog.PaperDocRequestAccessDetails)
        /// An unspecified error.
        case paperDocResolveCommentDetails(TeamLog.PaperDocResolveCommentDetails)
        /// An unspecified error.
        case paperDocRevertDetails(TeamLog.PaperDocRevertDetails)
        /// An unspecified error.
        case paperDocSlackShareDetails(TeamLog.PaperDocSlackShareDetails)
        /// An unspecified error.
        case paperDocTeamInviteDetails(TeamLog.PaperDocTeamInviteDetails)
        /// An unspecified error.
        case paperDocTrashedDetails(TeamLog.PaperDocTrashedDetails)
        /// An unspecified error.
        case paperDocUnresolveCommentDetails(TeamLog.PaperDocUnresolveCommentDetails)
        /// An unspecified error.
        case paperDocUntrashedDetails(TeamLog.PaperDocUntrashedDetails)
        /// An unspecified error.
        case paperDocViewDetails(TeamLog.PaperDocViewDetails)
        /// An unspecified error.
        case paperExternalViewAllowDetails(TeamLog.PaperExternalViewAllowDetails)
        /// An unspecified error.
        case paperExternalViewDefaultTeamDetails(TeamLog.PaperExternalViewDefaultTeamDetails)
        /// An unspecified error.
        case paperExternalViewForbidDetails(TeamLog.PaperExternalViewForbidDetails)
        /// An unspecified error.
        case paperFolderChangeSubscriptionDetails(TeamLog.PaperFolderChangeSubscriptionDetails)
        /// An unspecified error.
        case paperFolderDeletedDetails(TeamLog.PaperFolderDeletedDetails)
        /// An unspecified error.
        case paperFolderFollowedDetails(TeamLog.PaperFolderFollowedDetails)
        /// An unspecified error.
        case paperFolderTeamInviteDetails(TeamLog.PaperFolderTeamInviteDetails)
        /// An unspecified error.
        case passwordChangeDetails(TeamLog.PasswordChangeDetails)
        /// An unspecified error.
        case passwordResetDetails(TeamLog.PasswordResetDetails)
        /// An unspecified error.
        case passwordResetAllDetails(TeamLog.PasswordResetAllDetails)
        /// An unspecified error.
        case emmCreateExceptionsReportDetails(TeamLog.EmmCreateExceptionsReportDetails)
        /// An unspecified error.
        case emmCreateUsageReportDetails(TeamLog.EmmCreateUsageReportDetails)
        /// An unspecified error.
        case exportMembersReportDetails(TeamLog.ExportMembersReportDetails)
        /// An unspecified error.
        case paperAdminExportStartDetails(TeamLog.PaperAdminExportStartDetails)
        /// An unspecified error.
        case smartSyncCreateAdminPrivilegeReportDetails(TeamLog.SmartSyncCreateAdminPrivilegeReportDetails)
        /// An unspecified error.
        case teamActivityCreateReportDetails(TeamLog.TeamActivityCreateReportDetails)
        /// An unspecified error.
        case collectionShareDetails(TeamLog.CollectionShareDetails)
        /// An unspecified error.
        case noteAclInviteOnlyDetails(TeamLog.NoteAclInviteOnlyDetails)
        /// An unspecified error.
        case noteAclLinkDetails(TeamLog.NoteAclLinkDetails)
        /// An unspecified error.
        case noteAclTeamLinkDetails(TeamLog.NoteAclTeamLinkDetails)
        /// An unspecified error.
        case noteSharedDetails(TeamLog.NoteSharedDetails)
        /// An unspecified error.
        case noteShareReceiveDetails(TeamLog.NoteShareReceiveDetails)
        /// An unspecified error.
        case openNoteSharedDetails(TeamLog.OpenNoteSharedDetails)
        /// An unspecified error.
        case sfAddGroupDetails(TeamLog.SfAddGroupDetails)
        /// An unspecified error.
        case sfAllowNonMembersToViewSharedLinksDetails(TeamLog.SfAllowNonMembersToViewSharedLinksDetails)
        /// An unspecified error.
        case sfExternalInviteWarnDetails(TeamLog.SfExternalInviteWarnDetails)
        /// An unspecified error.
        case sfFbInviteDetails(TeamLog.SfFbInviteDetails)
        /// An unspecified error.
        case sfFbInviteChangeRoleDetails(TeamLog.SfFbInviteChangeRoleDetails)
        /// An unspecified error.
        case sfFbUninviteDetails(TeamLog.SfFbUninviteDetails)
        /// An unspecified error.
        case sfInviteGroupDetails(TeamLog.SfInviteGroupDetails)
        /// An unspecified error.
        case sfTeamGrantAccessDetails(TeamLog.SfTeamGrantAccessDetails)
        /// An unspecified error.
        case sfTeamInviteDetails(TeamLog.SfTeamInviteDetails)
        /// An unspecified error.
        case sfTeamInviteChangeRoleDetails(TeamLog.SfTeamInviteChangeRoleDetails)
        /// An unspecified error.
        case sfTeamJoinDetails(TeamLog.SfTeamJoinDetails)
        /// An unspecified error.
        case sfTeamJoinFromOobLinkDetails(TeamLog.SfTeamJoinFromOobLinkDetails)
        /// An unspecified error.
        case sfTeamUninviteDetails(TeamLog.SfTeamUninviteDetails)
        /// An unspecified error.
        case sharedContentAddInviteesDetails(TeamLog.SharedContentAddInviteesDetails)
        /// An unspecified error.
        case sharedContentAddLinkExpiryDetails(TeamLog.SharedContentAddLinkExpiryDetails)
        /// An unspecified error.
        case sharedContentAddLinkPasswordDetails(TeamLog.SharedContentAddLinkPasswordDetails)
        /// An unspecified error.
        case sharedContentAddMemberDetails(TeamLog.SharedContentAddMemberDetails)
        /// An unspecified error.
        case sharedContentChangeDownloadsPolicyDetails(TeamLog.SharedContentChangeDownloadsPolicyDetails)
        /// An unspecified error.
        case sharedContentChangeInviteeRoleDetails(TeamLog.SharedContentChangeInviteeRoleDetails)
        /// An unspecified error.
        case sharedContentChangeLinkAudienceDetails(TeamLog.SharedContentChangeLinkAudienceDetails)
        /// An unspecified error.
        case sharedContentChangeLinkExpiryDetails(TeamLog.SharedContentChangeLinkExpiryDetails)
        /// An unspecified error.
        case sharedContentChangeLinkPasswordDetails(TeamLog.SharedContentChangeLinkPasswordDetails)
        /// An unspecified error.
        case sharedContentChangeMemberRoleDetails(TeamLog.SharedContentChangeMemberRoleDetails)
        /// An unspecified error.
        case sharedContentChangeViewerInfoPolicyDetails(TeamLog.SharedContentChangeViewerInfoPolicyDetails)
        /// An unspecified error.
        case sharedContentClaimInvitationDetails(TeamLog.SharedContentClaimInvitationDetails)
        /// An unspecified error.
        case sharedContentCopyDetails(TeamLog.SharedContentCopyDetails)
        /// An unspecified error.
        case sharedContentDownloadDetails(TeamLog.SharedContentDownloadDetails)
        /// An unspecified error.
        case sharedContentRelinquishMembershipDetails(TeamLog.SharedContentRelinquishMembershipDetails)
        /// An unspecified error.
        case sharedContentRemoveInviteesDetails(TeamLog.SharedContentRemoveInviteesDetails)
        /// An unspecified error.
        case sharedContentRemoveLinkExpiryDetails(TeamLog.SharedContentRemoveLinkExpiryDetails)
        /// An unspecified error.
        case sharedContentRemoveLinkPasswordDetails(TeamLog.SharedContentRemoveLinkPasswordDetails)
        /// An unspecified error.
        case sharedContentRemoveMemberDetails(TeamLog.SharedContentRemoveMemberDetails)
        /// An unspecified error.
        case sharedContentRequestAccessDetails(TeamLog.SharedContentRequestAccessDetails)
        /// An unspecified error.
        case sharedContentUnshareDetails(TeamLog.SharedContentUnshareDetails)
        /// An unspecified error.
        case sharedContentViewDetails(TeamLog.SharedContentViewDetails)
        /// An unspecified error.
        case sharedFolderChangeLinkPolicyDetails(TeamLog.SharedFolderChangeLinkPolicyDetails)
        /// An unspecified error.
        case sharedFolderChangeMembersInheritancePolicyDetails(TeamLog.SharedFolderChangeMembersInheritancePolicyDetails)
        /// An unspecified error.
        case sharedFolderChangeMembersManagementPolicyDetails(TeamLog.SharedFolderChangeMembersManagementPolicyDetails)
        /// An unspecified error.
        case sharedFolderChangeMembersPolicyDetails(TeamLog.SharedFolderChangeMembersPolicyDetails)
        /// An unspecified error.
        case sharedFolderCreateDetails(TeamLog.SharedFolderCreateDetails)
        /// An unspecified error.
        case sharedFolderDeclineInvitationDetails(TeamLog.SharedFolderDeclineInvitationDetails)
        /// An unspecified error.
        case sharedFolderMountDetails(TeamLog.SharedFolderMountDetails)
        /// An unspecified error.
        case sharedFolderNestDetails(TeamLog.SharedFolderNestDetails)
        /// An unspecified error.
        case sharedFolderTransferOwnershipDetails(TeamLog.SharedFolderTransferOwnershipDetails)
        /// An unspecified error.
        case sharedFolderUnmountDetails(TeamLog.SharedFolderUnmountDetails)
        /// An unspecified error.
        case sharedLinkAddExpiryDetails(TeamLog.SharedLinkAddExpiryDetails)
        /// An unspecified error.
        case sharedLinkChangeExpiryDetails(TeamLog.SharedLinkChangeExpiryDetails)
        /// An unspecified error.
        case sharedLinkChangeVisibilityDetails(TeamLog.SharedLinkChangeVisibilityDetails)
        /// An unspecified error.
        case sharedLinkCopyDetails(TeamLog.SharedLinkCopyDetails)
        /// An unspecified error.
        case sharedLinkCreateDetails(TeamLog.SharedLinkCreateDetails)
        /// An unspecified error.
        case sharedLinkDisableDetails(TeamLog.SharedLinkDisableDetails)
        /// An unspecified error.
        case sharedLinkDownloadDetails(TeamLog.SharedLinkDownloadDetails)
        /// An unspecified error.
        case sharedLinkRemoveExpiryDetails(TeamLog.SharedLinkRemoveExpiryDetails)
        /// An unspecified error.
        case sharedLinkShareDetails(TeamLog.SharedLinkShareDetails)
        /// An unspecified error.
        case sharedLinkViewDetails(TeamLog.SharedLinkViewDetails)
        /// An unspecified error.
        case sharedNoteOpenedDetails(TeamLog.SharedNoteOpenedDetails)
        /// An unspecified error.
        case shmodelGroupShareDetails(TeamLog.ShmodelGroupShareDetails)
        /// An unspecified error.
        case showcaseAccessGrantedDetails(TeamLog.ShowcaseAccessGrantedDetails)
        /// An unspecified error.
        case showcaseAddMemberDetails(TeamLog.ShowcaseAddMemberDetails)
        /// An unspecified error.
        case showcaseArchivedDetails(TeamLog.ShowcaseArchivedDetails)
        /// An unspecified error.
        case showcaseCreatedDetails(TeamLog.ShowcaseCreatedDetails)
        /// An unspecified error.
        case showcaseDeleteCommentDetails(TeamLog.ShowcaseDeleteCommentDetails)
        /// An unspecified error.
        case showcaseEditedDetails(TeamLog.ShowcaseEditedDetails)
        /// An unspecified error.
        case showcaseEditCommentDetails(TeamLog.ShowcaseEditCommentDetails)
        /// An unspecified error.
        case showcaseFileAddedDetails(TeamLog.ShowcaseFileAddedDetails)
        /// An unspecified error.
        case showcaseFileDownloadDetails(TeamLog.ShowcaseFileDownloadDetails)
        /// An unspecified error.
        case showcaseFileRemovedDetails(TeamLog.ShowcaseFileRemovedDetails)
        /// An unspecified error.
        case showcaseFileViewDetails(TeamLog.ShowcaseFileViewDetails)
        /// An unspecified error.
        case showcasePermanentlyDeletedDetails(TeamLog.ShowcasePermanentlyDeletedDetails)
        /// An unspecified error.
        case showcasePostCommentDetails(TeamLog.ShowcasePostCommentDetails)
        /// An unspecified error.
        case showcaseRemoveMemberDetails(TeamLog.ShowcaseRemoveMemberDetails)
        /// An unspecified error.
        case showcaseRenamedDetails(TeamLog.ShowcaseRenamedDetails)
        /// An unspecified error.
        case showcaseRequestAccessDetails(TeamLog.ShowcaseRequestAccessDetails)
        /// An unspecified error.
        case showcaseResolveCommentDetails(TeamLog.ShowcaseResolveCommentDetails)
        /// An unspecified error.
        case showcaseRestoredDetails(TeamLog.ShowcaseRestoredDetails)
        /// An unspecified error.
        case showcaseTrashedDetails(TeamLog.ShowcaseTrashedDetails)
        /// An unspecified error.
        case showcaseTrashedDeprecatedDetails(TeamLog.ShowcaseTrashedDeprecatedDetails)
        /// An unspecified error.
        case showcaseUnresolveCommentDetails(TeamLog.ShowcaseUnresolveCommentDetails)
        /// An unspecified error.
        case showcaseUntrashedDetails(TeamLog.ShowcaseUntrashedDetails)
        /// An unspecified error.
        case showcaseUntrashedDeprecatedDetails(TeamLog.ShowcaseUntrashedDeprecatedDetails)
        /// An unspecified error.
        case showcaseViewDetails(TeamLog.ShowcaseViewDetails)
        /// An unspecified error.
        case ssoAddCertDetails(TeamLog.SsoAddCertDetails)
        /// An unspecified error.
        case ssoAddLoginUrlDetails(TeamLog.SsoAddLoginUrlDetails)
        /// An unspecified error.
        case ssoAddLogoutUrlDetails(TeamLog.SsoAddLogoutUrlDetails)
        /// An unspecified error.
        case ssoChangeCertDetails(TeamLog.SsoChangeCertDetails)
        /// An unspecified error.
        case ssoChangeLoginUrlDetails(TeamLog.SsoChangeLoginUrlDetails)
        /// An unspecified error.
        case ssoChangeLogoutUrlDetails(TeamLog.SsoChangeLogoutUrlDetails)
        /// An unspecified error.
        case ssoChangeSamlIdentityModeDetails(TeamLog.SsoChangeSamlIdentityModeDetails)
        /// An unspecified error.
        case ssoRemoveCertDetails(TeamLog.SsoRemoveCertDetails)
        /// An unspecified error.
        case ssoRemoveLoginUrlDetails(TeamLog.SsoRemoveLoginUrlDetails)
        /// An unspecified error.
        case ssoRemoveLogoutUrlDetails(TeamLog.SsoRemoveLogoutUrlDetails)
        /// An unspecified error.
        case teamFolderChangeStatusDetails(TeamLog.TeamFolderChangeStatusDetails)
        /// An unspecified error.
        case teamFolderCreateDetails(TeamLog.TeamFolderCreateDetails)
        /// An unspecified error.
        case teamFolderDowngradeDetails(TeamLog.TeamFolderDowngradeDetails)
        /// An unspecified error.
        case teamFolderPermanentlyDeleteDetails(TeamLog.TeamFolderPermanentlyDeleteDetails)
        /// An unspecified error.
        case teamFolderRenameDetails(TeamLog.TeamFolderRenameDetails)
        /// An unspecified error.
        case teamSelectiveSyncSettingsChangedDetails(TeamLog.TeamSelectiveSyncSettingsChangedDetails)
        /// An unspecified error.
        case accountCaptureChangePolicyDetails(TeamLog.AccountCaptureChangePolicyDetails)
        /// An unspecified error.
        case allowDownloadDisabledDetails(TeamLog.AllowDownloadDisabledDetails)
        /// An unspecified error.
        case allowDownloadEnabledDetails(TeamLog.AllowDownloadEnabledDetails)
        /// An unspecified error.
        case cameraUploadsPolicyChangedDetails(TeamLog.CameraUploadsPolicyChangedDetails)
        /// An unspecified error.
        case dataPlacementRestrictionChangePolicyDetails(TeamLog.DataPlacementRestrictionChangePolicyDetails)
        /// An unspecified error.
        case dataPlacementRestrictionSatisfyPolicyDetails(TeamLog.DataPlacementRestrictionSatisfyPolicyDetails)
        /// An unspecified error.
        case deviceApprovalsChangeDesktopPolicyDetails(TeamLog.DeviceApprovalsChangeDesktopPolicyDetails)
        /// An unspecified error.
        case deviceApprovalsChangeMobilePolicyDetails(TeamLog.DeviceApprovalsChangeMobilePolicyDetails)
        /// An unspecified error.
        case deviceApprovalsChangeOverageActionDetails(TeamLog.DeviceApprovalsChangeOverageActionDetails)
        /// An unspecified error.
        case deviceApprovalsChangeUnlinkActionDetails(TeamLog.DeviceApprovalsChangeUnlinkActionDetails)
        /// An unspecified error.
        case directoryRestrictionsAddMembersDetails(TeamLog.DirectoryRestrictionsAddMembersDetails)
        /// An unspecified error.
        case directoryRestrictionsRemoveMembersDetails(TeamLog.DirectoryRestrictionsRemoveMembersDetails)
        /// An unspecified error.
        case emmAddExceptionDetails(TeamLog.EmmAddExceptionDetails)
        /// An unspecified error.
        case emmChangePolicyDetails(TeamLog.EmmChangePolicyDetails)
        /// An unspecified error.
        case emmRemoveExceptionDetails(TeamLog.EmmRemoveExceptionDetails)
        /// An unspecified error.
        case extendedVersionHistoryChangePolicyDetails(TeamLog.ExtendedVersionHistoryChangePolicyDetails)
        /// An unspecified error.
        case fileCommentsChangePolicyDetails(TeamLog.FileCommentsChangePolicyDetails)
        /// An unspecified error.
        case fileRequestsChangePolicyDetails(TeamLog.FileRequestsChangePolicyDetails)
        /// An unspecified error.
        case fileRequestsEmailsEnabledDetails(TeamLog.FileRequestsEmailsEnabledDetails)
        /// An unspecified error.
        case fileRequestsEmailsRestrictedToTeamOnlyDetails(TeamLog.FileRequestsEmailsRestrictedToTeamOnlyDetails)
        /// An unspecified error.
        case googleSsoChangePolicyDetails(TeamLog.GoogleSsoChangePolicyDetails)
        /// An unspecified error.
        case groupUserManagementChangePolicyDetails(TeamLog.GroupUserManagementChangePolicyDetails)
        /// An unspecified error.
        case memberRequestsChangePolicyDetails(TeamLog.MemberRequestsChangePolicyDetails)
        /// An unspecified error.
        case memberSpaceLimitsAddExceptionDetails(TeamLog.MemberSpaceLimitsAddExceptionDetails)
        /// An unspecified error.
        case memberSpaceLimitsChangeCapsTypePolicyDetails(TeamLog.MemberSpaceLimitsChangeCapsTypePolicyDetails)
        /// An unspecified error.
        case memberSpaceLimitsChangePolicyDetails(TeamLog.MemberSpaceLimitsChangePolicyDetails)
        /// An unspecified error.
        case memberSpaceLimitsRemoveExceptionDetails(TeamLog.MemberSpaceLimitsRemoveExceptionDetails)
        /// An unspecified error.
        case memberSuggestionsChangePolicyDetails(TeamLog.MemberSuggestionsChangePolicyDetails)
        /// An unspecified error.
        case microsoftOfficeAddinChangePolicyDetails(TeamLog.MicrosoftOfficeAddinChangePolicyDetails)
        /// An unspecified error.
        case networkControlChangePolicyDetails(TeamLog.NetworkControlChangePolicyDetails)
        /// An unspecified error.
        case paperChangeDeploymentPolicyDetails(TeamLog.PaperChangeDeploymentPolicyDetails)
        /// An unspecified error.
        case paperChangeMemberLinkPolicyDetails(TeamLog.PaperChangeMemberLinkPolicyDetails)
        /// An unspecified error.
        case paperChangeMemberPolicyDetails(TeamLog.PaperChangeMemberPolicyDetails)
        /// An unspecified error.
        case paperChangePolicyDetails(TeamLog.PaperChangePolicyDetails)
        /// An unspecified error.
        case paperEnabledUsersGroupAdditionDetails(TeamLog.PaperEnabledUsersGroupAdditionDetails)
        /// An unspecified error.
        case paperEnabledUsersGroupRemovalDetails(TeamLog.PaperEnabledUsersGroupRemovalDetails)
        /// An unspecified error.
        case permanentDeleteChangePolicyDetails(TeamLog.PermanentDeleteChangePolicyDetails)
        /// An unspecified error.
        case sharingChangeFolderJoinPolicyDetails(TeamLog.SharingChangeFolderJoinPolicyDetails)
        /// An unspecified error.
        case sharingChangeLinkPolicyDetails(TeamLog.SharingChangeLinkPolicyDetails)
        /// An unspecified error.
        case sharingChangeMemberPolicyDetails(TeamLog.SharingChangeMemberPolicyDetails)
        /// An unspecified error.
        case showcaseChangeDownloadPolicyDetails(TeamLog.ShowcaseChangeDownloadPolicyDetails)
        /// An unspecified error.
        case showcaseChangeEnabledPolicyDetails(TeamLog.ShowcaseChangeEnabledPolicyDetails)
        /// An unspecified error.
        case showcaseChangeExternalSharingPolicyDetails(TeamLog.ShowcaseChangeExternalSharingPolicyDetails)
        /// An unspecified error.
        case smartSyncChangePolicyDetails(TeamLog.SmartSyncChangePolicyDetails)
        /// An unspecified error.
        case smartSyncNotOptOutDetails(TeamLog.SmartSyncNotOptOutDetails)
        /// An unspecified error.
        case smartSyncOptOutDetails(TeamLog.SmartSyncOptOutDetails)
        /// An unspecified error.
        case ssoChangePolicyDetails(TeamLog.SsoChangePolicyDetails)
        /// An unspecified error.
        case teamSelectiveSyncPolicyChangedDetails(TeamLog.TeamSelectiveSyncPolicyChangedDetails)
        /// An unspecified error.
        case tfaChangePolicyDetails(TeamLog.TfaChangePolicyDetails)
        /// An unspecified error.
        case twoAccountChangePolicyDetails(TeamLog.TwoAccountChangePolicyDetails)
        /// An unspecified error.
        case viewerInfoPolicyChangedDetails(TeamLog.ViewerInfoPolicyChangedDetails)
        /// An unspecified error.
        case webSessionsChangeFixedLengthPolicyDetails(TeamLog.WebSessionsChangeFixedLengthPolicyDetails)
        /// An unspecified error.
        case webSessionsChangeIdleLengthPolicyDetails(TeamLog.WebSessionsChangeIdleLengthPolicyDetails)
        /// An unspecified error.
        case teamMergeFromDetails(TeamLog.TeamMergeFromDetails)
        /// An unspecified error.
        case teamMergeToDetails(TeamLog.TeamMergeToDetails)
        /// An unspecified error.
        case teamProfileAddLogoDetails(TeamLog.TeamProfileAddLogoDetails)
        /// An unspecified error.
        case teamProfileChangeDefaultLanguageDetails(TeamLog.TeamProfileChangeDefaultLanguageDetails)
        /// An unspecified error.
        case teamProfileChangeLogoDetails(TeamLog.TeamProfileChangeLogoDetails)
        /// An unspecified error.
        case teamProfileChangeNameDetails(TeamLog.TeamProfileChangeNameDetails)
        /// An unspecified error.
        case teamProfileRemoveLogoDetails(TeamLog.TeamProfileRemoveLogoDetails)
        /// An unspecified error.
        case tfaAddBackupPhoneDetails(TeamLog.TfaAddBackupPhoneDetails)
        /// An unspecified error.
        case tfaAddSecurityKeyDetails(TeamLog.TfaAddSecurityKeyDetails)
        /// An unspecified error.
        case tfaChangeBackupPhoneDetails(TeamLog.TfaChangeBackupPhoneDetails)
        /// An unspecified error.
        case tfaChangeStatusDetails(TeamLog.TfaChangeStatusDetails)
        /// An unspecified error.
        case tfaRemoveBackupPhoneDetails(TeamLog.TfaRemoveBackupPhoneDetails)
        /// An unspecified error.
        case tfaRemoveSecurityKeyDetails(TeamLog.TfaRemoveSecurityKeyDetails)
        /// An unspecified error.
        case tfaResetDetails(TeamLog.TfaResetDetails)
        /// Hints that this event was returned with missing details due to an internal error.
        case missingDetails(TeamLog.MissingDetails)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(EventDetailsSerializer().serialize(self)))"
        }
    }
    open class EventDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: EventDetails) -> JSON {
            switch value {
                case .appLinkTeamDetails(let arg):
                    var d = Serialization.getFields(TeamLog.AppLinkTeamDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("app_link_team_details")
                    return .dictionary(d)
                case .appLinkUserDetails(let arg):
                    var d = Serialization.getFields(TeamLog.AppLinkUserDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("app_link_user_details")
                    return .dictionary(d)
                case .appUnlinkTeamDetails(let arg):
                    var d = Serialization.getFields(TeamLog.AppUnlinkTeamDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("app_unlink_team_details")
                    return .dictionary(d)
                case .appUnlinkUserDetails(let arg):
                    var d = Serialization.getFields(TeamLog.AppUnlinkUserDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("app_unlink_user_details")
                    return .dictionary(d)
                case .fileAddCommentDetails(let arg):
                    var d = Serialization.getFields(TeamLog.FileAddCommentDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("file_add_comment_details")
                    return .dictionary(d)
                case .fileChangeCommentSubscriptionDetails(let arg):
                    var d = Serialization.getFields(TeamLog.FileChangeCommentSubscriptionDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("file_change_comment_subscription_details")
                    return .dictionary(d)
                case .fileDeleteCommentDetails(let arg):
                    var d = Serialization.getFields(TeamLog.FileDeleteCommentDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("file_delete_comment_details")
                    return .dictionary(d)
                case .fileEditCommentDetails(let arg):
                    var d = Serialization.getFields(TeamLog.FileEditCommentDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("file_edit_comment_details")
                    return .dictionary(d)
                case .fileLikeCommentDetails(let arg):
                    var d = Serialization.getFields(TeamLog.FileLikeCommentDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("file_like_comment_details")
                    return .dictionary(d)
                case .fileResolveCommentDetails(let arg):
                    var d = Serialization.getFields(TeamLog.FileResolveCommentDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("file_resolve_comment_details")
                    return .dictionary(d)
                case .fileUnlikeCommentDetails(let arg):
                    var d = Serialization.getFields(TeamLog.FileUnlikeCommentDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("file_unlike_comment_details")
                    return .dictionary(d)
                case .fileUnresolveCommentDetails(let arg):
                    var d = Serialization.getFields(TeamLog.FileUnresolveCommentDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("file_unresolve_comment_details")
                    return .dictionary(d)
                case .deviceChangeIpDesktopDetails(let arg):
                    var d = Serialization.getFields(TeamLog.DeviceChangeIpDesktopDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("device_change_ip_desktop_details")
                    return .dictionary(d)
                case .deviceChangeIpMobileDetails(let arg):
                    var d = Serialization.getFields(TeamLog.DeviceChangeIpMobileDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("device_change_ip_mobile_details")
                    return .dictionary(d)
                case .deviceChangeIpWebDetails(let arg):
                    var d = Serialization.getFields(TeamLog.DeviceChangeIpWebDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("device_change_ip_web_details")
                    return .dictionary(d)
                case .deviceDeleteOnUnlinkFailDetails(let arg):
                    var d = Serialization.getFields(TeamLog.DeviceDeleteOnUnlinkFailDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("device_delete_on_unlink_fail_details")
                    return .dictionary(d)
                case .deviceDeleteOnUnlinkSuccessDetails(let arg):
                    var d = Serialization.getFields(TeamLog.DeviceDeleteOnUnlinkSuccessDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("device_delete_on_unlink_success_details")
                    return .dictionary(d)
                case .deviceLinkFailDetails(let arg):
                    var d = Serialization.getFields(TeamLog.DeviceLinkFailDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("device_link_fail_details")
                    return .dictionary(d)
                case .deviceLinkSuccessDetails(let arg):
                    var d = Serialization.getFields(TeamLog.DeviceLinkSuccessDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("device_link_success_details")
                    return .dictionary(d)
                case .deviceManagementDisabledDetails(let arg):
                    var d = Serialization.getFields(TeamLog.DeviceManagementDisabledDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("device_management_disabled_details")
                    return .dictionary(d)
                case .deviceManagementEnabledDetails(let arg):
                    var d = Serialization.getFields(TeamLog.DeviceManagementEnabledDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("device_management_enabled_details")
                    return .dictionary(d)
                case .deviceUnlinkDetails(let arg):
                    var d = Serialization.getFields(TeamLog.DeviceUnlinkDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("device_unlink_details")
                    return .dictionary(d)
                case .emmRefreshAuthTokenDetails(let arg):
                    var d = Serialization.getFields(TeamLog.EmmRefreshAuthTokenDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("emm_refresh_auth_token_details")
                    return .dictionary(d)
                case .accountCaptureChangeAvailabilityDetails(let arg):
                    var d = Serialization.getFields(TeamLog.AccountCaptureChangeAvailabilityDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("account_capture_change_availability_details")
                    return .dictionary(d)
                case .accountCaptureMigrateAccountDetails(let arg):
                    var d = Serialization.getFields(TeamLog.AccountCaptureMigrateAccountDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("account_capture_migrate_account_details")
                    return .dictionary(d)
                case .accountCaptureNotificationEmailsSentDetails(let arg):
                    var d = Serialization.getFields(TeamLog.AccountCaptureNotificationEmailsSentDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("account_capture_notification_emails_sent_details")
                    return .dictionary(d)
                case .accountCaptureRelinquishAccountDetails(let arg):
                    var d = Serialization.getFields(TeamLog.AccountCaptureRelinquishAccountDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("account_capture_relinquish_account_details")
                    return .dictionary(d)
                case .disabledDomainInvitesDetails(let arg):
                    var d = Serialization.getFields(TeamLog.DisabledDomainInvitesDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("disabled_domain_invites_details")
                    return .dictionary(d)
                case .domainInvitesApproveRequestToJoinTeamDetails(let arg):
                    var d = Serialization.getFields(TeamLog.DomainInvitesApproveRequestToJoinTeamDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("domain_invites_approve_request_to_join_team_details")
                    return .dictionary(d)
                case .domainInvitesDeclineRequestToJoinTeamDetails(let arg):
                    var d = Serialization.getFields(TeamLog.DomainInvitesDeclineRequestToJoinTeamDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("domain_invites_decline_request_to_join_team_details")
                    return .dictionary(d)
                case .domainInvitesEmailExistingUsersDetails(let arg):
                    var d = Serialization.getFields(TeamLog.DomainInvitesEmailExistingUsersDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("domain_invites_email_existing_users_details")
                    return .dictionary(d)
                case .domainInvitesRequestToJoinTeamDetails(let arg):
                    var d = Serialization.getFields(TeamLog.DomainInvitesRequestToJoinTeamDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("domain_invites_request_to_join_team_details")
                    return .dictionary(d)
                case .domainInvitesSetInviteNewUserPrefToNoDetails(let arg):
                    var d = Serialization.getFields(TeamLog.DomainInvitesSetInviteNewUserPrefToNoDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("domain_invites_set_invite_new_user_pref_to_no_details")
                    return .dictionary(d)
                case .domainInvitesSetInviteNewUserPrefToYesDetails(let arg):
                    var d = Serialization.getFields(TeamLog.DomainInvitesSetInviteNewUserPrefToYesDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("domain_invites_set_invite_new_user_pref_to_yes_details")
                    return .dictionary(d)
                case .domainVerificationAddDomainFailDetails(let arg):
                    var d = Serialization.getFields(TeamLog.DomainVerificationAddDomainFailDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("domain_verification_add_domain_fail_details")
                    return .dictionary(d)
                case .domainVerificationAddDomainSuccessDetails(let arg):
                    var d = Serialization.getFields(TeamLog.DomainVerificationAddDomainSuccessDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("domain_verification_add_domain_success_details")
                    return .dictionary(d)
                case .domainVerificationRemoveDomainDetails(let arg):
                    var d = Serialization.getFields(TeamLog.DomainVerificationRemoveDomainDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("domain_verification_remove_domain_details")
                    return .dictionary(d)
                case .enabledDomainInvitesDetails(let arg):
                    var d = Serialization.getFields(TeamLog.EnabledDomainInvitesDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("enabled_domain_invites_details")
                    return .dictionary(d)
                case .createFolderDetails(let arg):
                    var d = Serialization.getFields(TeamLog.CreateFolderDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("create_folder_details")
                    return .dictionary(d)
                case .fileAddDetails(let arg):
                    var d = Serialization.getFields(TeamLog.FileAddDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("file_add_details")
                    return .dictionary(d)
                case .fileCopyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.FileCopyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("file_copy_details")
                    return .dictionary(d)
                case .fileDeleteDetails(let arg):
                    var d = Serialization.getFields(TeamLog.FileDeleteDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("file_delete_details")
                    return .dictionary(d)
                case .fileDownloadDetails(let arg):
                    var d = Serialization.getFields(TeamLog.FileDownloadDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("file_download_details")
                    return .dictionary(d)
                case .fileEditDetails(let arg):
                    var d = Serialization.getFields(TeamLog.FileEditDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("file_edit_details")
                    return .dictionary(d)
                case .fileGetCopyReferenceDetails(let arg):
                    var d = Serialization.getFields(TeamLog.FileGetCopyReferenceDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("file_get_copy_reference_details")
                    return .dictionary(d)
                case .fileMoveDetails(let arg):
                    var d = Serialization.getFields(TeamLog.FileMoveDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("file_move_details")
                    return .dictionary(d)
                case .filePermanentlyDeleteDetails(let arg):
                    var d = Serialization.getFields(TeamLog.FilePermanentlyDeleteDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("file_permanently_delete_details")
                    return .dictionary(d)
                case .filePreviewDetails(let arg):
                    var d = Serialization.getFields(TeamLog.FilePreviewDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("file_preview_details")
                    return .dictionary(d)
                case .fileRenameDetails(let arg):
                    var d = Serialization.getFields(TeamLog.FileRenameDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("file_rename_details")
                    return .dictionary(d)
                case .fileRestoreDetails(let arg):
                    var d = Serialization.getFields(TeamLog.FileRestoreDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("file_restore_details")
                    return .dictionary(d)
                case .fileRevertDetails(let arg):
                    var d = Serialization.getFields(TeamLog.FileRevertDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("file_revert_details")
                    return .dictionary(d)
                case .fileRollbackChangesDetails(let arg):
                    var d = Serialization.getFields(TeamLog.FileRollbackChangesDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("file_rollback_changes_details")
                    return .dictionary(d)
                case .fileSaveCopyReferenceDetails(let arg):
                    var d = Serialization.getFields(TeamLog.FileSaveCopyReferenceDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("file_save_copy_reference_details")
                    return .dictionary(d)
                case .fileRequestChangeDetails(let arg):
                    var d = Serialization.getFields(TeamLog.FileRequestChangeDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("file_request_change_details")
                    return .dictionary(d)
                case .fileRequestCloseDetails(let arg):
                    var d = Serialization.getFields(TeamLog.FileRequestCloseDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("file_request_close_details")
                    return .dictionary(d)
                case .fileRequestCreateDetails(let arg):
                    var d = Serialization.getFields(TeamLog.FileRequestCreateDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("file_request_create_details")
                    return .dictionary(d)
                case .fileRequestReceiveFileDetails(let arg):
                    var d = Serialization.getFields(TeamLog.FileRequestReceiveFileDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("file_request_receive_file_details")
                    return .dictionary(d)
                case .groupAddExternalIdDetails(let arg):
                    var d = Serialization.getFields(TeamLog.GroupAddExternalIdDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("group_add_external_id_details")
                    return .dictionary(d)
                case .groupAddMemberDetails(let arg):
                    var d = Serialization.getFields(TeamLog.GroupAddMemberDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("group_add_member_details")
                    return .dictionary(d)
                case .groupChangeExternalIdDetails(let arg):
                    var d = Serialization.getFields(TeamLog.GroupChangeExternalIdDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("group_change_external_id_details")
                    return .dictionary(d)
                case .groupChangeManagementTypeDetails(let arg):
                    var d = Serialization.getFields(TeamLog.GroupChangeManagementTypeDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("group_change_management_type_details")
                    return .dictionary(d)
                case .groupChangeMemberRoleDetails(let arg):
                    var d = Serialization.getFields(TeamLog.GroupChangeMemberRoleDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("group_change_member_role_details")
                    return .dictionary(d)
                case .groupCreateDetails(let arg):
                    var d = Serialization.getFields(TeamLog.GroupCreateDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("group_create_details")
                    return .dictionary(d)
                case .groupDeleteDetails(let arg):
                    var d = Serialization.getFields(TeamLog.GroupDeleteDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("group_delete_details")
                    return .dictionary(d)
                case .groupDescriptionUpdatedDetails(let arg):
                    var d = Serialization.getFields(TeamLog.GroupDescriptionUpdatedDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("group_description_updated_details")
                    return .dictionary(d)
                case .groupJoinPolicyUpdatedDetails(let arg):
                    var d = Serialization.getFields(TeamLog.GroupJoinPolicyUpdatedDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("group_join_policy_updated_details")
                    return .dictionary(d)
                case .groupMovedDetails(let arg):
                    var d = Serialization.getFields(TeamLog.GroupMovedDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("group_moved_details")
                    return .dictionary(d)
                case .groupRemoveExternalIdDetails(let arg):
                    var d = Serialization.getFields(TeamLog.GroupRemoveExternalIdDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("group_remove_external_id_details")
                    return .dictionary(d)
                case .groupRemoveMemberDetails(let arg):
                    var d = Serialization.getFields(TeamLog.GroupRemoveMemberDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("group_remove_member_details")
                    return .dictionary(d)
                case .groupRenameDetails(let arg):
                    var d = Serialization.getFields(TeamLog.GroupRenameDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("group_rename_details")
                    return .dictionary(d)
                case .emmErrorDetails(let arg):
                    var d = Serialization.getFields(TeamLog.EmmErrorDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("emm_error_details")
                    return .dictionary(d)
                case .loginFailDetails(let arg):
                    var d = Serialization.getFields(TeamLog.LoginFailDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("login_fail_details")
                    return .dictionary(d)
                case .loginSuccessDetails(let arg):
                    var d = Serialization.getFields(TeamLog.LoginSuccessDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("login_success_details")
                    return .dictionary(d)
                case .logoutDetails(let arg):
                    var d = Serialization.getFields(TeamLog.LogoutDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("logout_details")
                    return .dictionary(d)
                case .resellerSupportSessionEndDetails(let arg):
                    var d = Serialization.getFields(TeamLog.ResellerSupportSessionEndDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("reseller_support_session_end_details")
                    return .dictionary(d)
                case .resellerSupportSessionStartDetails(let arg):
                    var d = Serialization.getFields(TeamLog.ResellerSupportSessionStartDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("reseller_support_session_start_details")
                    return .dictionary(d)
                case .signInAsSessionEndDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SignInAsSessionEndDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("sign_in_as_session_end_details")
                    return .dictionary(d)
                case .signInAsSessionStartDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SignInAsSessionStartDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("sign_in_as_session_start_details")
                    return .dictionary(d)
                case .ssoErrorDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SsoErrorDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("sso_error_details")
                    return .dictionary(d)
                case .memberAddNameDetails(let arg):
                    var d = Serialization.getFields(TeamLog.MemberAddNameDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("member_add_name_details")
                    return .dictionary(d)
                case .memberChangeAdminRoleDetails(let arg):
                    var d = Serialization.getFields(TeamLog.MemberChangeAdminRoleDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("member_change_admin_role_details")
                    return .dictionary(d)
                case .memberChangeEmailDetails(let arg):
                    var d = Serialization.getFields(TeamLog.MemberChangeEmailDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("member_change_email_details")
                    return .dictionary(d)
                case .memberChangeMembershipTypeDetails(let arg):
                    var d = Serialization.getFields(TeamLog.MemberChangeMembershipTypeDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("member_change_membership_type_details")
                    return .dictionary(d)
                case .memberChangeNameDetails(let arg):
                    var d = Serialization.getFields(TeamLog.MemberChangeNameDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("member_change_name_details")
                    return .dictionary(d)
                case .memberChangeStatusDetails(let arg):
                    var d = Serialization.getFields(TeamLog.MemberChangeStatusDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("member_change_status_details")
                    return .dictionary(d)
                case .memberDeleteManualContactsDetails(let arg):
                    var d = Serialization.getFields(TeamLog.MemberDeleteManualContactsDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("member_delete_manual_contacts_details")
                    return .dictionary(d)
                case .memberPermanentlyDeleteAccountContentsDetails(let arg):
                    var d = Serialization.getFields(TeamLog.MemberPermanentlyDeleteAccountContentsDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("member_permanently_delete_account_contents_details")
                    return .dictionary(d)
                case .memberSpaceLimitsAddCustomQuotaDetails(let arg):
                    var d = Serialization.getFields(TeamLog.MemberSpaceLimitsAddCustomQuotaDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("member_space_limits_add_custom_quota_details")
                    return .dictionary(d)
                case .memberSpaceLimitsChangeCustomQuotaDetails(let arg):
                    var d = Serialization.getFields(TeamLog.MemberSpaceLimitsChangeCustomQuotaDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("member_space_limits_change_custom_quota_details")
                    return .dictionary(d)
                case .memberSpaceLimitsChangeStatusDetails(let arg):
                    var d = Serialization.getFields(TeamLog.MemberSpaceLimitsChangeStatusDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("member_space_limits_change_status_details")
                    return .dictionary(d)
                case .memberSpaceLimitsRemoveCustomQuotaDetails(let arg):
                    var d = Serialization.getFields(TeamLog.MemberSpaceLimitsRemoveCustomQuotaDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("member_space_limits_remove_custom_quota_details")
                    return .dictionary(d)
                case .memberSuggestDetails(let arg):
                    var d = Serialization.getFields(TeamLog.MemberSuggestDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("member_suggest_details")
                    return .dictionary(d)
                case .memberTransferAccountContentsDetails(let arg):
                    var d = Serialization.getFields(TeamLog.MemberTransferAccountContentsDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("member_transfer_account_contents_details")
                    return .dictionary(d)
                case .secondaryMailsPolicyChangedDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SecondaryMailsPolicyChangedDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("secondary_mails_policy_changed_details")
                    return .dictionary(d)
                case .paperContentAddMemberDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperContentAddMemberDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_content_add_member_details")
                    return .dictionary(d)
                case .paperContentAddToFolderDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperContentAddToFolderDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_content_add_to_folder_details")
                    return .dictionary(d)
                case .paperContentArchiveDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperContentArchiveDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_content_archive_details")
                    return .dictionary(d)
                case .paperContentCreateDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperContentCreateDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_content_create_details")
                    return .dictionary(d)
                case .paperContentPermanentlyDeleteDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperContentPermanentlyDeleteDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_content_permanently_delete_details")
                    return .dictionary(d)
                case .paperContentRemoveFromFolderDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperContentRemoveFromFolderDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_content_remove_from_folder_details")
                    return .dictionary(d)
                case .paperContentRemoveMemberDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperContentRemoveMemberDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_content_remove_member_details")
                    return .dictionary(d)
                case .paperContentRenameDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperContentRenameDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_content_rename_details")
                    return .dictionary(d)
                case .paperContentRestoreDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperContentRestoreDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_content_restore_details")
                    return .dictionary(d)
                case .paperDocAddCommentDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocAddCommentDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_add_comment_details")
                    return .dictionary(d)
                case .paperDocChangeMemberRoleDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocChangeMemberRoleDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_change_member_role_details")
                    return .dictionary(d)
                case .paperDocChangeSharingPolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocChangeSharingPolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_change_sharing_policy_details")
                    return .dictionary(d)
                case .paperDocChangeSubscriptionDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocChangeSubscriptionDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_change_subscription_details")
                    return .dictionary(d)
                case .paperDocDeletedDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocDeletedDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_deleted_details")
                    return .dictionary(d)
                case .paperDocDeleteCommentDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocDeleteCommentDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_delete_comment_details")
                    return .dictionary(d)
                case .paperDocDownloadDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocDownloadDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_download_details")
                    return .dictionary(d)
                case .paperDocEditDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocEditDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_edit_details")
                    return .dictionary(d)
                case .paperDocEditCommentDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocEditCommentDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_edit_comment_details")
                    return .dictionary(d)
                case .paperDocFollowedDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocFollowedDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_followed_details")
                    return .dictionary(d)
                case .paperDocMentionDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocMentionDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_mention_details")
                    return .dictionary(d)
                case .paperDocOwnershipChangedDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocOwnershipChangedDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_ownership_changed_details")
                    return .dictionary(d)
                case .paperDocRequestAccessDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocRequestAccessDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_request_access_details")
                    return .dictionary(d)
                case .paperDocResolveCommentDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocResolveCommentDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_resolve_comment_details")
                    return .dictionary(d)
                case .paperDocRevertDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocRevertDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_revert_details")
                    return .dictionary(d)
                case .paperDocSlackShareDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocSlackShareDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_slack_share_details")
                    return .dictionary(d)
                case .paperDocTeamInviteDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocTeamInviteDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_team_invite_details")
                    return .dictionary(d)
                case .paperDocTrashedDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocTrashedDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_trashed_details")
                    return .dictionary(d)
                case .paperDocUnresolveCommentDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocUnresolveCommentDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_unresolve_comment_details")
                    return .dictionary(d)
                case .paperDocUntrashedDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocUntrashedDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_untrashed_details")
                    return .dictionary(d)
                case .paperDocViewDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocViewDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_view_details")
                    return .dictionary(d)
                case .paperExternalViewAllowDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperExternalViewAllowDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_external_view_allow_details")
                    return .dictionary(d)
                case .paperExternalViewDefaultTeamDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperExternalViewDefaultTeamDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_external_view_default_team_details")
                    return .dictionary(d)
                case .paperExternalViewForbidDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperExternalViewForbidDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_external_view_forbid_details")
                    return .dictionary(d)
                case .paperFolderChangeSubscriptionDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperFolderChangeSubscriptionDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_folder_change_subscription_details")
                    return .dictionary(d)
                case .paperFolderDeletedDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperFolderDeletedDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_folder_deleted_details")
                    return .dictionary(d)
                case .paperFolderFollowedDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperFolderFollowedDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_folder_followed_details")
                    return .dictionary(d)
                case .paperFolderTeamInviteDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperFolderTeamInviteDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_folder_team_invite_details")
                    return .dictionary(d)
                case .passwordChangeDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PasswordChangeDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("password_change_details")
                    return .dictionary(d)
                case .passwordResetDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PasswordResetDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("password_reset_details")
                    return .dictionary(d)
                case .passwordResetAllDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PasswordResetAllDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("password_reset_all_details")
                    return .dictionary(d)
                case .emmCreateExceptionsReportDetails(let arg):
                    var d = Serialization.getFields(TeamLog.EmmCreateExceptionsReportDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("emm_create_exceptions_report_details")
                    return .dictionary(d)
                case .emmCreateUsageReportDetails(let arg):
                    var d = Serialization.getFields(TeamLog.EmmCreateUsageReportDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("emm_create_usage_report_details")
                    return .dictionary(d)
                case .exportMembersReportDetails(let arg):
                    var d = Serialization.getFields(TeamLog.ExportMembersReportDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("export_members_report_details")
                    return .dictionary(d)
                case .paperAdminExportStartDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperAdminExportStartDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_admin_export_start_details")
                    return .dictionary(d)
                case .smartSyncCreateAdminPrivilegeReportDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SmartSyncCreateAdminPrivilegeReportDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("smart_sync_create_admin_privilege_report_details")
                    return .dictionary(d)
                case .teamActivityCreateReportDetails(let arg):
                    var d = Serialization.getFields(TeamLog.TeamActivityCreateReportDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("team_activity_create_report_details")
                    return .dictionary(d)
                case .collectionShareDetails(let arg):
                    var d = Serialization.getFields(TeamLog.CollectionShareDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("collection_share_details")
                    return .dictionary(d)
                case .noteAclInviteOnlyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.NoteAclInviteOnlyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("note_acl_invite_only_details")
                    return .dictionary(d)
                case .noteAclLinkDetails(let arg):
                    var d = Serialization.getFields(TeamLog.NoteAclLinkDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("note_acl_link_details")
                    return .dictionary(d)
                case .noteAclTeamLinkDetails(let arg):
                    var d = Serialization.getFields(TeamLog.NoteAclTeamLinkDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("note_acl_team_link_details")
                    return .dictionary(d)
                case .noteSharedDetails(let arg):
                    var d = Serialization.getFields(TeamLog.NoteSharedDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("note_shared_details")
                    return .dictionary(d)
                case .noteShareReceiveDetails(let arg):
                    var d = Serialization.getFields(TeamLog.NoteShareReceiveDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("note_share_receive_details")
                    return .dictionary(d)
                case .openNoteSharedDetails(let arg):
                    var d = Serialization.getFields(TeamLog.OpenNoteSharedDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("open_note_shared_details")
                    return .dictionary(d)
                case .sfAddGroupDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SfAddGroupDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("sf_add_group_details")
                    return .dictionary(d)
                case .sfAllowNonMembersToViewSharedLinksDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SfAllowNonMembersToViewSharedLinksDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("sf_allow_non_members_to_view_shared_links_details")
                    return .dictionary(d)
                case .sfExternalInviteWarnDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SfExternalInviteWarnDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("sf_external_invite_warn_details")
                    return .dictionary(d)
                case .sfFbInviteDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SfFbInviteDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("sf_fb_invite_details")
                    return .dictionary(d)
                case .sfFbInviteChangeRoleDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SfFbInviteChangeRoleDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("sf_fb_invite_change_role_details")
                    return .dictionary(d)
                case .sfFbUninviteDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SfFbUninviteDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("sf_fb_uninvite_details")
                    return .dictionary(d)
                case .sfInviteGroupDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SfInviteGroupDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("sf_invite_group_details")
                    return .dictionary(d)
                case .sfTeamGrantAccessDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SfTeamGrantAccessDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("sf_team_grant_access_details")
                    return .dictionary(d)
                case .sfTeamInviteDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SfTeamInviteDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("sf_team_invite_details")
                    return .dictionary(d)
                case .sfTeamInviteChangeRoleDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SfTeamInviteChangeRoleDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("sf_team_invite_change_role_details")
                    return .dictionary(d)
                case .sfTeamJoinDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SfTeamJoinDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("sf_team_join_details")
                    return .dictionary(d)
                case .sfTeamJoinFromOobLinkDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SfTeamJoinFromOobLinkDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("sf_team_join_from_oob_link_details")
                    return .dictionary(d)
                case .sfTeamUninviteDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SfTeamUninviteDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("sf_team_uninvite_details")
                    return .dictionary(d)
                case .sharedContentAddInviteesDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentAddInviteesDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_add_invitees_details")
                    return .dictionary(d)
                case .sharedContentAddLinkExpiryDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentAddLinkExpiryDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_add_link_expiry_details")
                    return .dictionary(d)
                case .sharedContentAddLinkPasswordDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentAddLinkPasswordDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_add_link_password_details")
                    return .dictionary(d)
                case .sharedContentAddMemberDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentAddMemberDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_add_member_details")
                    return .dictionary(d)
                case .sharedContentChangeDownloadsPolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentChangeDownloadsPolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_change_downloads_policy_details")
                    return .dictionary(d)
                case .sharedContentChangeInviteeRoleDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentChangeInviteeRoleDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_change_invitee_role_details")
                    return .dictionary(d)
                case .sharedContentChangeLinkAudienceDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentChangeLinkAudienceDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_change_link_audience_details")
                    return .dictionary(d)
                case .sharedContentChangeLinkExpiryDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentChangeLinkExpiryDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_change_link_expiry_details")
                    return .dictionary(d)
                case .sharedContentChangeLinkPasswordDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentChangeLinkPasswordDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_change_link_password_details")
                    return .dictionary(d)
                case .sharedContentChangeMemberRoleDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentChangeMemberRoleDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_change_member_role_details")
                    return .dictionary(d)
                case .sharedContentChangeViewerInfoPolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentChangeViewerInfoPolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_change_viewer_info_policy_details")
                    return .dictionary(d)
                case .sharedContentClaimInvitationDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentClaimInvitationDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_claim_invitation_details")
                    return .dictionary(d)
                case .sharedContentCopyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentCopyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_copy_details")
                    return .dictionary(d)
                case .sharedContentDownloadDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentDownloadDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_download_details")
                    return .dictionary(d)
                case .sharedContentRelinquishMembershipDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentRelinquishMembershipDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_relinquish_membership_details")
                    return .dictionary(d)
                case .sharedContentRemoveInviteesDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentRemoveInviteesDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_remove_invitees_details")
                    return .dictionary(d)
                case .sharedContentRemoveLinkExpiryDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentRemoveLinkExpiryDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_remove_link_expiry_details")
                    return .dictionary(d)
                case .sharedContentRemoveLinkPasswordDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentRemoveLinkPasswordDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_remove_link_password_details")
                    return .dictionary(d)
                case .sharedContentRemoveMemberDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentRemoveMemberDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_remove_member_details")
                    return .dictionary(d)
                case .sharedContentRequestAccessDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentRequestAccessDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_request_access_details")
                    return .dictionary(d)
                case .sharedContentUnshareDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentUnshareDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_unshare_details")
                    return .dictionary(d)
                case .sharedContentViewDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentViewDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_view_details")
                    return .dictionary(d)
                case .sharedFolderChangeLinkPolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedFolderChangeLinkPolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_folder_change_link_policy_details")
                    return .dictionary(d)
                case .sharedFolderChangeMembersInheritancePolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedFolderChangeMembersInheritancePolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_folder_change_members_inheritance_policy_details")
                    return .dictionary(d)
                case .sharedFolderChangeMembersManagementPolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedFolderChangeMembersManagementPolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_folder_change_members_management_policy_details")
                    return .dictionary(d)
                case .sharedFolderChangeMembersPolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedFolderChangeMembersPolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_folder_change_members_policy_details")
                    return .dictionary(d)
                case .sharedFolderCreateDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedFolderCreateDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_folder_create_details")
                    return .dictionary(d)
                case .sharedFolderDeclineInvitationDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedFolderDeclineInvitationDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_folder_decline_invitation_details")
                    return .dictionary(d)
                case .sharedFolderMountDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedFolderMountDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_folder_mount_details")
                    return .dictionary(d)
                case .sharedFolderNestDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedFolderNestDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_folder_nest_details")
                    return .dictionary(d)
                case .sharedFolderTransferOwnershipDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedFolderTransferOwnershipDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_folder_transfer_ownership_details")
                    return .dictionary(d)
                case .sharedFolderUnmountDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedFolderUnmountDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_folder_unmount_details")
                    return .dictionary(d)
                case .sharedLinkAddExpiryDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedLinkAddExpiryDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_link_add_expiry_details")
                    return .dictionary(d)
                case .sharedLinkChangeExpiryDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedLinkChangeExpiryDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_link_change_expiry_details")
                    return .dictionary(d)
                case .sharedLinkChangeVisibilityDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedLinkChangeVisibilityDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_link_change_visibility_details")
                    return .dictionary(d)
                case .sharedLinkCopyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedLinkCopyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_link_copy_details")
                    return .dictionary(d)
                case .sharedLinkCreateDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedLinkCreateDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_link_create_details")
                    return .dictionary(d)
                case .sharedLinkDisableDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedLinkDisableDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_link_disable_details")
                    return .dictionary(d)
                case .sharedLinkDownloadDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedLinkDownloadDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_link_download_details")
                    return .dictionary(d)
                case .sharedLinkRemoveExpiryDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedLinkRemoveExpiryDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_link_remove_expiry_details")
                    return .dictionary(d)
                case .sharedLinkShareDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedLinkShareDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_link_share_details")
                    return .dictionary(d)
                case .sharedLinkViewDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedLinkViewDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_link_view_details")
                    return .dictionary(d)
                case .sharedNoteOpenedDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharedNoteOpenedDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shared_note_opened_details")
                    return .dictionary(d)
                case .shmodelGroupShareDetails(let arg):
                    var d = Serialization.getFields(TeamLog.ShmodelGroupShareDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("shmodel_group_share_details")
                    return .dictionary(d)
                case .showcaseAccessGrantedDetails(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseAccessGrantedDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_access_granted_details")
                    return .dictionary(d)
                case .showcaseAddMemberDetails(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseAddMemberDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_add_member_details")
                    return .dictionary(d)
                case .showcaseArchivedDetails(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseArchivedDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_archived_details")
                    return .dictionary(d)
                case .showcaseCreatedDetails(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseCreatedDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_created_details")
                    return .dictionary(d)
                case .showcaseDeleteCommentDetails(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseDeleteCommentDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_delete_comment_details")
                    return .dictionary(d)
                case .showcaseEditedDetails(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseEditedDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_edited_details")
                    return .dictionary(d)
                case .showcaseEditCommentDetails(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseEditCommentDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_edit_comment_details")
                    return .dictionary(d)
                case .showcaseFileAddedDetails(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseFileAddedDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_file_added_details")
                    return .dictionary(d)
                case .showcaseFileDownloadDetails(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseFileDownloadDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_file_download_details")
                    return .dictionary(d)
                case .showcaseFileRemovedDetails(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseFileRemovedDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_file_removed_details")
                    return .dictionary(d)
                case .showcaseFileViewDetails(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseFileViewDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_file_view_details")
                    return .dictionary(d)
                case .showcasePermanentlyDeletedDetails(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcasePermanentlyDeletedDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_permanently_deleted_details")
                    return .dictionary(d)
                case .showcasePostCommentDetails(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcasePostCommentDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_post_comment_details")
                    return .dictionary(d)
                case .showcaseRemoveMemberDetails(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseRemoveMemberDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_remove_member_details")
                    return .dictionary(d)
                case .showcaseRenamedDetails(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseRenamedDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_renamed_details")
                    return .dictionary(d)
                case .showcaseRequestAccessDetails(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseRequestAccessDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_request_access_details")
                    return .dictionary(d)
                case .showcaseResolveCommentDetails(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseResolveCommentDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_resolve_comment_details")
                    return .dictionary(d)
                case .showcaseRestoredDetails(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseRestoredDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_restored_details")
                    return .dictionary(d)
                case .showcaseTrashedDetails(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseTrashedDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_trashed_details")
                    return .dictionary(d)
                case .showcaseTrashedDeprecatedDetails(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseTrashedDeprecatedDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_trashed_deprecated_details")
                    return .dictionary(d)
                case .showcaseUnresolveCommentDetails(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseUnresolveCommentDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_unresolve_comment_details")
                    return .dictionary(d)
                case .showcaseUntrashedDetails(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseUntrashedDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_untrashed_details")
                    return .dictionary(d)
                case .showcaseUntrashedDeprecatedDetails(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseUntrashedDeprecatedDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_untrashed_deprecated_details")
                    return .dictionary(d)
                case .showcaseViewDetails(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseViewDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_view_details")
                    return .dictionary(d)
                case .ssoAddCertDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SsoAddCertDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("sso_add_cert_details")
                    return .dictionary(d)
                case .ssoAddLoginUrlDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SsoAddLoginUrlDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("sso_add_login_url_details")
                    return .dictionary(d)
                case .ssoAddLogoutUrlDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SsoAddLogoutUrlDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("sso_add_logout_url_details")
                    return .dictionary(d)
                case .ssoChangeCertDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SsoChangeCertDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("sso_change_cert_details")
                    return .dictionary(d)
                case .ssoChangeLoginUrlDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SsoChangeLoginUrlDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("sso_change_login_url_details")
                    return .dictionary(d)
                case .ssoChangeLogoutUrlDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SsoChangeLogoutUrlDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("sso_change_logout_url_details")
                    return .dictionary(d)
                case .ssoChangeSamlIdentityModeDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SsoChangeSamlIdentityModeDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("sso_change_saml_identity_mode_details")
                    return .dictionary(d)
                case .ssoRemoveCertDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SsoRemoveCertDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("sso_remove_cert_details")
                    return .dictionary(d)
                case .ssoRemoveLoginUrlDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SsoRemoveLoginUrlDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("sso_remove_login_url_details")
                    return .dictionary(d)
                case .ssoRemoveLogoutUrlDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SsoRemoveLogoutUrlDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("sso_remove_logout_url_details")
                    return .dictionary(d)
                case .teamFolderChangeStatusDetails(let arg):
                    var d = Serialization.getFields(TeamLog.TeamFolderChangeStatusDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("team_folder_change_status_details")
                    return .dictionary(d)
                case .teamFolderCreateDetails(let arg):
                    var d = Serialization.getFields(TeamLog.TeamFolderCreateDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("team_folder_create_details")
                    return .dictionary(d)
                case .teamFolderDowngradeDetails(let arg):
                    var d = Serialization.getFields(TeamLog.TeamFolderDowngradeDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("team_folder_downgrade_details")
                    return .dictionary(d)
                case .teamFolderPermanentlyDeleteDetails(let arg):
                    var d = Serialization.getFields(TeamLog.TeamFolderPermanentlyDeleteDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("team_folder_permanently_delete_details")
                    return .dictionary(d)
                case .teamFolderRenameDetails(let arg):
                    var d = Serialization.getFields(TeamLog.TeamFolderRenameDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("team_folder_rename_details")
                    return .dictionary(d)
                case .teamSelectiveSyncSettingsChangedDetails(let arg):
                    var d = Serialization.getFields(TeamLog.TeamSelectiveSyncSettingsChangedDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("team_selective_sync_settings_changed_details")
                    return .dictionary(d)
                case .accountCaptureChangePolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.AccountCaptureChangePolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("account_capture_change_policy_details")
                    return .dictionary(d)
                case .allowDownloadDisabledDetails(let arg):
                    var d = Serialization.getFields(TeamLog.AllowDownloadDisabledDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("allow_download_disabled_details")
                    return .dictionary(d)
                case .allowDownloadEnabledDetails(let arg):
                    var d = Serialization.getFields(TeamLog.AllowDownloadEnabledDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("allow_download_enabled_details")
                    return .dictionary(d)
                case .cameraUploadsPolicyChangedDetails(let arg):
                    var d = Serialization.getFields(TeamLog.CameraUploadsPolicyChangedDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("camera_uploads_policy_changed_details")
                    return .dictionary(d)
                case .dataPlacementRestrictionChangePolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.DataPlacementRestrictionChangePolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("data_placement_restriction_change_policy_details")
                    return .dictionary(d)
                case .dataPlacementRestrictionSatisfyPolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.DataPlacementRestrictionSatisfyPolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("data_placement_restriction_satisfy_policy_details")
                    return .dictionary(d)
                case .deviceApprovalsChangeDesktopPolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.DeviceApprovalsChangeDesktopPolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("device_approvals_change_desktop_policy_details")
                    return .dictionary(d)
                case .deviceApprovalsChangeMobilePolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.DeviceApprovalsChangeMobilePolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("device_approvals_change_mobile_policy_details")
                    return .dictionary(d)
                case .deviceApprovalsChangeOverageActionDetails(let arg):
                    var d = Serialization.getFields(TeamLog.DeviceApprovalsChangeOverageActionDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("device_approvals_change_overage_action_details")
                    return .dictionary(d)
                case .deviceApprovalsChangeUnlinkActionDetails(let arg):
                    var d = Serialization.getFields(TeamLog.DeviceApprovalsChangeUnlinkActionDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("device_approvals_change_unlink_action_details")
                    return .dictionary(d)
                case .directoryRestrictionsAddMembersDetails(let arg):
                    var d = Serialization.getFields(TeamLog.DirectoryRestrictionsAddMembersDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("directory_restrictions_add_members_details")
                    return .dictionary(d)
                case .directoryRestrictionsRemoveMembersDetails(let arg):
                    var d = Serialization.getFields(TeamLog.DirectoryRestrictionsRemoveMembersDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("directory_restrictions_remove_members_details")
                    return .dictionary(d)
                case .emmAddExceptionDetails(let arg):
                    var d = Serialization.getFields(TeamLog.EmmAddExceptionDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("emm_add_exception_details")
                    return .dictionary(d)
                case .emmChangePolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.EmmChangePolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("emm_change_policy_details")
                    return .dictionary(d)
                case .emmRemoveExceptionDetails(let arg):
                    var d = Serialization.getFields(TeamLog.EmmRemoveExceptionDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("emm_remove_exception_details")
                    return .dictionary(d)
                case .extendedVersionHistoryChangePolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.ExtendedVersionHistoryChangePolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("extended_version_history_change_policy_details")
                    return .dictionary(d)
                case .fileCommentsChangePolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.FileCommentsChangePolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("file_comments_change_policy_details")
                    return .dictionary(d)
                case .fileRequestsChangePolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.FileRequestsChangePolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("file_requests_change_policy_details")
                    return .dictionary(d)
                case .fileRequestsEmailsEnabledDetails(let arg):
                    var d = Serialization.getFields(TeamLog.FileRequestsEmailsEnabledDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("file_requests_emails_enabled_details")
                    return .dictionary(d)
                case .fileRequestsEmailsRestrictedToTeamOnlyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.FileRequestsEmailsRestrictedToTeamOnlyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("file_requests_emails_restricted_to_team_only_details")
                    return .dictionary(d)
                case .googleSsoChangePolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.GoogleSsoChangePolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("google_sso_change_policy_details")
                    return .dictionary(d)
                case .groupUserManagementChangePolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.GroupUserManagementChangePolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("group_user_management_change_policy_details")
                    return .dictionary(d)
                case .memberRequestsChangePolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.MemberRequestsChangePolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("member_requests_change_policy_details")
                    return .dictionary(d)
                case .memberSpaceLimitsAddExceptionDetails(let arg):
                    var d = Serialization.getFields(TeamLog.MemberSpaceLimitsAddExceptionDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("member_space_limits_add_exception_details")
                    return .dictionary(d)
                case .memberSpaceLimitsChangeCapsTypePolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.MemberSpaceLimitsChangeCapsTypePolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("member_space_limits_change_caps_type_policy_details")
                    return .dictionary(d)
                case .memberSpaceLimitsChangePolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.MemberSpaceLimitsChangePolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("member_space_limits_change_policy_details")
                    return .dictionary(d)
                case .memberSpaceLimitsRemoveExceptionDetails(let arg):
                    var d = Serialization.getFields(TeamLog.MemberSpaceLimitsRemoveExceptionDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("member_space_limits_remove_exception_details")
                    return .dictionary(d)
                case .memberSuggestionsChangePolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.MemberSuggestionsChangePolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("member_suggestions_change_policy_details")
                    return .dictionary(d)
                case .microsoftOfficeAddinChangePolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.MicrosoftOfficeAddinChangePolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("microsoft_office_addin_change_policy_details")
                    return .dictionary(d)
                case .networkControlChangePolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.NetworkControlChangePolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("network_control_change_policy_details")
                    return .dictionary(d)
                case .paperChangeDeploymentPolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperChangeDeploymentPolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_change_deployment_policy_details")
                    return .dictionary(d)
                case .paperChangeMemberLinkPolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperChangeMemberLinkPolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_change_member_link_policy_details")
                    return .dictionary(d)
                case .paperChangeMemberPolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperChangeMemberPolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_change_member_policy_details")
                    return .dictionary(d)
                case .paperChangePolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperChangePolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_change_policy_details")
                    return .dictionary(d)
                case .paperEnabledUsersGroupAdditionDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperEnabledUsersGroupAdditionDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_enabled_users_group_addition_details")
                    return .dictionary(d)
                case .paperEnabledUsersGroupRemovalDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PaperEnabledUsersGroupRemovalDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("paper_enabled_users_group_removal_details")
                    return .dictionary(d)
                case .permanentDeleteChangePolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.PermanentDeleteChangePolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("permanent_delete_change_policy_details")
                    return .dictionary(d)
                case .sharingChangeFolderJoinPolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharingChangeFolderJoinPolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("sharing_change_folder_join_policy_details")
                    return .dictionary(d)
                case .sharingChangeLinkPolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharingChangeLinkPolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("sharing_change_link_policy_details")
                    return .dictionary(d)
                case .sharingChangeMemberPolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SharingChangeMemberPolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("sharing_change_member_policy_details")
                    return .dictionary(d)
                case .showcaseChangeDownloadPolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseChangeDownloadPolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_change_download_policy_details")
                    return .dictionary(d)
                case .showcaseChangeEnabledPolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseChangeEnabledPolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_change_enabled_policy_details")
                    return .dictionary(d)
                case .showcaseChangeExternalSharingPolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseChangeExternalSharingPolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_change_external_sharing_policy_details")
                    return .dictionary(d)
                case .smartSyncChangePolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SmartSyncChangePolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("smart_sync_change_policy_details")
                    return .dictionary(d)
                case .smartSyncNotOptOutDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SmartSyncNotOptOutDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("smart_sync_not_opt_out_details")
                    return .dictionary(d)
                case .smartSyncOptOutDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SmartSyncOptOutDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("smart_sync_opt_out_details")
                    return .dictionary(d)
                case .ssoChangePolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.SsoChangePolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("sso_change_policy_details")
                    return .dictionary(d)
                case .teamSelectiveSyncPolicyChangedDetails(let arg):
                    var d = Serialization.getFields(TeamLog.TeamSelectiveSyncPolicyChangedDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("team_selective_sync_policy_changed_details")
                    return .dictionary(d)
                case .tfaChangePolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.TfaChangePolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("tfa_change_policy_details")
                    return .dictionary(d)
                case .twoAccountChangePolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.TwoAccountChangePolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("two_account_change_policy_details")
                    return .dictionary(d)
                case .viewerInfoPolicyChangedDetails(let arg):
                    var d = Serialization.getFields(TeamLog.ViewerInfoPolicyChangedDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("viewer_info_policy_changed_details")
                    return .dictionary(d)
                case .webSessionsChangeFixedLengthPolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.WebSessionsChangeFixedLengthPolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("web_sessions_change_fixed_length_policy_details")
                    return .dictionary(d)
                case .webSessionsChangeIdleLengthPolicyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.WebSessionsChangeIdleLengthPolicyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("web_sessions_change_idle_length_policy_details")
                    return .dictionary(d)
                case .teamMergeFromDetails(let arg):
                    var d = Serialization.getFields(TeamLog.TeamMergeFromDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("team_merge_from_details")
                    return .dictionary(d)
                case .teamMergeToDetails(let arg):
                    var d = Serialization.getFields(TeamLog.TeamMergeToDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("team_merge_to_details")
                    return .dictionary(d)
                case .teamProfileAddLogoDetails(let arg):
                    var d = Serialization.getFields(TeamLog.TeamProfileAddLogoDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("team_profile_add_logo_details")
                    return .dictionary(d)
                case .teamProfileChangeDefaultLanguageDetails(let arg):
                    var d = Serialization.getFields(TeamLog.TeamProfileChangeDefaultLanguageDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("team_profile_change_default_language_details")
                    return .dictionary(d)
                case .teamProfileChangeLogoDetails(let arg):
                    var d = Serialization.getFields(TeamLog.TeamProfileChangeLogoDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("team_profile_change_logo_details")
                    return .dictionary(d)
                case .teamProfileChangeNameDetails(let arg):
                    var d = Serialization.getFields(TeamLog.TeamProfileChangeNameDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("team_profile_change_name_details")
                    return .dictionary(d)
                case .teamProfileRemoveLogoDetails(let arg):
                    var d = Serialization.getFields(TeamLog.TeamProfileRemoveLogoDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("team_profile_remove_logo_details")
                    return .dictionary(d)
                case .tfaAddBackupPhoneDetails(let arg):
                    var d = Serialization.getFields(TeamLog.TfaAddBackupPhoneDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("tfa_add_backup_phone_details")
                    return .dictionary(d)
                case .tfaAddSecurityKeyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.TfaAddSecurityKeyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("tfa_add_security_key_details")
                    return .dictionary(d)
                case .tfaChangeBackupPhoneDetails(let arg):
                    var d = Serialization.getFields(TeamLog.TfaChangeBackupPhoneDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("tfa_change_backup_phone_details")
                    return .dictionary(d)
                case .tfaChangeStatusDetails(let arg):
                    var d = Serialization.getFields(TeamLog.TfaChangeStatusDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("tfa_change_status_details")
                    return .dictionary(d)
                case .tfaRemoveBackupPhoneDetails(let arg):
                    var d = Serialization.getFields(TeamLog.TfaRemoveBackupPhoneDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("tfa_remove_backup_phone_details")
                    return .dictionary(d)
                case .tfaRemoveSecurityKeyDetails(let arg):
                    var d = Serialization.getFields(TeamLog.TfaRemoveSecurityKeyDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("tfa_remove_security_key_details")
                    return .dictionary(d)
                case .tfaResetDetails(let arg):
                    var d = Serialization.getFields(TeamLog.TfaResetDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("tfa_reset_details")
                    return .dictionary(d)
                case .missingDetails(let arg):
                    var d = Serialization.getFields(TeamLog.MissingDetailsSerializer().serialize(arg))
                    d[".tag"] = .str("missing_details")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> EventDetails {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "app_link_team_details":
                            let v = TeamLog.AppLinkTeamDetailsSerializer().deserialize(json)
                            return EventDetails.appLinkTeamDetails(v)
                        case "app_link_user_details":
                            let v = TeamLog.AppLinkUserDetailsSerializer().deserialize(json)
                            return EventDetails.appLinkUserDetails(v)
                        case "app_unlink_team_details":
                            let v = TeamLog.AppUnlinkTeamDetailsSerializer().deserialize(json)
                            return EventDetails.appUnlinkTeamDetails(v)
                        case "app_unlink_user_details":
                            let v = TeamLog.AppUnlinkUserDetailsSerializer().deserialize(json)
                            return EventDetails.appUnlinkUserDetails(v)
                        case "file_add_comment_details":
                            let v = TeamLog.FileAddCommentDetailsSerializer().deserialize(json)
                            return EventDetails.fileAddCommentDetails(v)
                        case "file_change_comment_subscription_details":
                            let v = TeamLog.FileChangeCommentSubscriptionDetailsSerializer().deserialize(json)
                            return EventDetails.fileChangeCommentSubscriptionDetails(v)
                        case "file_delete_comment_details":
                            let v = TeamLog.FileDeleteCommentDetailsSerializer().deserialize(json)
                            return EventDetails.fileDeleteCommentDetails(v)
                        case "file_edit_comment_details":
                            let v = TeamLog.FileEditCommentDetailsSerializer().deserialize(json)
                            return EventDetails.fileEditCommentDetails(v)
                        case "file_like_comment_details":
                            let v = TeamLog.FileLikeCommentDetailsSerializer().deserialize(json)
                            return EventDetails.fileLikeCommentDetails(v)
                        case "file_resolve_comment_details":
                            let v = TeamLog.FileResolveCommentDetailsSerializer().deserialize(json)
                            return EventDetails.fileResolveCommentDetails(v)
                        case "file_unlike_comment_details":
                            let v = TeamLog.FileUnlikeCommentDetailsSerializer().deserialize(json)
                            return EventDetails.fileUnlikeCommentDetails(v)
                        case "file_unresolve_comment_details":
                            let v = TeamLog.FileUnresolveCommentDetailsSerializer().deserialize(json)
                            return EventDetails.fileUnresolveCommentDetails(v)
                        case "device_change_ip_desktop_details":
                            let v = TeamLog.DeviceChangeIpDesktopDetailsSerializer().deserialize(json)
                            return EventDetails.deviceChangeIpDesktopDetails(v)
                        case "device_change_ip_mobile_details":
                            let v = TeamLog.DeviceChangeIpMobileDetailsSerializer().deserialize(json)
                            return EventDetails.deviceChangeIpMobileDetails(v)
                        case "device_change_ip_web_details":
                            let v = TeamLog.DeviceChangeIpWebDetailsSerializer().deserialize(json)
                            return EventDetails.deviceChangeIpWebDetails(v)
                        case "device_delete_on_unlink_fail_details":
                            let v = TeamLog.DeviceDeleteOnUnlinkFailDetailsSerializer().deserialize(json)
                            return EventDetails.deviceDeleteOnUnlinkFailDetails(v)
                        case "device_delete_on_unlink_success_details":
                            let v = TeamLog.DeviceDeleteOnUnlinkSuccessDetailsSerializer().deserialize(json)
                            return EventDetails.deviceDeleteOnUnlinkSuccessDetails(v)
                        case "device_link_fail_details":
                            let v = TeamLog.DeviceLinkFailDetailsSerializer().deserialize(json)
                            return EventDetails.deviceLinkFailDetails(v)
                        case "device_link_success_details":
                            let v = TeamLog.DeviceLinkSuccessDetailsSerializer().deserialize(json)
                            return EventDetails.deviceLinkSuccessDetails(v)
                        case "device_management_disabled_details":
                            let v = TeamLog.DeviceManagementDisabledDetailsSerializer().deserialize(json)
                            return EventDetails.deviceManagementDisabledDetails(v)
                        case "device_management_enabled_details":
                            let v = TeamLog.DeviceManagementEnabledDetailsSerializer().deserialize(json)
                            return EventDetails.deviceManagementEnabledDetails(v)
                        case "device_unlink_details":
                            let v = TeamLog.DeviceUnlinkDetailsSerializer().deserialize(json)
                            return EventDetails.deviceUnlinkDetails(v)
                        case "emm_refresh_auth_token_details":
                            let v = TeamLog.EmmRefreshAuthTokenDetailsSerializer().deserialize(json)
                            return EventDetails.emmRefreshAuthTokenDetails(v)
                        case "account_capture_change_availability_details":
                            let v = TeamLog.AccountCaptureChangeAvailabilityDetailsSerializer().deserialize(json)
                            return EventDetails.accountCaptureChangeAvailabilityDetails(v)
                        case "account_capture_migrate_account_details":
                            let v = TeamLog.AccountCaptureMigrateAccountDetailsSerializer().deserialize(json)
                            return EventDetails.accountCaptureMigrateAccountDetails(v)
                        case "account_capture_notification_emails_sent_details":
                            let v = TeamLog.AccountCaptureNotificationEmailsSentDetailsSerializer().deserialize(json)
                            return EventDetails.accountCaptureNotificationEmailsSentDetails(v)
                        case "account_capture_relinquish_account_details":
                            let v = TeamLog.AccountCaptureRelinquishAccountDetailsSerializer().deserialize(json)
                            return EventDetails.accountCaptureRelinquishAccountDetails(v)
                        case "disabled_domain_invites_details":
                            let v = TeamLog.DisabledDomainInvitesDetailsSerializer().deserialize(json)
                            return EventDetails.disabledDomainInvitesDetails(v)
                        case "domain_invites_approve_request_to_join_team_details":
                            let v = TeamLog.DomainInvitesApproveRequestToJoinTeamDetailsSerializer().deserialize(json)
                            return EventDetails.domainInvitesApproveRequestToJoinTeamDetails(v)
                        case "domain_invites_decline_request_to_join_team_details":
                            let v = TeamLog.DomainInvitesDeclineRequestToJoinTeamDetailsSerializer().deserialize(json)
                            return EventDetails.domainInvitesDeclineRequestToJoinTeamDetails(v)
                        case "domain_invites_email_existing_users_details":
                            let v = TeamLog.DomainInvitesEmailExistingUsersDetailsSerializer().deserialize(json)
                            return EventDetails.domainInvitesEmailExistingUsersDetails(v)
                        case "domain_invites_request_to_join_team_details":
                            let v = TeamLog.DomainInvitesRequestToJoinTeamDetailsSerializer().deserialize(json)
                            return EventDetails.domainInvitesRequestToJoinTeamDetails(v)
                        case "domain_invites_set_invite_new_user_pref_to_no_details":
                            let v = TeamLog.DomainInvitesSetInviteNewUserPrefToNoDetailsSerializer().deserialize(json)
                            return EventDetails.domainInvitesSetInviteNewUserPrefToNoDetails(v)
                        case "domain_invites_set_invite_new_user_pref_to_yes_details":
                            let v = TeamLog.DomainInvitesSetInviteNewUserPrefToYesDetailsSerializer().deserialize(json)
                            return EventDetails.domainInvitesSetInviteNewUserPrefToYesDetails(v)
                        case "domain_verification_add_domain_fail_details":
                            let v = TeamLog.DomainVerificationAddDomainFailDetailsSerializer().deserialize(json)
                            return EventDetails.domainVerificationAddDomainFailDetails(v)
                        case "domain_verification_add_domain_success_details":
                            let v = TeamLog.DomainVerificationAddDomainSuccessDetailsSerializer().deserialize(json)
                            return EventDetails.domainVerificationAddDomainSuccessDetails(v)
                        case "domain_verification_remove_domain_details":
                            let v = TeamLog.DomainVerificationRemoveDomainDetailsSerializer().deserialize(json)
                            return EventDetails.domainVerificationRemoveDomainDetails(v)
                        case "enabled_domain_invites_details":
                            let v = TeamLog.EnabledDomainInvitesDetailsSerializer().deserialize(json)
                            return EventDetails.enabledDomainInvitesDetails(v)
                        case "create_folder_details":
                            let v = TeamLog.CreateFolderDetailsSerializer().deserialize(json)
                            return EventDetails.createFolderDetails(v)
                        case "file_add_details":
                            let v = TeamLog.FileAddDetailsSerializer().deserialize(json)
                            return EventDetails.fileAddDetails(v)
                        case "file_copy_details":
                            let v = TeamLog.FileCopyDetailsSerializer().deserialize(json)
                            return EventDetails.fileCopyDetails(v)
                        case "file_delete_details":
                            let v = TeamLog.FileDeleteDetailsSerializer().deserialize(json)
                            return EventDetails.fileDeleteDetails(v)
                        case "file_download_details":
                            let v = TeamLog.FileDownloadDetailsSerializer().deserialize(json)
                            return EventDetails.fileDownloadDetails(v)
                        case "file_edit_details":
                            let v = TeamLog.FileEditDetailsSerializer().deserialize(json)
                            return EventDetails.fileEditDetails(v)
                        case "file_get_copy_reference_details":
                            let v = TeamLog.FileGetCopyReferenceDetailsSerializer().deserialize(json)
                            return EventDetails.fileGetCopyReferenceDetails(v)
                        case "file_move_details":
                            let v = TeamLog.FileMoveDetailsSerializer().deserialize(json)
                            return EventDetails.fileMoveDetails(v)
                        case "file_permanently_delete_details":
                            let v = TeamLog.FilePermanentlyDeleteDetailsSerializer().deserialize(json)
                            return EventDetails.filePermanentlyDeleteDetails(v)
                        case "file_preview_details":
                            let v = TeamLog.FilePreviewDetailsSerializer().deserialize(json)
                            return EventDetails.filePreviewDetails(v)
                        case "file_rename_details":
                            let v = TeamLog.FileRenameDetailsSerializer().deserialize(json)
                            return EventDetails.fileRenameDetails(v)
                        case "file_restore_details":
                            let v = TeamLog.FileRestoreDetailsSerializer().deserialize(json)
                            return EventDetails.fileRestoreDetails(v)
                        case "file_revert_details":
                            let v = TeamLog.FileRevertDetailsSerializer().deserialize(json)
                            return EventDetails.fileRevertDetails(v)
                        case "file_rollback_changes_details":
                            let v = TeamLog.FileRollbackChangesDetailsSerializer().deserialize(json)
                            return EventDetails.fileRollbackChangesDetails(v)
                        case "file_save_copy_reference_details":
                            let v = TeamLog.FileSaveCopyReferenceDetailsSerializer().deserialize(json)
                            return EventDetails.fileSaveCopyReferenceDetails(v)
                        case "file_request_change_details":
                            let v = TeamLog.FileRequestChangeDetailsSerializer().deserialize(json)
                            return EventDetails.fileRequestChangeDetails(v)
                        case "file_request_close_details":
                            let v = TeamLog.FileRequestCloseDetailsSerializer().deserialize(json)
                            return EventDetails.fileRequestCloseDetails(v)
                        case "file_request_create_details":
                            let v = TeamLog.FileRequestCreateDetailsSerializer().deserialize(json)
                            return EventDetails.fileRequestCreateDetails(v)
                        case "file_request_receive_file_details":
                            let v = TeamLog.FileRequestReceiveFileDetailsSerializer().deserialize(json)
                            return EventDetails.fileRequestReceiveFileDetails(v)
                        case "group_add_external_id_details":
                            let v = TeamLog.GroupAddExternalIdDetailsSerializer().deserialize(json)
                            return EventDetails.groupAddExternalIdDetails(v)
                        case "group_add_member_details":
                            let v = TeamLog.GroupAddMemberDetailsSerializer().deserialize(json)
                            return EventDetails.groupAddMemberDetails(v)
                        case "group_change_external_id_details":
                            let v = TeamLog.GroupChangeExternalIdDetailsSerializer().deserialize(json)
                            return EventDetails.groupChangeExternalIdDetails(v)
                        case "group_change_management_type_details":
                            let v = TeamLog.GroupChangeManagementTypeDetailsSerializer().deserialize(json)
                            return EventDetails.groupChangeManagementTypeDetails(v)
                        case "group_change_member_role_details":
                            let v = TeamLog.GroupChangeMemberRoleDetailsSerializer().deserialize(json)
                            return EventDetails.groupChangeMemberRoleDetails(v)
                        case "group_create_details":
                            let v = TeamLog.GroupCreateDetailsSerializer().deserialize(json)
                            return EventDetails.groupCreateDetails(v)
                        case "group_delete_details":
                            let v = TeamLog.GroupDeleteDetailsSerializer().deserialize(json)
                            return EventDetails.groupDeleteDetails(v)
                        case "group_description_updated_details":
                            let v = TeamLog.GroupDescriptionUpdatedDetailsSerializer().deserialize(json)
                            return EventDetails.groupDescriptionUpdatedDetails(v)
                        case "group_join_policy_updated_details":
                            let v = TeamLog.GroupJoinPolicyUpdatedDetailsSerializer().deserialize(json)
                            return EventDetails.groupJoinPolicyUpdatedDetails(v)
                        case "group_moved_details":
                            let v = TeamLog.GroupMovedDetailsSerializer().deserialize(json)
                            return EventDetails.groupMovedDetails(v)
                        case "group_remove_external_id_details":
                            let v = TeamLog.GroupRemoveExternalIdDetailsSerializer().deserialize(json)
                            return EventDetails.groupRemoveExternalIdDetails(v)
                        case "group_remove_member_details":
                            let v = TeamLog.GroupRemoveMemberDetailsSerializer().deserialize(json)
                            return EventDetails.groupRemoveMemberDetails(v)
                        case "group_rename_details":
                            let v = TeamLog.GroupRenameDetailsSerializer().deserialize(json)
                            return EventDetails.groupRenameDetails(v)
                        case "emm_error_details":
                            let v = TeamLog.EmmErrorDetailsSerializer().deserialize(json)
                            return EventDetails.emmErrorDetails(v)
                        case "login_fail_details":
                            let v = TeamLog.LoginFailDetailsSerializer().deserialize(json)
                            return EventDetails.loginFailDetails(v)
                        case "login_success_details":
                            let v = TeamLog.LoginSuccessDetailsSerializer().deserialize(json)
                            return EventDetails.loginSuccessDetails(v)
                        case "logout_details":
                            let v = TeamLog.LogoutDetailsSerializer().deserialize(json)
                            return EventDetails.logoutDetails(v)
                        case "reseller_support_session_end_details":
                            let v = TeamLog.ResellerSupportSessionEndDetailsSerializer().deserialize(json)
                            return EventDetails.resellerSupportSessionEndDetails(v)
                        case "reseller_support_session_start_details":
                            let v = TeamLog.ResellerSupportSessionStartDetailsSerializer().deserialize(json)
                            return EventDetails.resellerSupportSessionStartDetails(v)
                        case "sign_in_as_session_end_details":
                            let v = TeamLog.SignInAsSessionEndDetailsSerializer().deserialize(json)
                            return EventDetails.signInAsSessionEndDetails(v)
                        case "sign_in_as_session_start_details":
                            let v = TeamLog.SignInAsSessionStartDetailsSerializer().deserialize(json)
                            return EventDetails.signInAsSessionStartDetails(v)
                        case "sso_error_details":
                            let v = TeamLog.SsoErrorDetailsSerializer().deserialize(json)
                            return EventDetails.ssoErrorDetails(v)
                        case "member_add_name_details":
                            let v = TeamLog.MemberAddNameDetailsSerializer().deserialize(json)
                            return EventDetails.memberAddNameDetails(v)
                        case "member_change_admin_role_details":
                            let v = TeamLog.MemberChangeAdminRoleDetailsSerializer().deserialize(json)
                            return EventDetails.memberChangeAdminRoleDetails(v)
                        case "member_change_email_details":
                            let v = TeamLog.MemberChangeEmailDetailsSerializer().deserialize(json)
                            return EventDetails.memberChangeEmailDetails(v)
                        case "member_change_membership_type_details":
                            let v = TeamLog.MemberChangeMembershipTypeDetailsSerializer().deserialize(json)
                            return EventDetails.memberChangeMembershipTypeDetails(v)
                        case "member_change_name_details":
                            let v = TeamLog.MemberChangeNameDetailsSerializer().deserialize(json)
                            return EventDetails.memberChangeNameDetails(v)
                        case "member_change_status_details":
                            let v = TeamLog.MemberChangeStatusDetailsSerializer().deserialize(json)
                            return EventDetails.memberChangeStatusDetails(v)
                        case "member_delete_manual_contacts_details":
                            let v = TeamLog.MemberDeleteManualContactsDetailsSerializer().deserialize(json)
                            return EventDetails.memberDeleteManualContactsDetails(v)
                        case "member_permanently_delete_account_contents_details":
                            let v = TeamLog.MemberPermanentlyDeleteAccountContentsDetailsSerializer().deserialize(json)
                            return EventDetails.memberPermanentlyDeleteAccountContentsDetails(v)
                        case "member_space_limits_add_custom_quota_details":
                            let v = TeamLog.MemberSpaceLimitsAddCustomQuotaDetailsSerializer().deserialize(json)
                            return EventDetails.memberSpaceLimitsAddCustomQuotaDetails(v)
                        case "member_space_limits_change_custom_quota_details":
                            let v = TeamLog.MemberSpaceLimitsChangeCustomQuotaDetailsSerializer().deserialize(json)
                            return EventDetails.memberSpaceLimitsChangeCustomQuotaDetails(v)
                        case "member_space_limits_change_status_details":
                            let v = TeamLog.MemberSpaceLimitsChangeStatusDetailsSerializer().deserialize(json)
                            return EventDetails.memberSpaceLimitsChangeStatusDetails(v)
                        case "member_space_limits_remove_custom_quota_details":
                            let v = TeamLog.MemberSpaceLimitsRemoveCustomQuotaDetailsSerializer().deserialize(json)
                            return EventDetails.memberSpaceLimitsRemoveCustomQuotaDetails(v)
                        case "member_suggest_details":
                            let v = TeamLog.MemberSuggestDetailsSerializer().deserialize(json)
                            return EventDetails.memberSuggestDetails(v)
                        case "member_transfer_account_contents_details":
                            let v = TeamLog.MemberTransferAccountContentsDetailsSerializer().deserialize(json)
                            return EventDetails.memberTransferAccountContentsDetails(v)
                        case "secondary_mails_policy_changed_details":
                            let v = TeamLog.SecondaryMailsPolicyChangedDetailsSerializer().deserialize(json)
                            return EventDetails.secondaryMailsPolicyChangedDetails(v)
                        case "paper_content_add_member_details":
                            let v = TeamLog.PaperContentAddMemberDetailsSerializer().deserialize(json)
                            return EventDetails.paperContentAddMemberDetails(v)
                        case "paper_content_add_to_folder_details":
                            let v = TeamLog.PaperContentAddToFolderDetailsSerializer().deserialize(json)
                            return EventDetails.paperContentAddToFolderDetails(v)
                        case "paper_content_archive_details":
                            let v = TeamLog.PaperContentArchiveDetailsSerializer().deserialize(json)
                            return EventDetails.paperContentArchiveDetails(v)
                        case "paper_content_create_details":
                            let v = TeamLog.PaperContentCreateDetailsSerializer().deserialize(json)
                            return EventDetails.paperContentCreateDetails(v)
                        case "paper_content_permanently_delete_details":
                            let v = TeamLog.PaperContentPermanentlyDeleteDetailsSerializer().deserialize(json)
                            return EventDetails.paperContentPermanentlyDeleteDetails(v)
                        case "paper_content_remove_from_folder_details":
                            let v = TeamLog.PaperContentRemoveFromFolderDetailsSerializer().deserialize(json)
                            return EventDetails.paperContentRemoveFromFolderDetails(v)
                        case "paper_content_remove_member_details":
                            let v = TeamLog.PaperContentRemoveMemberDetailsSerializer().deserialize(json)
                            return EventDetails.paperContentRemoveMemberDetails(v)
                        case "paper_content_rename_details":
                            let v = TeamLog.PaperContentRenameDetailsSerializer().deserialize(json)
                            return EventDetails.paperContentRenameDetails(v)
                        case "paper_content_restore_details":
                            let v = TeamLog.PaperContentRestoreDetailsSerializer().deserialize(json)
                            return EventDetails.paperContentRestoreDetails(v)
                        case "paper_doc_add_comment_details":
                            let v = TeamLog.PaperDocAddCommentDetailsSerializer().deserialize(json)
                            return EventDetails.paperDocAddCommentDetails(v)
                        case "paper_doc_change_member_role_details":
                            let v = TeamLog.PaperDocChangeMemberRoleDetailsSerializer().deserialize(json)
                            return EventDetails.paperDocChangeMemberRoleDetails(v)
                        case "paper_doc_change_sharing_policy_details":
                            let v = TeamLog.PaperDocChangeSharingPolicyDetailsSerializer().deserialize(json)
                            return EventDetails.paperDocChangeSharingPolicyDetails(v)
                        case "paper_doc_change_subscription_details":
                            let v = TeamLog.PaperDocChangeSubscriptionDetailsSerializer().deserialize(json)
                            return EventDetails.paperDocChangeSubscriptionDetails(v)
                        case "paper_doc_deleted_details":
                            let v = TeamLog.PaperDocDeletedDetailsSerializer().deserialize(json)
                            return EventDetails.paperDocDeletedDetails(v)
                        case "paper_doc_delete_comment_details":
                            let v = TeamLog.PaperDocDeleteCommentDetailsSerializer().deserialize(json)
                            return EventDetails.paperDocDeleteCommentDetails(v)
                        case "paper_doc_download_details":
                            let v = TeamLog.PaperDocDownloadDetailsSerializer().deserialize(json)
                            return EventDetails.paperDocDownloadDetails(v)
                        case "paper_doc_edit_details":
                            let v = TeamLog.PaperDocEditDetailsSerializer().deserialize(json)
                            return EventDetails.paperDocEditDetails(v)
                        case "paper_doc_edit_comment_details":
                            let v = TeamLog.PaperDocEditCommentDetailsSerializer().deserialize(json)
                            return EventDetails.paperDocEditCommentDetails(v)
                        case "paper_doc_followed_details":
                            let v = TeamLog.PaperDocFollowedDetailsSerializer().deserialize(json)
                            return EventDetails.paperDocFollowedDetails(v)
                        case "paper_doc_mention_details":
                            let v = TeamLog.PaperDocMentionDetailsSerializer().deserialize(json)
                            return EventDetails.paperDocMentionDetails(v)
                        case "paper_doc_ownership_changed_details":
                            let v = TeamLog.PaperDocOwnershipChangedDetailsSerializer().deserialize(json)
                            return EventDetails.paperDocOwnershipChangedDetails(v)
                        case "paper_doc_request_access_details":
                            let v = TeamLog.PaperDocRequestAccessDetailsSerializer().deserialize(json)
                            return EventDetails.paperDocRequestAccessDetails(v)
                        case "paper_doc_resolve_comment_details":
                            let v = TeamLog.PaperDocResolveCommentDetailsSerializer().deserialize(json)
                            return EventDetails.paperDocResolveCommentDetails(v)
                        case "paper_doc_revert_details":
                            let v = TeamLog.PaperDocRevertDetailsSerializer().deserialize(json)
                            return EventDetails.paperDocRevertDetails(v)
                        case "paper_doc_slack_share_details":
                            let v = TeamLog.PaperDocSlackShareDetailsSerializer().deserialize(json)
                            return EventDetails.paperDocSlackShareDetails(v)
                        case "paper_doc_team_invite_details":
                            let v = TeamLog.PaperDocTeamInviteDetailsSerializer().deserialize(json)
                            return EventDetails.paperDocTeamInviteDetails(v)
                        case "paper_doc_trashed_details":
                            let v = TeamLog.PaperDocTrashedDetailsSerializer().deserialize(json)
                            return EventDetails.paperDocTrashedDetails(v)
                        case "paper_doc_unresolve_comment_details":
                            let v = TeamLog.PaperDocUnresolveCommentDetailsSerializer().deserialize(json)
                            return EventDetails.paperDocUnresolveCommentDetails(v)
                        case "paper_doc_untrashed_details":
                            let v = TeamLog.PaperDocUntrashedDetailsSerializer().deserialize(json)
                            return EventDetails.paperDocUntrashedDetails(v)
                        case "paper_doc_view_details":
                            let v = TeamLog.PaperDocViewDetailsSerializer().deserialize(json)
                            return EventDetails.paperDocViewDetails(v)
                        case "paper_external_view_allow_details":
                            let v = TeamLog.PaperExternalViewAllowDetailsSerializer().deserialize(json)
                            return EventDetails.paperExternalViewAllowDetails(v)
                        case "paper_external_view_default_team_details":
                            let v = TeamLog.PaperExternalViewDefaultTeamDetailsSerializer().deserialize(json)
                            return EventDetails.paperExternalViewDefaultTeamDetails(v)
                        case "paper_external_view_forbid_details":
                            let v = TeamLog.PaperExternalViewForbidDetailsSerializer().deserialize(json)
                            return EventDetails.paperExternalViewForbidDetails(v)
                        case "paper_folder_change_subscription_details":
                            let v = TeamLog.PaperFolderChangeSubscriptionDetailsSerializer().deserialize(json)
                            return EventDetails.paperFolderChangeSubscriptionDetails(v)
                        case "paper_folder_deleted_details":
                            let v = TeamLog.PaperFolderDeletedDetailsSerializer().deserialize(json)
                            return EventDetails.paperFolderDeletedDetails(v)
                        case "paper_folder_followed_details":
                            let v = TeamLog.PaperFolderFollowedDetailsSerializer().deserialize(json)
                            return EventDetails.paperFolderFollowedDetails(v)
                        case "paper_folder_team_invite_details":
                            let v = TeamLog.PaperFolderTeamInviteDetailsSerializer().deserialize(json)
                            return EventDetails.paperFolderTeamInviteDetails(v)
                        case "password_change_details":
                            let v = TeamLog.PasswordChangeDetailsSerializer().deserialize(json)
                            return EventDetails.passwordChangeDetails(v)
                        case "password_reset_details":
                            let v = TeamLog.PasswordResetDetailsSerializer().deserialize(json)
                            return EventDetails.passwordResetDetails(v)
                        case "password_reset_all_details":
                            let v = TeamLog.PasswordResetAllDetailsSerializer().deserialize(json)
                            return EventDetails.passwordResetAllDetails(v)
                        case "emm_create_exceptions_report_details":
                            let v = TeamLog.EmmCreateExceptionsReportDetailsSerializer().deserialize(json)
                            return EventDetails.emmCreateExceptionsReportDetails(v)
                        case "emm_create_usage_report_details":
                            let v = TeamLog.EmmCreateUsageReportDetailsSerializer().deserialize(json)
                            return EventDetails.emmCreateUsageReportDetails(v)
                        case "export_members_report_details":
                            let v = TeamLog.ExportMembersReportDetailsSerializer().deserialize(json)
                            return EventDetails.exportMembersReportDetails(v)
                        case "paper_admin_export_start_details":
                            let v = TeamLog.PaperAdminExportStartDetailsSerializer().deserialize(json)
                            return EventDetails.paperAdminExportStartDetails(v)
                        case "smart_sync_create_admin_privilege_report_details":
                            let v = TeamLog.SmartSyncCreateAdminPrivilegeReportDetailsSerializer().deserialize(json)
                            return EventDetails.smartSyncCreateAdminPrivilegeReportDetails(v)
                        case "team_activity_create_report_details":
                            let v = TeamLog.TeamActivityCreateReportDetailsSerializer().deserialize(json)
                            return EventDetails.teamActivityCreateReportDetails(v)
                        case "collection_share_details":
                            let v = TeamLog.CollectionShareDetailsSerializer().deserialize(json)
                            return EventDetails.collectionShareDetails(v)
                        case "note_acl_invite_only_details":
                            let v = TeamLog.NoteAclInviteOnlyDetailsSerializer().deserialize(json)
                            return EventDetails.noteAclInviteOnlyDetails(v)
                        case "note_acl_link_details":
                            let v = TeamLog.NoteAclLinkDetailsSerializer().deserialize(json)
                            return EventDetails.noteAclLinkDetails(v)
                        case "note_acl_team_link_details":
                            let v = TeamLog.NoteAclTeamLinkDetailsSerializer().deserialize(json)
                            return EventDetails.noteAclTeamLinkDetails(v)
                        case "note_shared_details":
                            let v = TeamLog.NoteSharedDetailsSerializer().deserialize(json)
                            return EventDetails.noteSharedDetails(v)
                        case "note_share_receive_details":
                            let v = TeamLog.NoteShareReceiveDetailsSerializer().deserialize(json)
                            return EventDetails.noteShareReceiveDetails(v)
                        case "open_note_shared_details":
                            let v = TeamLog.OpenNoteSharedDetailsSerializer().deserialize(json)
                            return EventDetails.openNoteSharedDetails(v)
                        case "sf_add_group_details":
                            let v = TeamLog.SfAddGroupDetailsSerializer().deserialize(json)
                            return EventDetails.sfAddGroupDetails(v)
                        case "sf_allow_non_members_to_view_shared_links_details":
                            let v = TeamLog.SfAllowNonMembersToViewSharedLinksDetailsSerializer().deserialize(json)
                            return EventDetails.sfAllowNonMembersToViewSharedLinksDetails(v)
                        case "sf_external_invite_warn_details":
                            let v = TeamLog.SfExternalInviteWarnDetailsSerializer().deserialize(json)
                            return EventDetails.sfExternalInviteWarnDetails(v)
                        case "sf_fb_invite_details":
                            let v = TeamLog.SfFbInviteDetailsSerializer().deserialize(json)
                            return EventDetails.sfFbInviteDetails(v)
                        case "sf_fb_invite_change_role_details":
                            let v = TeamLog.SfFbInviteChangeRoleDetailsSerializer().deserialize(json)
                            return EventDetails.sfFbInviteChangeRoleDetails(v)
                        case "sf_fb_uninvite_details":
                            let v = TeamLog.SfFbUninviteDetailsSerializer().deserialize(json)
                            return EventDetails.sfFbUninviteDetails(v)
                        case "sf_invite_group_details":
                            let v = TeamLog.SfInviteGroupDetailsSerializer().deserialize(json)
                            return EventDetails.sfInviteGroupDetails(v)
                        case "sf_team_grant_access_details":
                            let v = TeamLog.SfTeamGrantAccessDetailsSerializer().deserialize(json)
                            return EventDetails.sfTeamGrantAccessDetails(v)
                        case "sf_team_invite_details":
                            let v = TeamLog.SfTeamInviteDetailsSerializer().deserialize(json)
                            return EventDetails.sfTeamInviteDetails(v)
                        case "sf_team_invite_change_role_details":
                            let v = TeamLog.SfTeamInviteChangeRoleDetailsSerializer().deserialize(json)
                            return EventDetails.sfTeamInviteChangeRoleDetails(v)
                        case "sf_team_join_details":
                            let v = TeamLog.SfTeamJoinDetailsSerializer().deserialize(json)
                            return EventDetails.sfTeamJoinDetails(v)
                        case "sf_team_join_from_oob_link_details":
                            let v = TeamLog.SfTeamJoinFromOobLinkDetailsSerializer().deserialize(json)
                            return EventDetails.sfTeamJoinFromOobLinkDetails(v)
                        case "sf_team_uninvite_details":
                            let v = TeamLog.SfTeamUninviteDetailsSerializer().deserialize(json)
                            return EventDetails.sfTeamUninviteDetails(v)
                        case "shared_content_add_invitees_details":
                            let v = TeamLog.SharedContentAddInviteesDetailsSerializer().deserialize(json)
                            return EventDetails.sharedContentAddInviteesDetails(v)
                        case "shared_content_add_link_expiry_details":
                            let v = TeamLog.SharedContentAddLinkExpiryDetailsSerializer().deserialize(json)
                            return EventDetails.sharedContentAddLinkExpiryDetails(v)
                        case "shared_content_add_link_password_details":
                            let v = TeamLog.SharedContentAddLinkPasswordDetailsSerializer().deserialize(json)
                            return EventDetails.sharedContentAddLinkPasswordDetails(v)
                        case "shared_content_add_member_details":
                            let v = TeamLog.SharedContentAddMemberDetailsSerializer().deserialize(json)
                            return EventDetails.sharedContentAddMemberDetails(v)
                        case "shared_content_change_downloads_policy_details":
                            let v = TeamLog.SharedContentChangeDownloadsPolicyDetailsSerializer().deserialize(json)
                            return EventDetails.sharedContentChangeDownloadsPolicyDetails(v)
                        case "shared_content_change_invitee_role_details":
                            let v = TeamLog.SharedContentChangeInviteeRoleDetailsSerializer().deserialize(json)
                            return EventDetails.sharedContentChangeInviteeRoleDetails(v)
                        case "shared_content_change_link_audience_details":
                            let v = TeamLog.SharedContentChangeLinkAudienceDetailsSerializer().deserialize(json)
                            return EventDetails.sharedContentChangeLinkAudienceDetails(v)
                        case "shared_content_change_link_expiry_details":
                            let v = TeamLog.SharedContentChangeLinkExpiryDetailsSerializer().deserialize(json)
                            return EventDetails.sharedContentChangeLinkExpiryDetails(v)
                        case "shared_content_change_link_password_details":
                            let v = TeamLog.SharedContentChangeLinkPasswordDetailsSerializer().deserialize(json)
                            return EventDetails.sharedContentChangeLinkPasswordDetails(v)
                        case "shared_content_change_member_role_details":
                            let v = TeamLog.SharedContentChangeMemberRoleDetailsSerializer().deserialize(json)
                            return EventDetails.sharedContentChangeMemberRoleDetails(v)
                        case "shared_content_change_viewer_info_policy_details":
                            let v = TeamLog.SharedContentChangeViewerInfoPolicyDetailsSerializer().deserialize(json)
                            return EventDetails.sharedContentChangeViewerInfoPolicyDetails(v)
                        case "shared_content_claim_invitation_details":
                            let v = TeamLog.SharedContentClaimInvitationDetailsSerializer().deserialize(json)
                            return EventDetails.sharedContentClaimInvitationDetails(v)
                        case "shared_content_copy_details":
                            let v = TeamLog.SharedContentCopyDetailsSerializer().deserialize(json)
                            return EventDetails.sharedContentCopyDetails(v)
                        case "shared_content_download_details":
                            let v = TeamLog.SharedContentDownloadDetailsSerializer().deserialize(json)
                            return EventDetails.sharedContentDownloadDetails(v)
                        case "shared_content_relinquish_membership_details":
                            let v = TeamLog.SharedContentRelinquishMembershipDetailsSerializer().deserialize(json)
                            return EventDetails.sharedContentRelinquishMembershipDetails(v)
                        case "shared_content_remove_invitees_details":
                            let v = TeamLog.SharedContentRemoveInviteesDetailsSerializer().deserialize(json)
                            return EventDetails.sharedContentRemoveInviteesDetails(v)
                        case "shared_content_remove_link_expiry_details":
                            let v = TeamLog.SharedContentRemoveLinkExpiryDetailsSerializer().deserialize(json)
                            return EventDetails.sharedContentRemoveLinkExpiryDetails(v)
                        case "shared_content_remove_link_password_details":
                            let v = TeamLog.SharedContentRemoveLinkPasswordDetailsSerializer().deserialize(json)
                            return EventDetails.sharedContentRemoveLinkPasswordDetails(v)
                        case "shared_content_remove_member_details":
                            let v = TeamLog.SharedContentRemoveMemberDetailsSerializer().deserialize(json)
                            return EventDetails.sharedContentRemoveMemberDetails(v)
                        case "shared_content_request_access_details":
                            let v = TeamLog.SharedContentRequestAccessDetailsSerializer().deserialize(json)
                            return EventDetails.sharedContentRequestAccessDetails(v)
                        case "shared_content_unshare_details":
                            let v = TeamLog.SharedContentUnshareDetailsSerializer().deserialize(json)
                            return EventDetails.sharedContentUnshareDetails(v)
                        case "shared_content_view_details":
                            let v = TeamLog.SharedContentViewDetailsSerializer().deserialize(json)
                            return EventDetails.sharedContentViewDetails(v)
                        case "shared_folder_change_link_policy_details":
                            let v = TeamLog.SharedFolderChangeLinkPolicyDetailsSerializer().deserialize(json)
                            return EventDetails.sharedFolderChangeLinkPolicyDetails(v)
                        case "shared_folder_change_members_inheritance_policy_details":
                            let v = TeamLog.SharedFolderChangeMembersInheritancePolicyDetailsSerializer().deserialize(json)
                            return EventDetails.sharedFolderChangeMembersInheritancePolicyDetails(v)
                        case "shared_folder_change_members_management_policy_details":
                            let v = TeamLog.SharedFolderChangeMembersManagementPolicyDetailsSerializer().deserialize(json)
                            return EventDetails.sharedFolderChangeMembersManagementPolicyDetails(v)
                        case "shared_folder_change_members_policy_details":
                            let v = TeamLog.SharedFolderChangeMembersPolicyDetailsSerializer().deserialize(json)
                            return EventDetails.sharedFolderChangeMembersPolicyDetails(v)
                        case "shared_folder_create_details":
                            let v = TeamLog.SharedFolderCreateDetailsSerializer().deserialize(json)
                            return EventDetails.sharedFolderCreateDetails(v)
                        case "shared_folder_decline_invitation_details":
                            let v = TeamLog.SharedFolderDeclineInvitationDetailsSerializer().deserialize(json)
                            return EventDetails.sharedFolderDeclineInvitationDetails(v)
                        case "shared_folder_mount_details":
                            let v = TeamLog.SharedFolderMountDetailsSerializer().deserialize(json)
                            return EventDetails.sharedFolderMountDetails(v)
                        case "shared_folder_nest_details":
                            let v = TeamLog.SharedFolderNestDetailsSerializer().deserialize(json)
                            return EventDetails.sharedFolderNestDetails(v)
                        case "shared_folder_transfer_ownership_details":
                            let v = TeamLog.SharedFolderTransferOwnershipDetailsSerializer().deserialize(json)
                            return EventDetails.sharedFolderTransferOwnershipDetails(v)
                        case "shared_folder_unmount_details":
                            let v = TeamLog.SharedFolderUnmountDetailsSerializer().deserialize(json)
                            return EventDetails.sharedFolderUnmountDetails(v)
                        case "shared_link_add_expiry_details":
                            let v = TeamLog.SharedLinkAddExpiryDetailsSerializer().deserialize(json)
                            return EventDetails.sharedLinkAddExpiryDetails(v)
                        case "shared_link_change_expiry_details":
                            let v = TeamLog.SharedLinkChangeExpiryDetailsSerializer().deserialize(json)
                            return EventDetails.sharedLinkChangeExpiryDetails(v)
                        case "shared_link_change_visibility_details":
                            let v = TeamLog.SharedLinkChangeVisibilityDetailsSerializer().deserialize(json)
                            return EventDetails.sharedLinkChangeVisibilityDetails(v)
                        case "shared_link_copy_details":
                            let v = TeamLog.SharedLinkCopyDetailsSerializer().deserialize(json)
                            return EventDetails.sharedLinkCopyDetails(v)
                        case "shared_link_create_details":
                            let v = TeamLog.SharedLinkCreateDetailsSerializer().deserialize(json)
                            return EventDetails.sharedLinkCreateDetails(v)
                        case "shared_link_disable_details":
                            let v = TeamLog.SharedLinkDisableDetailsSerializer().deserialize(json)
                            return EventDetails.sharedLinkDisableDetails(v)
                        case "shared_link_download_details":
                            let v = TeamLog.SharedLinkDownloadDetailsSerializer().deserialize(json)
                            return EventDetails.sharedLinkDownloadDetails(v)
                        case "shared_link_remove_expiry_details":
                            let v = TeamLog.SharedLinkRemoveExpiryDetailsSerializer().deserialize(json)
                            return EventDetails.sharedLinkRemoveExpiryDetails(v)
                        case "shared_link_share_details":
                            let v = TeamLog.SharedLinkShareDetailsSerializer().deserialize(json)
                            return EventDetails.sharedLinkShareDetails(v)
                        case "shared_link_view_details":
                            let v = TeamLog.SharedLinkViewDetailsSerializer().deserialize(json)
                            return EventDetails.sharedLinkViewDetails(v)
                        case "shared_note_opened_details":
                            let v = TeamLog.SharedNoteOpenedDetailsSerializer().deserialize(json)
                            return EventDetails.sharedNoteOpenedDetails(v)
                        case "shmodel_group_share_details":
                            let v = TeamLog.ShmodelGroupShareDetailsSerializer().deserialize(json)
                            return EventDetails.shmodelGroupShareDetails(v)
                        case "showcase_access_granted_details":
                            let v = TeamLog.ShowcaseAccessGrantedDetailsSerializer().deserialize(json)
                            return EventDetails.showcaseAccessGrantedDetails(v)
                        case "showcase_add_member_details":
                            let v = TeamLog.ShowcaseAddMemberDetailsSerializer().deserialize(json)
                            return EventDetails.showcaseAddMemberDetails(v)
                        case "showcase_archived_details":
                            let v = TeamLog.ShowcaseArchivedDetailsSerializer().deserialize(json)
                            return EventDetails.showcaseArchivedDetails(v)
                        case "showcase_created_details":
                            let v = TeamLog.ShowcaseCreatedDetailsSerializer().deserialize(json)
                            return EventDetails.showcaseCreatedDetails(v)
                        case "showcase_delete_comment_details":
                            let v = TeamLog.ShowcaseDeleteCommentDetailsSerializer().deserialize(json)
                            return EventDetails.showcaseDeleteCommentDetails(v)
                        case "showcase_edited_details":
                            let v = TeamLog.ShowcaseEditedDetailsSerializer().deserialize(json)
                            return EventDetails.showcaseEditedDetails(v)
                        case "showcase_edit_comment_details":
                            let v = TeamLog.ShowcaseEditCommentDetailsSerializer().deserialize(json)
                            return EventDetails.showcaseEditCommentDetails(v)
                        case "showcase_file_added_details":
                            let v = TeamLog.ShowcaseFileAddedDetailsSerializer().deserialize(json)
                            return EventDetails.showcaseFileAddedDetails(v)
                        case "showcase_file_download_details":
                            let v = TeamLog.ShowcaseFileDownloadDetailsSerializer().deserialize(json)
                            return EventDetails.showcaseFileDownloadDetails(v)
                        case "showcase_file_removed_details":
                            let v = TeamLog.ShowcaseFileRemovedDetailsSerializer().deserialize(json)
                            return EventDetails.showcaseFileRemovedDetails(v)
                        case "showcase_file_view_details":
                            let v = TeamLog.ShowcaseFileViewDetailsSerializer().deserialize(json)
                            return EventDetails.showcaseFileViewDetails(v)
                        case "showcase_permanently_deleted_details":
                            let v = TeamLog.ShowcasePermanentlyDeletedDetailsSerializer().deserialize(json)
                            return EventDetails.showcasePermanentlyDeletedDetails(v)
                        case "showcase_post_comment_details":
                            let v = TeamLog.ShowcasePostCommentDetailsSerializer().deserialize(json)
                            return EventDetails.showcasePostCommentDetails(v)
                        case "showcase_remove_member_details":
                            let v = TeamLog.ShowcaseRemoveMemberDetailsSerializer().deserialize(json)
                            return EventDetails.showcaseRemoveMemberDetails(v)
                        case "showcase_renamed_details":
                            let v = TeamLog.ShowcaseRenamedDetailsSerializer().deserialize(json)
                            return EventDetails.showcaseRenamedDetails(v)
                        case "showcase_request_access_details":
                            let v = TeamLog.ShowcaseRequestAccessDetailsSerializer().deserialize(json)
                            return EventDetails.showcaseRequestAccessDetails(v)
                        case "showcase_resolve_comment_details":
                            let v = TeamLog.ShowcaseResolveCommentDetailsSerializer().deserialize(json)
                            return EventDetails.showcaseResolveCommentDetails(v)
                        case "showcase_restored_details":
                            let v = TeamLog.ShowcaseRestoredDetailsSerializer().deserialize(json)
                            return EventDetails.showcaseRestoredDetails(v)
                        case "showcase_trashed_details":
                            let v = TeamLog.ShowcaseTrashedDetailsSerializer().deserialize(json)
                            return EventDetails.showcaseTrashedDetails(v)
                        case "showcase_trashed_deprecated_details":
                            let v = TeamLog.ShowcaseTrashedDeprecatedDetailsSerializer().deserialize(json)
                            return EventDetails.showcaseTrashedDeprecatedDetails(v)
                        case "showcase_unresolve_comment_details":
                            let v = TeamLog.ShowcaseUnresolveCommentDetailsSerializer().deserialize(json)
                            return EventDetails.showcaseUnresolveCommentDetails(v)
                        case "showcase_untrashed_details":
                            let v = TeamLog.ShowcaseUntrashedDetailsSerializer().deserialize(json)
                            return EventDetails.showcaseUntrashedDetails(v)
                        case "showcase_untrashed_deprecated_details":
                            let v = TeamLog.ShowcaseUntrashedDeprecatedDetailsSerializer().deserialize(json)
                            return EventDetails.showcaseUntrashedDeprecatedDetails(v)
                        case "showcase_view_details":
                            let v = TeamLog.ShowcaseViewDetailsSerializer().deserialize(json)
                            return EventDetails.showcaseViewDetails(v)
                        case "sso_add_cert_details":
                            let v = TeamLog.SsoAddCertDetailsSerializer().deserialize(json)
                            return EventDetails.ssoAddCertDetails(v)
                        case "sso_add_login_url_details":
                            let v = TeamLog.SsoAddLoginUrlDetailsSerializer().deserialize(json)
                            return EventDetails.ssoAddLoginUrlDetails(v)
                        case "sso_add_logout_url_details":
                            let v = TeamLog.SsoAddLogoutUrlDetailsSerializer().deserialize(json)
                            return EventDetails.ssoAddLogoutUrlDetails(v)
                        case "sso_change_cert_details":
                            let v = TeamLog.SsoChangeCertDetailsSerializer().deserialize(json)
                            return EventDetails.ssoChangeCertDetails(v)
                        case "sso_change_login_url_details":
                            let v = TeamLog.SsoChangeLoginUrlDetailsSerializer().deserialize(json)
                            return EventDetails.ssoChangeLoginUrlDetails(v)
                        case "sso_change_logout_url_details":
                            let v = TeamLog.SsoChangeLogoutUrlDetailsSerializer().deserialize(json)
                            return EventDetails.ssoChangeLogoutUrlDetails(v)
                        case "sso_change_saml_identity_mode_details":
                            let v = TeamLog.SsoChangeSamlIdentityModeDetailsSerializer().deserialize(json)
                            return EventDetails.ssoChangeSamlIdentityModeDetails(v)
                        case "sso_remove_cert_details":
                            let v = TeamLog.SsoRemoveCertDetailsSerializer().deserialize(json)
                            return EventDetails.ssoRemoveCertDetails(v)
                        case "sso_remove_login_url_details":
                            let v = TeamLog.SsoRemoveLoginUrlDetailsSerializer().deserialize(json)
                            return EventDetails.ssoRemoveLoginUrlDetails(v)
                        case "sso_remove_logout_url_details":
                            let v = TeamLog.SsoRemoveLogoutUrlDetailsSerializer().deserialize(json)
                            return EventDetails.ssoRemoveLogoutUrlDetails(v)
                        case "team_folder_change_status_details":
                            let v = TeamLog.TeamFolderChangeStatusDetailsSerializer().deserialize(json)
                            return EventDetails.teamFolderChangeStatusDetails(v)
                        case "team_folder_create_details":
                            let v = TeamLog.TeamFolderCreateDetailsSerializer().deserialize(json)
                            return EventDetails.teamFolderCreateDetails(v)
                        case "team_folder_downgrade_details":
                            let v = TeamLog.TeamFolderDowngradeDetailsSerializer().deserialize(json)
                            return EventDetails.teamFolderDowngradeDetails(v)
                        case "team_folder_permanently_delete_details":
                            let v = TeamLog.TeamFolderPermanentlyDeleteDetailsSerializer().deserialize(json)
                            return EventDetails.teamFolderPermanentlyDeleteDetails(v)
                        case "team_folder_rename_details":
                            let v = TeamLog.TeamFolderRenameDetailsSerializer().deserialize(json)
                            return EventDetails.teamFolderRenameDetails(v)
                        case "team_selective_sync_settings_changed_details":
                            let v = TeamLog.TeamSelectiveSyncSettingsChangedDetailsSerializer().deserialize(json)
                            return EventDetails.teamSelectiveSyncSettingsChangedDetails(v)
                        case "account_capture_change_policy_details":
                            let v = TeamLog.AccountCaptureChangePolicyDetailsSerializer().deserialize(json)
                            return EventDetails.accountCaptureChangePolicyDetails(v)
                        case "allow_download_disabled_details":
                            let v = TeamLog.AllowDownloadDisabledDetailsSerializer().deserialize(json)
                            return EventDetails.allowDownloadDisabledDetails(v)
                        case "allow_download_enabled_details":
                            let v = TeamLog.AllowDownloadEnabledDetailsSerializer().deserialize(json)
                            return EventDetails.allowDownloadEnabledDetails(v)
                        case "camera_uploads_policy_changed_details":
                            let v = TeamLog.CameraUploadsPolicyChangedDetailsSerializer().deserialize(json)
                            return EventDetails.cameraUploadsPolicyChangedDetails(v)
                        case "data_placement_restriction_change_policy_details":
                            let v = TeamLog.DataPlacementRestrictionChangePolicyDetailsSerializer().deserialize(json)
                            return EventDetails.dataPlacementRestrictionChangePolicyDetails(v)
                        case "data_placement_restriction_satisfy_policy_details":
                            let v = TeamLog.DataPlacementRestrictionSatisfyPolicyDetailsSerializer().deserialize(json)
                            return EventDetails.dataPlacementRestrictionSatisfyPolicyDetails(v)
                        case "device_approvals_change_desktop_policy_details":
                            let v = TeamLog.DeviceApprovalsChangeDesktopPolicyDetailsSerializer().deserialize(json)
                            return EventDetails.deviceApprovalsChangeDesktopPolicyDetails(v)
                        case "device_approvals_change_mobile_policy_details":
                            let v = TeamLog.DeviceApprovalsChangeMobilePolicyDetailsSerializer().deserialize(json)
                            return EventDetails.deviceApprovalsChangeMobilePolicyDetails(v)
                        case "device_approvals_change_overage_action_details":
                            let v = TeamLog.DeviceApprovalsChangeOverageActionDetailsSerializer().deserialize(json)
                            return EventDetails.deviceApprovalsChangeOverageActionDetails(v)
                        case "device_approvals_change_unlink_action_details":
                            let v = TeamLog.DeviceApprovalsChangeUnlinkActionDetailsSerializer().deserialize(json)
                            return EventDetails.deviceApprovalsChangeUnlinkActionDetails(v)
                        case "directory_restrictions_add_members_details":
                            let v = TeamLog.DirectoryRestrictionsAddMembersDetailsSerializer().deserialize(json)
                            return EventDetails.directoryRestrictionsAddMembersDetails(v)
                        case "directory_restrictions_remove_members_details":
                            let v = TeamLog.DirectoryRestrictionsRemoveMembersDetailsSerializer().deserialize(json)
                            return EventDetails.directoryRestrictionsRemoveMembersDetails(v)
                        case "emm_add_exception_details":
                            let v = TeamLog.EmmAddExceptionDetailsSerializer().deserialize(json)
                            return EventDetails.emmAddExceptionDetails(v)
                        case "emm_change_policy_details":
                            let v = TeamLog.EmmChangePolicyDetailsSerializer().deserialize(json)
                            return EventDetails.emmChangePolicyDetails(v)
                        case "emm_remove_exception_details":
                            let v = TeamLog.EmmRemoveExceptionDetailsSerializer().deserialize(json)
                            return EventDetails.emmRemoveExceptionDetails(v)
                        case "extended_version_history_change_policy_details":
                            let v = TeamLog.ExtendedVersionHistoryChangePolicyDetailsSerializer().deserialize(json)
                            return EventDetails.extendedVersionHistoryChangePolicyDetails(v)
                        case "file_comments_change_policy_details":
                            let v = TeamLog.FileCommentsChangePolicyDetailsSerializer().deserialize(json)
                            return EventDetails.fileCommentsChangePolicyDetails(v)
                        case "file_requests_change_policy_details":
                            let v = TeamLog.FileRequestsChangePolicyDetailsSerializer().deserialize(json)
                            return EventDetails.fileRequestsChangePolicyDetails(v)
                        case "file_requests_emails_enabled_details":
                            let v = TeamLog.FileRequestsEmailsEnabledDetailsSerializer().deserialize(json)
                            return EventDetails.fileRequestsEmailsEnabledDetails(v)
                        case "file_requests_emails_restricted_to_team_only_details":
                            let v = TeamLog.FileRequestsEmailsRestrictedToTeamOnlyDetailsSerializer().deserialize(json)
                            return EventDetails.fileRequestsEmailsRestrictedToTeamOnlyDetails(v)
                        case "google_sso_change_policy_details":
                            let v = TeamLog.GoogleSsoChangePolicyDetailsSerializer().deserialize(json)
                            return EventDetails.googleSsoChangePolicyDetails(v)
                        case "group_user_management_change_policy_details":
                            let v = TeamLog.GroupUserManagementChangePolicyDetailsSerializer().deserialize(json)
                            return EventDetails.groupUserManagementChangePolicyDetails(v)
                        case "member_requests_change_policy_details":
                            let v = TeamLog.MemberRequestsChangePolicyDetailsSerializer().deserialize(json)
                            return EventDetails.memberRequestsChangePolicyDetails(v)
                        case "member_space_limits_add_exception_details":
                            let v = TeamLog.MemberSpaceLimitsAddExceptionDetailsSerializer().deserialize(json)
                            return EventDetails.memberSpaceLimitsAddExceptionDetails(v)
                        case "member_space_limits_change_caps_type_policy_details":
                            let v = TeamLog.MemberSpaceLimitsChangeCapsTypePolicyDetailsSerializer().deserialize(json)
                            return EventDetails.memberSpaceLimitsChangeCapsTypePolicyDetails(v)
                        case "member_space_limits_change_policy_details":
                            let v = TeamLog.MemberSpaceLimitsChangePolicyDetailsSerializer().deserialize(json)
                            return EventDetails.memberSpaceLimitsChangePolicyDetails(v)
                        case "member_space_limits_remove_exception_details":
                            let v = TeamLog.MemberSpaceLimitsRemoveExceptionDetailsSerializer().deserialize(json)
                            return EventDetails.memberSpaceLimitsRemoveExceptionDetails(v)
                        case "member_suggestions_change_policy_details":
                            let v = TeamLog.MemberSuggestionsChangePolicyDetailsSerializer().deserialize(json)
                            return EventDetails.memberSuggestionsChangePolicyDetails(v)
                        case "microsoft_office_addin_change_policy_details":
                            let v = TeamLog.MicrosoftOfficeAddinChangePolicyDetailsSerializer().deserialize(json)
                            return EventDetails.microsoftOfficeAddinChangePolicyDetails(v)
                        case "network_control_change_policy_details":
                            let v = TeamLog.NetworkControlChangePolicyDetailsSerializer().deserialize(json)
                            return EventDetails.networkControlChangePolicyDetails(v)
                        case "paper_change_deployment_policy_details":
                            let v = TeamLog.PaperChangeDeploymentPolicyDetailsSerializer().deserialize(json)
                            return EventDetails.paperChangeDeploymentPolicyDetails(v)
                        case "paper_change_member_link_policy_details":
                            let v = TeamLog.PaperChangeMemberLinkPolicyDetailsSerializer().deserialize(json)
                            return EventDetails.paperChangeMemberLinkPolicyDetails(v)
                        case "paper_change_member_policy_details":
                            let v = TeamLog.PaperChangeMemberPolicyDetailsSerializer().deserialize(json)
                            return EventDetails.paperChangeMemberPolicyDetails(v)
                        case "paper_change_policy_details":
                            let v = TeamLog.PaperChangePolicyDetailsSerializer().deserialize(json)
                            return EventDetails.paperChangePolicyDetails(v)
                        case "paper_enabled_users_group_addition_details":
                            let v = TeamLog.PaperEnabledUsersGroupAdditionDetailsSerializer().deserialize(json)
                            return EventDetails.paperEnabledUsersGroupAdditionDetails(v)
                        case "paper_enabled_users_group_removal_details":
                            let v = TeamLog.PaperEnabledUsersGroupRemovalDetailsSerializer().deserialize(json)
                            return EventDetails.paperEnabledUsersGroupRemovalDetails(v)
                        case "permanent_delete_change_policy_details":
                            let v = TeamLog.PermanentDeleteChangePolicyDetailsSerializer().deserialize(json)
                            return EventDetails.permanentDeleteChangePolicyDetails(v)
                        case "sharing_change_folder_join_policy_details":
                            let v = TeamLog.SharingChangeFolderJoinPolicyDetailsSerializer().deserialize(json)
                            return EventDetails.sharingChangeFolderJoinPolicyDetails(v)
                        case "sharing_change_link_policy_details":
                            let v = TeamLog.SharingChangeLinkPolicyDetailsSerializer().deserialize(json)
                            return EventDetails.sharingChangeLinkPolicyDetails(v)
                        case "sharing_change_member_policy_details":
                            let v = TeamLog.SharingChangeMemberPolicyDetailsSerializer().deserialize(json)
                            return EventDetails.sharingChangeMemberPolicyDetails(v)
                        case "showcase_change_download_policy_details":
                            let v = TeamLog.ShowcaseChangeDownloadPolicyDetailsSerializer().deserialize(json)
                            return EventDetails.showcaseChangeDownloadPolicyDetails(v)
                        case "showcase_change_enabled_policy_details":
                            let v = TeamLog.ShowcaseChangeEnabledPolicyDetailsSerializer().deserialize(json)
                            return EventDetails.showcaseChangeEnabledPolicyDetails(v)
                        case "showcase_change_external_sharing_policy_details":
                            let v = TeamLog.ShowcaseChangeExternalSharingPolicyDetailsSerializer().deserialize(json)
                            return EventDetails.showcaseChangeExternalSharingPolicyDetails(v)
                        case "smart_sync_change_policy_details":
                            let v = TeamLog.SmartSyncChangePolicyDetailsSerializer().deserialize(json)
                            return EventDetails.smartSyncChangePolicyDetails(v)
                        case "smart_sync_not_opt_out_details":
                            let v = TeamLog.SmartSyncNotOptOutDetailsSerializer().deserialize(json)
                            return EventDetails.smartSyncNotOptOutDetails(v)
                        case "smart_sync_opt_out_details":
                            let v = TeamLog.SmartSyncOptOutDetailsSerializer().deserialize(json)
                            return EventDetails.smartSyncOptOutDetails(v)
                        case "sso_change_policy_details":
                            let v = TeamLog.SsoChangePolicyDetailsSerializer().deserialize(json)
                            return EventDetails.ssoChangePolicyDetails(v)
                        case "team_selective_sync_policy_changed_details":
                            let v = TeamLog.TeamSelectiveSyncPolicyChangedDetailsSerializer().deserialize(json)
                            return EventDetails.teamSelectiveSyncPolicyChangedDetails(v)
                        case "tfa_change_policy_details":
                            let v = TeamLog.TfaChangePolicyDetailsSerializer().deserialize(json)
                            return EventDetails.tfaChangePolicyDetails(v)
                        case "two_account_change_policy_details":
                            let v = TeamLog.TwoAccountChangePolicyDetailsSerializer().deserialize(json)
                            return EventDetails.twoAccountChangePolicyDetails(v)
                        case "viewer_info_policy_changed_details":
                            let v = TeamLog.ViewerInfoPolicyChangedDetailsSerializer().deserialize(json)
                            return EventDetails.viewerInfoPolicyChangedDetails(v)
                        case "web_sessions_change_fixed_length_policy_details":
                            let v = TeamLog.WebSessionsChangeFixedLengthPolicyDetailsSerializer().deserialize(json)
                            return EventDetails.webSessionsChangeFixedLengthPolicyDetails(v)
                        case "web_sessions_change_idle_length_policy_details":
                            let v = TeamLog.WebSessionsChangeIdleLengthPolicyDetailsSerializer().deserialize(json)
                            return EventDetails.webSessionsChangeIdleLengthPolicyDetails(v)
                        case "team_merge_from_details":
                            let v = TeamLog.TeamMergeFromDetailsSerializer().deserialize(json)
                            return EventDetails.teamMergeFromDetails(v)
                        case "team_merge_to_details":
                            let v = TeamLog.TeamMergeToDetailsSerializer().deserialize(json)
                            return EventDetails.teamMergeToDetails(v)
                        case "team_profile_add_logo_details":
                            let v = TeamLog.TeamProfileAddLogoDetailsSerializer().deserialize(json)
                            return EventDetails.teamProfileAddLogoDetails(v)
                        case "team_profile_change_default_language_details":
                            let v = TeamLog.TeamProfileChangeDefaultLanguageDetailsSerializer().deserialize(json)
                            return EventDetails.teamProfileChangeDefaultLanguageDetails(v)
                        case "team_profile_change_logo_details":
                            let v = TeamLog.TeamProfileChangeLogoDetailsSerializer().deserialize(json)
                            return EventDetails.teamProfileChangeLogoDetails(v)
                        case "team_profile_change_name_details":
                            let v = TeamLog.TeamProfileChangeNameDetailsSerializer().deserialize(json)
                            return EventDetails.teamProfileChangeNameDetails(v)
                        case "team_profile_remove_logo_details":
                            let v = TeamLog.TeamProfileRemoveLogoDetailsSerializer().deserialize(json)
                            return EventDetails.teamProfileRemoveLogoDetails(v)
                        case "tfa_add_backup_phone_details":
                            let v = TeamLog.TfaAddBackupPhoneDetailsSerializer().deserialize(json)
                            return EventDetails.tfaAddBackupPhoneDetails(v)
                        case "tfa_add_security_key_details":
                            let v = TeamLog.TfaAddSecurityKeyDetailsSerializer().deserialize(json)
                            return EventDetails.tfaAddSecurityKeyDetails(v)
                        case "tfa_change_backup_phone_details":
                            let v = TeamLog.TfaChangeBackupPhoneDetailsSerializer().deserialize(json)
                            return EventDetails.tfaChangeBackupPhoneDetails(v)
                        case "tfa_change_status_details":
                            let v = TeamLog.TfaChangeStatusDetailsSerializer().deserialize(json)
                            return EventDetails.tfaChangeStatusDetails(v)
                        case "tfa_remove_backup_phone_details":
                            let v = TeamLog.TfaRemoveBackupPhoneDetailsSerializer().deserialize(json)
                            return EventDetails.tfaRemoveBackupPhoneDetails(v)
                        case "tfa_remove_security_key_details":
                            let v = TeamLog.TfaRemoveSecurityKeyDetailsSerializer().deserialize(json)
                            return EventDetails.tfaRemoveSecurityKeyDetails(v)
                        case "tfa_reset_details":
                            let v = TeamLog.TfaResetDetailsSerializer().deserialize(json)
                            return EventDetails.tfaResetDetails(v)
                        case "missing_details":
                            let v = TeamLog.MissingDetailsSerializer().deserialize(json)
                            return EventDetails.missingDetails(v)
                        case "other":
                            return EventDetails.other
                        default:
                            return EventDetails.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The type of the event.
    public enum EventType: CustomStringConvertible {
        /// (apps) Linked app for team
        case appLinkTeam(TeamLog.AppLinkTeamType)
        /// (apps) Linked app for member
        case appLinkUser(TeamLog.AppLinkUserType)
        /// (apps) Unlinked app for team
        case appUnlinkTeam(TeamLog.AppUnlinkTeamType)
        /// (apps) Unlinked app for member
        case appUnlinkUser(TeamLog.AppUnlinkUserType)
        /// (comments) Added file comment
        case fileAddComment(TeamLog.FileAddCommentType)
        /// (comments) Subscribed to or unsubscribed from comment notifications for file
        case fileChangeCommentSubscription(TeamLog.FileChangeCommentSubscriptionType)
        /// (comments) Deleted file comment
        case fileDeleteComment(TeamLog.FileDeleteCommentType)
        /// (comments) Edited file comment
        case fileEditComment(TeamLog.FileEditCommentType)
        /// (comments) Liked file comment (deprecated, no longer logged)
        case fileLikeComment(TeamLog.FileLikeCommentType)
        /// (comments) Resolved file comment
        case fileResolveComment(TeamLog.FileResolveCommentType)
        /// (comments) Unliked file comment (deprecated, no longer logged)
        case fileUnlikeComment(TeamLog.FileUnlikeCommentType)
        /// (comments) Unresolved file comment
        case fileUnresolveComment(TeamLog.FileUnresolveCommentType)
        /// (devices) Changed IP address associated with active desktop session
        case deviceChangeIpDesktop(TeamLog.DeviceChangeIpDesktopType)
        /// (devices) Changed IP address associated with active mobile session
        case deviceChangeIpMobile(TeamLog.DeviceChangeIpMobileType)
        /// (devices) Changed IP address associated with active web session
        case deviceChangeIpWeb(TeamLog.DeviceChangeIpWebType)
        /// (devices) Failed to delete all files from unlinked device
        case deviceDeleteOnUnlinkFail(TeamLog.DeviceDeleteOnUnlinkFailType)
        /// (devices) Deleted all files from unlinked device
        case deviceDeleteOnUnlinkSuccess(TeamLog.DeviceDeleteOnUnlinkSuccessType)
        /// (devices) Failed to link device
        case deviceLinkFail(TeamLog.DeviceLinkFailType)
        /// (devices) Linked device
        case deviceLinkSuccess(TeamLog.DeviceLinkSuccessType)
        /// (devices) Disabled device management (deprecated, no longer logged)
        case deviceManagementDisabled(TeamLog.DeviceManagementDisabledType)
        /// (devices) Enabled device management (deprecated, no longer logged)
        case deviceManagementEnabled(TeamLog.DeviceManagementEnabledType)
        /// (devices) Disconnected device
        case deviceUnlink(TeamLog.DeviceUnlinkType)
        /// (devices) Refreshed auth token used for setting up enterprise mobility management
        case emmRefreshAuthToken(TeamLog.EmmRefreshAuthTokenType)
        /// (domains) Granted/revoked option to enable account capture on team domains
        case accountCaptureChangeAvailability(TeamLog.AccountCaptureChangeAvailabilityType)
        /// (domains) Account-captured user migrated account to team
        case accountCaptureMigrateAccount(TeamLog.AccountCaptureMigrateAccountType)
        /// (domains) Sent proactive account capture email to all unmanaged members
        case accountCaptureNotificationEmailsSent(TeamLog.AccountCaptureNotificationEmailsSentType)
        /// (domains) Account-captured user changed account email to personal email
        case accountCaptureRelinquishAccount(TeamLog.AccountCaptureRelinquishAccountType)
        /// (domains) Disabled domain invites (deprecated, no longer logged)
        case disabledDomainInvites(TeamLog.DisabledDomainInvitesType)
        /// (domains) Approved user's request to join team
        case domainInvitesApproveRequestToJoinTeam(TeamLog.DomainInvitesApproveRequestToJoinTeamType)
        /// (domains) Declined user's request to join team
        case domainInvitesDeclineRequestToJoinTeam(TeamLog.DomainInvitesDeclineRequestToJoinTeamType)
        /// (domains) Sent domain invites to existing domain accounts (deprecated, no longer logged)
        case domainInvitesEmailExistingUsers(TeamLog.DomainInvitesEmailExistingUsersType)
        /// (domains) Requested to join team
        case domainInvitesRequestToJoinTeam(TeamLog.DomainInvitesRequestToJoinTeamType)
        /// (domains) Disabled "Automatically invite new users" (deprecated, no longer logged)
        case domainInvitesSetInviteNewUserPrefToNo(TeamLog.DomainInvitesSetInviteNewUserPrefToNoType)
        /// (domains) Enabled "Automatically invite new users" (deprecated, no longer logged)
        case domainInvitesSetInviteNewUserPrefToYes(TeamLog.DomainInvitesSetInviteNewUserPrefToYesType)
        /// (domains) Failed to verify team domain
        case domainVerificationAddDomainFail(TeamLog.DomainVerificationAddDomainFailType)
        /// (domains) Verified team domain
        case domainVerificationAddDomainSuccess(TeamLog.DomainVerificationAddDomainSuccessType)
        /// (domains) Removed domain from list of verified team domains
        case domainVerificationRemoveDomain(TeamLog.DomainVerificationRemoveDomainType)
        /// (domains) Enabled domain invites (deprecated, no longer logged)
        case enabledDomainInvites(TeamLog.EnabledDomainInvitesType)
        /// (file_operations) Created folders (deprecated, no longer logged)
        case createFolder(TeamLog.CreateFolderType)
        /// (file_operations) Added files and/or folders
        case fileAdd(TeamLog.FileAddType)
        /// (file_operations) Copied files and/or folders
        case fileCopy(TeamLog.FileCopyType)
        /// (file_operations) Deleted files and/or folders
        case fileDelete(TeamLog.FileDeleteType)
        /// (file_operations) Downloaded files and/or folders
        case fileDownload(TeamLog.FileDownloadType)
        /// (file_operations) Edited files
        case fileEdit(TeamLog.FileEditType)
        /// (file_operations) Created copy reference to file/folder
        case fileGetCopyReference(TeamLog.FileGetCopyReferenceType)
        /// (file_operations) Moved files and/or folders
        case fileMove(TeamLog.FileMoveType)
        /// (file_operations) Permanently deleted files and/or folders
        case filePermanentlyDelete(TeamLog.FilePermanentlyDeleteType)
        /// (file_operations) Previewed files and/or folders
        case filePreview(TeamLog.FilePreviewType)
        /// (file_operations) Renamed files and/or folders
        case fileRename(TeamLog.FileRenameType)
        /// (file_operations) Restored deleted files and/or folders
        case fileRestore(TeamLog.FileRestoreType)
        /// (file_operations) Reverted files to previous version
        case fileRevert(TeamLog.FileRevertType)
        /// (file_operations) Rolled back file actions
        case fileRollbackChanges(TeamLog.FileRollbackChangesType)
        /// (file_operations) Saved file/folder using copy reference
        case fileSaveCopyReference(TeamLog.FileSaveCopyReferenceType)
        /// (file_requests) Changed file request
        case fileRequestChange(TeamLog.FileRequestChangeType)
        /// (file_requests) Closed file request
        case fileRequestClose(TeamLog.FileRequestCloseType)
        /// (file_requests) Created file request
        case fileRequestCreate(TeamLog.FileRequestCreateType)
        /// (file_requests) Received files for file request
        case fileRequestReceiveFile(TeamLog.FileRequestReceiveFileType)
        /// (groups) Added external ID for group
        case groupAddExternalId(TeamLog.GroupAddExternalIdType)
        /// (groups) Added team members to group
        case groupAddMember(TeamLog.GroupAddMemberType)
        /// (groups) Changed external ID for group
        case groupChangeExternalId(TeamLog.GroupChangeExternalIdType)
        /// (groups) Changed group management type
        case groupChangeManagementType(TeamLog.GroupChangeManagementTypeType)
        /// (groups) Changed manager permissions of group member
        case groupChangeMemberRole(TeamLog.GroupChangeMemberRoleType)
        /// (groups) Created group
        case groupCreate(TeamLog.GroupCreateType)
        /// (groups) Deleted group
        case groupDelete(TeamLog.GroupDeleteType)
        /// (groups) Updated group (deprecated, no longer logged)
        case groupDescriptionUpdated(TeamLog.GroupDescriptionUpdatedType)
        /// (groups) Updated group join policy (deprecated, no longer logged)
        case groupJoinPolicyUpdated(TeamLog.GroupJoinPolicyUpdatedType)
        /// (groups) Moved group (deprecated, no longer logged)
        case groupMoved(TeamLog.GroupMovedType)
        /// (groups) Removed external ID for group
        case groupRemoveExternalId(TeamLog.GroupRemoveExternalIdType)
        /// (groups) Removed team members from group
        case groupRemoveMember(TeamLog.GroupRemoveMemberType)
        /// (groups) Renamed group
        case groupRename(TeamLog.GroupRenameType)
        /// (logins) Failed to sign in via EMM (deprecated, replaced by 'Failed to sign in')
        case emmError(TeamLog.EmmErrorType)
        /// (logins) Failed to sign in
        case loginFail(TeamLog.LoginFailType)
        /// (logins) Signed in
        case loginSuccess(TeamLog.LoginSuccessType)
        /// (logins) Signed out
        case logout(TeamLog.LogoutType)
        /// (logins) Ended reseller support session
        case resellerSupportSessionEnd(TeamLog.ResellerSupportSessionEndType)
        /// (logins) Started reseller support session
        case resellerSupportSessionStart(TeamLog.ResellerSupportSessionStartType)
        /// (logins) Ended admin sign-in-as session
        case signInAsSessionEnd(TeamLog.SignInAsSessionEndType)
        /// (logins) Started admin sign-in-as session
        case signInAsSessionStart(TeamLog.SignInAsSessionStartType)
        /// (logins) Failed to sign in via SSO (deprecated, replaced by 'Failed to sign in')
        case ssoError(TeamLog.SsoErrorType)
        /// (members) Added team member name
        case memberAddName(TeamLog.MemberAddNameType)
        /// (members) Changed team member admin role
        case memberChangeAdminRole(TeamLog.MemberChangeAdminRoleType)
        /// (members) Changed team member email
        case memberChangeEmail(TeamLog.MemberChangeEmailType)
        /// (members) Changed membership type (limited/full) of member (deprecated, no longer logged)
        case memberChangeMembershipType(TeamLog.MemberChangeMembershipTypeType)
        /// (members) Changed team member name
        case memberChangeName(TeamLog.MemberChangeNameType)
        /// (members) Changed member status (invited, joined, suspended, etc.)
        case memberChangeStatus(TeamLog.MemberChangeStatusType)
        /// (members) Cleared manually added contacts
        case memberDeleteManualContacts(TeamLog.MemberDeleteManualContactsType)
        /// (members) Permanently deleted contents of deleted team member account
        case memberPermanentlyDeleteAccountContents(TeamLog.MemberPermanentlyDeleteAccountContentsType)
        /// (members) Set custom member space limit
        case memberSpaceLimitsAddCustomQuota(TeamLog.MemberSpaceLimitsAddCustomQuotaType)
        /// (members) Changed custom member space limit
        case memberSpaceLimitsChangeCustomQuota(TeamLog.MemberSpaceLimitsChangeCustomQuotaType)
        /// (members) Changed space limit status
        case memberSpaceLimitsChangeStatus(TeamLog.MemberSpaceLimitsChangeStatusType)
        /// (members) Removed custom member space limit
        case memberSpaceLimitsRemoveCustomQuota(TeamLog.MemberSpaceLimitsRemoveCustomQuotaType)
        /// (members) Suggested person to add to team
        case memberSuggest(TeamLog.MemberSuggestType)
        /// (members) Transferred contents of deleted member account to another member
        case memberTransferAccountContents(TeamLog.MemberTransferAccountContentsType)
        /// (members) Secondary mails policy changed
        case secondaryMailsPolicyChanged(TeamLog.SecondaryMailsPolicyChangedType)
        /// (paper) Added team member to Paper doc/folder
        case paperContentAddMember(TeamLog.PaperContentAddMemberType)
        /// (paper) Added Paper doc/folder to folder
        case paperContentAddToFolder(TeamLog.PaperContentAddToFolderType)
        /// (paper) Archived Paper doc/folder
        case paperContentArchive(TeamLog.PaperContentArchiveType)
        /// (paper) Created Paper doc/folder
        case paperContentCreate(TeamLog.PaperContentCreateType)
        /// (paper) Permanently deleted Paper doc/folder
        case paperContentPermanentlyDelete(TeamLog.PaperContentPermanentlyDeleteType)
        /// (paper) Removed Paper doc/folder from folder
        case paperContentRemoveFromFolder(TeamLog.PaperContentRemoveFromFolderType)
        /// (paper) Removed team member from Paper doc/folder
        case paperContentRemoveMember(TeamLog.PaperContentRemoveMemberType)
        /// (paper) Renamed Paper doc/folder
        case paperContentRename(TeamLog.PaperContentRenameType)
        /// (paper) Restored archived Paper doc/folder
        case paperContentRestore(TeamLog.PaperContentRestoreType)
        /// (paper) Added Paper doc comment
        case paperDocAddComment(TeamLog.PaperDocAddCommentType)
        /// (paper) Changed team member permissions for Paper doc
        case paperDocChangeMemberRole(TeamLog.PaperDocChangeMemberRoleType)
        /// (paper) Changed sharing setting for Paper doc
        case paperDocChangeSharingPolicy(TeamLog.PaperDocChangeSharingPolicyType)
        /// (paper) Followed/unfollowed Paper doc
        case paperDocChangeSubscription(TeamLog.PaperDocChangeSubscriptionType)
        /// (paper) Archived Paper doc (deprecated, no longer logged)
        case paperDocDeleted(TeamLog.PaperDocDeletedType)
        /// (paper) Deleted Paper doc comment
        case paperDocDeleteComment(TeamLog.PaperDocDeleteCommentType)
        /// (paper) Downloaded Paper doc in specific format
        case paperDocDownload(TeamLog.PaperDocDownloadType)
        /// (paper) Edited Paper doc
        case paperDocEdit(TeamLog.PaperDocEditType)
        /// (paper) Edited Paper doc comment
        case paperDocEditComment(TeamLog.PaperDocEditCommentType)
        /// (paper) Followed Paper doc (deprecated, replaced by 'Followed/unfollowed Paper doc')
        case paperDocFollowed(TeamLog.PaperDocFollowedType)
        /// (paper) Mentioned team member in Paper doc
        case paperDocMention(TeamLog.PaperDocMentionType)
        /// (paper) Transferred ownership of Paper doc
        case paperDocOwnershipChanged(TeamLog.PaperDocOwnershipChangedType)
        /// (paper) Requested access to Paper doc
        case paperDocRequestAccess(TeamLog.PaperDocRequestAccessType)
        /// (paper) Resolved Paper doc comment
        case paperDocResolveComment(TeamLog.PaperDocResolveCommentType)
        /// (paper) Restored Paper doc to previous version
        case paperDocRevert(TeamLog.PaperDocRevertType)
        /// (paper) Shared Paper doc via Slack
        case paperDocSlackShare(TeamLog.PaperDocSlackShareType)
        /// (paper) Shared Paper doc with team member (deprecated, no longer logged)
        case paperDocTeamInvite(TeamLog.PaperDocTeamInviteType)
        /// (paper) Deleted Paper doc
        case paperDocTrashed(TeamLog.PaperDocTrashedType)
        /// (paper) Unresolved Paper doc comment
        case paperDocUnresolveComment(TeamLog.PaperDocUnresolveCommentType)
        /// (paper) Restored Paper doc
        case paperDocUntrashed(TeamLog.PaperDocUntrashedType)
        /// (paper) Viewed Paper doc
        case paperDocView(TeamLog.PaperDocViewType)
        /// (paper) Changed Paper external sharing setting to anyone (deprecated, no longer logged)
        case paperExternalViewAllow(TeamLog.PaperExternalViewAllowType)
        /// (paper) Changed Paper external sharing setting to default team (deprecated, no longer logged)
        case paperExternalViewDefaultTeam(TeamLog.PaperExternalViewDefaultTeamType)
        /// (paper) Changed Paper external sharing setting to team-only (deprecated, no longer logged)
        case paperExternalViewForbid(TeamLog.PaperExternalViewForbidType)
        /// (paper) Followed/unfollowed Paper folder
        case paperFolderChangeSubscription(TeamLog.PaperFolderChangeSubscriptionType)
        /// (paper) Archived Paper folder (deprecated, no longer logged)
        case paperFolderDeleted(TeamLog.PaperFolderDeletedType)
        /// (paper) Followed Paper folder (deprecated, replaced by 'Followed/unfollowed Paper folder')
        case paperFolderFollowed(TeamLog.PaperFolderFollowedType)
        /// (paper) Shared Paper folder with member (deprecated, no longer logged)
        case paperFolderTeamInvite(TeamLog.PaperFolderTeamInviteType)
        /// (passwords) Changed password
        case passwordChange(TeamLog.PasswordChangeType)
        /// (passwords) Reset password
        case passwordReset(TeamLog.PasswordResetType)
        /// (passwords) Reset all team member passwords
        case passwordResetAll(TeamLog.PasswordResetAllType)
        /// (reports) Created EMM-excluded users report
        case emmCreateExceptionsReport(TeamLog.EmmCreateExceptionsReportType)
        /// (reports) Created EMM mobile app usage report
        case emmCreateUsageReport(TeamLog.EmmCreateUsageReportType)
        /// (reports) Created member data report
        case exportMembersReport(TeamLog.ExportMembersReportType)
        /// (reports) Exported all team Paper docs
        case paperAdminExportStart(TeamLog.PaperAdminExportStartType)
        /// (reports) Created Smart Sync non-admin devices report
        case smartSyncCreateAdminPrivilegeReport(TeamLog.SmartSyncCreateAdminPrivilegeReportType)
        /// (reports) Created team activity report
        case teamActivityCreateReport(TeamLog.TeamActivityCreateReportType)
        /// (sharing) Shared album
        case collectionShare(TeamLog.CollectionShareType)
        /// (sharing) Changed Paper doc to invite-only (deprecated, no longer logged)
        case noteAclInviteOnly(TeamLog.NoteAclInviteOnlyType)
        /// (sharing) Changed Paper doc to link-accessible (deprecated, no longer logged)
        case noteAclLink(TeamLog.NoteAclLinkType)
        /// (sharing) Changed Paper doc to link-accessible for team (deprecated, no longer logged)
        case noteAclTeamLink(TeamLog.NoteAclTeamLinkType)
        /// (sharing) Shared Paper doc (deprecated, no longer logged)
        case noteShared(TeamLog.NoteSharedType)
        /// (sharing) Shared received Paper doc (deprecated, no longer logged)
        case noteShareReceive(TeamLog.NoteShareReceiveType)
        /// (sharing) Opened shared Paper doc (deprecated, no longer logged)
        case openNoteShared(TeamLog.OpenNoteSharedType)
        /// (sharing) Added team to shared folder (deprecated, no longer logged)
        case sfAddGroup(TeamLog.SfAddGroupType)
        /// (sharing) Allowed non-collaborators to view links to files in shared folder (deprecated, no longer logged)
        case sfAllowNonMembersToViewSharedLinks(TeamLog.SfAllowNonMembersToViewSharedLinksType)
        /// (sharing) Set team members to see warning before sharing folders outside team (deprecated, no longer logged)
        case sfExternalInviteWarn(TeamLog.SfExternalInviteWarnType)
        /// (sharing) Invited Facebook users to shared folder (deprecated, no longer logged)
        case sfFbInvite(TeamLog.SfFbInviteType)
        /// (sharing) Changed Facebook user's role in shared folder (deprecated, no longer logged)
        case sfFbInviteChangeRole(TeamLog.SfFbInviteChangeRoleType)
        /// (sharing) Uninvited Facebook user from shared folder (deprecated, no longer logged)
        case sfFbUninvite(TeamLog.SfFbUninviteType)
        /// (sharing) Invited group to shared folder (deprecated, no longer logged)
        case sfInviteGroup(TeamLog.SfInviteGroupType)
        /// (sharing) Granted access to shared folder (deprecated, no longer logged)
        case sfTeamGrantAccess(TeamLog.SfTeamGrantAccessType)
        /// (sharing) Invited team members to shared folder (deprecated, replaced by 'Invited user to Dropbox and added
        /// them to shared file/folder')
        case sfTeamInvite(TeamLog.SfTeamInviteType)
        /// (sharing) Changed team member's role in shared folder (deprecated, no longer logged)
        case sfTeamInviteChangeRole(TeamLog.SfTeamInviteChangeRoleType)
        /// (sharing) Joined team member's shared folder (deprecated, no longer logged)
        case sfTeamJoin(TeamLog.SfTeamJoinType)
        /// (sharing) Joined team member's shared folder from link (deprecated, no longer logged)
        case sfTeamJoinFromOobLink(TeamLog.SfTeamJoinFromOobLinkType)
        /// (sharing) Unshared folder with team member (deprecated, replaced by 'Removed invitee from shared file/folder
        /// before invite was accepted')
        case sfTeamUninvite(TeamLog.SfTeamUninviteType)
        /// (sharing) Invited user to Dropbox and added them to shared file/folder
        case sharedContentAddInvitees(TeamLog.SharedContentAddInviteesType)
        /// (sharing) Added expiration date to link for shared file/folder
        case sharedContentAddLinkExpiry(TeamLog.SharedContentAddLinkExpiryType)
        /// (sharing) Added password to link for shared file/folder
        case sharedContentAddLinkPassword(TeamLog.SharedContentAddLinkPasswordType)
        /// (sharing) Added users and/or groups to shared file/folder
        case sharedContentAddMember(TeamLog.SharedContentAddMemberType)
        /// (sharing) Changed whether members can download shared file/folder
        case sharedContentChangeDownloadsPolicy(TeamLog.SharedContentChangeDownloadsPolicyType)
        /// (sharing) Changed access type of invitee to shared file/folder before invite was accepted
        case sharedContentChangeInviteeRole(TeamLog.SharedContentChangeInviteeRoleType)
        /// (sharing) Changed link audience of shared file/folder
        case sharedContentChangeLinkAudience(TeamLog.SharedContentChangeLinkAudienceType)
        /// (sharing) Changed link expiration of shared file/folder
        case sharedContentChangeLinkExpiry(TeamLog.SharedContentChangeLinkExpiryType)
        /// (sharing) Changed link password of shared file/folder
        case sharedContentChangeLinkPassword(TeamLog.SharedContentChangeLinkPasswordType)
        /// (sharing) Changed access type of shared file/folder member
        case sharedContentChangeMemberRole(TeamLog.SharedContentChangeMemberRoleType)
        /// (sharing) Changed whether members can see who viewed shared file/folder
        case sharedContentChangeViewerInfoPolicy(TeamLog.SharedContentChangeViewerInfoPolicyType)
        /// (sharing) Acquired membership of shared file/folder by accepting invite
        case sharedContentClaimInvitation(TeamLog.SharedContentClaimInvitationType)
        /// (sharing) Copied shared file/folder to own Dropbox
        case sharedContentCopy(TeamLog.SharedContentCopyType)
        /// (sharing) Downloaded shared file/folder
        case sharedContentDownload(TeamLog.SharedContentDownloadType)
        /// (sharing) Left shared file/folder
        case sharedContentRelinquishMembership(TeamLog.SharedContentRelinquishMembershipType)
        /// (sharing) Removed invitee from shared file/folder before invite was accepted
        case sharedContentRemoveInvitees(TeamLog.SharedContentRemoveInviteesType)
        /// (sharing) Removed link expiration date of shared file/folder
        case sharedContentRemoveLinkExpiry(TeamLog.SharedContentRemoveLinkExpiryType)
        /// (sharing) Removed link password of shared file/folder
        case sharedContentRemoveLinkPassword(TeamLog.SharedContentRemoveLinkPasswordType)
        /// (sharing) Removed user/group from shared file/folder
        case sharedContentRemoveMember(TeamLog.SharedContentRemoveMemberType)
        /// (sharing) Requested access to shared file/folder
        case sharedContentRequestAccess(TeamLog.SharedContentRequestAccessType)
        /// (sharing) Unshared file/folder by clearing membership and turning off link
        case sharedContentUnshare(TeamLog.SharedContentUnshareType)
        /// (sharing) Previewed shared file/folder
        case sharedContentView(TeamLog.SharedContentViewType)
        /// (sharing) Changed who can access shared folder via link
        case sharedFolderChangeLinkPolicy(TeamLog.SharedFolderChangeLinkPolicyType)
        /// (sharing) Changed whether shared folder inherits members from parent folder
        case sharedFolderChangeMembersInheritancePolicy(TeamLog.SharedFolderChangeMembersInheritancePolicyType)
        /// (sharing) Changed who can add/remove members of shared folder
        case sharedFolderChangeMembersManagementPolicy(TeamLog.SharedFolderChangeMembersManagementPolicyType)
        /// (sharing) Changed who can become member of shared folder
        case sharedFolderChangeMembersPolicy(TeamLog.SharedFolderChangeMembersPolicyType)
        /// (sharing) Created shared folder
        case sharedFolderCreate(TeamLog.SharedFolderCreateType)
        /// (sharing) Declined team member's invite to shared folder
        case sharedFolderDeclineInvitation(TeamLog.SharedFolderDeclineInvitationType)
        /// (sharing) Added shared folder to own Dropbox
        case sharedFolderMount(TeamLog.SharedFolderMountType)
        /// (sharing) Changed parent of shared folder
        case sharedFolderNest(TeamLog.SharedFolderNestType)
        /// (sharing) Transferred ownership of shared folder to another member
        case sharedFolderTransferOwnership(TeamLog.SharedFolderTransferOwnershipType)
        /// (sharing) Deleted shared folder from Dropbox
        case sharedFolderUnmount(TeamLog.SharedFolderUnmountType)
        /// (sharing) Added shared link expiration date
        case sharedLinkAddExpiry(TeamLog.SharedLinkAddExpiryType)
        /// (sharing) Changed shared link expiration date
        case sharedLinkChangeExpiry(TeamLog.SharedLinkChangeExpiryType)
        /// (sharing) Changed visibility of shared link
        case sharedLinkChangeVisibility(TeamLog.SharedLinkChangeVisibilityType)
        /// (sharing) Added file/folder to Dropbox from shared link
        case sharedLinkCopy(TeamLog.SharedLinkCopyType)
        /// (sharing) Created shared link
        case sharedLinkCreate(TeamLog.SharedLinkCreateType)
        /// (sharing) Removed shared link
        case sharedLinkDisable(TeamLog.SharedLinkDisableType)
        /// (sharing) Downloaded file/folder from shared link
        case sharedLinkDownload(TeamLog.SharedLinkDownloadType)
        /// (sharing) Removed shared link expiration date
        case sharedLinkRemoveExpiry(TeamLog.SharedLinkRemoveExpiryType)
        /// (sharing) Added members as audience of shared link
        case sharedLinkShare(TeamLog.SharedLinkShareType)
        /// (sharing) Opened shared link
        case sharedLinkView(TeamLog.SharedLinkViewType)
        /// (sharing) Opened shared Paper doc (deprecated, no longer logged)
        case sharedNoteOpened(TeamLog.SharedNoteOpenedType)
        /// (sharing) Shared link with group (deprecated, no longer logged)
        case shmodelGroupShare(TeamLog.ShmodelGroupShareType)
        /// (showcase) Granted access to showcase
        case showcaseAccessGranted(TeamLog.ShowcaseAccessGrantedType)
        /// (showcase) Added member to showcase
        case showcaseAddMember(TeamLog.ShowcaseAddMemberType)
        /// (showcase) Archived showcase
        case showcaseArchived(TeamLog.ShowcaseArchivedType)
        /// (showcase) Created showcase
        case showcaseCreated(TeamLog.ShowcaseCreatedType)
        /// (showcase) Deleted showcase comment
        case showcaseDeleteComment(TeamLog.ShowcaseDeleteCommentType)
        /// (showcase) Edited showcase
        case showcaseEdited(TeamLog.ShowcaseEditedType)
        /// (showcase) Edited showcase comment
        case showcaseEditComment(TeamLog.ShowcaseEditCommentType)
        /// (showcase) Added file to showcase
        case showcaseFileAdded(TeamLog.ShowcaseFileAddedType)
        /// (showcase) Downloaded file from showcase
        case showcaseFileDownload(TeamLog.ShowcaseFileDownloadType)
        /// (showcase) Removed file from showcase
        case showcaseFileRemoved(TeamLog.ShowcaseFileRemovedType)
        /// (showcase) Viewed file in showcase
        case showcaseFileView(TeamLog.ShowcaseFileViewType)
        /// (showcase) Permanently deleted showcase
        case showcasePermanentlyDeleted(TeamLog.ShowcasePermanentlyDeletedType)
        /// (showcase) Added showcase comment
        case showcasePostComment(TeamLog.ShowcasePostCommentType)
        /// (showcase) Removed member from showcase
        case showcaseRemoveMember(TeamLog.ShowcaseRemoveMemberType)
        /// (showcase) Renamed showcase
        case showcaseRenamed(TeamLog.ShowcaseRenamedType)
        /// (showcase) Requested access to showcase
        case showcaseRequestAccess(TeamLog.ShowcaseRequestAccessType)
        /// (showcase) Resolved showcase comment
        case showcaseResolveComment(TeamLog.ShowcaseResolveCommentType)
        /// (showcase) Unarchived showcase
        case showcaseRestored(TeamLog.ShowcaseRestoredType)
        /// (showcase) Deleted showcase
        case showcaseTrashed(TeamLog.ShowcaseTrashedType)
        /// (showcase) Deleted showcase (old version) (deprecated, replaced by 'Deleted showcase')
        case showcaseTrashedDeprecated(TeamLog.ShowcaseTrashedDeprecatedType)
        /// (showcase) Unresolved showcase comment
        case showcaseUnresolveComment(TeamLog.ShowcaseUnresolveCommentType)
        /// (showcase) Restored showcase
        case showcaseUntrashed(TeamLog.ShowcaseUntrashedType)
        /// (showcase) Restored showcase (old version) (deprecated, replaced by 'Restored showcase')
        case showcaseUntrashedDeprecated(TeamLog.ShowcaseUntrashedDeprecatedType)
        /// (showcase) Viewed showcase
        case showcaseView(TeamLog.ShowcaseViewType)
        /// (sso) Added X.509 certificate for SSO
        case ssoAddCert(TeamLog.SsoAddCertType)
        /// (sso) Added sign-in URL for SSO
        case ssoAddLoginUrl(TeamLog.SsoAddLoginUrlType)
        /// (sso) Added sign-out URL for SSO
        case ssoAddLogoutUrl(TeamLog.SsoAddLogoutUrlType)
        /// (sso) Changed X.509 certificate for SSO
        case ssoChangeCert(TeamLog.SsoChangeCertType)
        /// (sso) Changed sign-in URL for SSO
        case ssoChangeLoginUrl(TeamLog.SsoChangeLoginUrlType)
        /// (sso) Changed sign-out URL for SSO
        case ssoChangeLogoutUrl(TeamLog.SsoChangeLogoutUrlType)
        /// (sso) Changed SAML identity mode for SSO
        case ssoChangeSamlIdentityMode(TeamLog.SsoChangeSamlIdentityModeType)
        /// (sso) Removed X.509 certificate for SSO
        case ssoRemoveCert(TeamLog.SsoRemoveCertType)
        /// (sso) Removed sign-in URL for SSO
        case ssoRemoveLoginUrl(TeamLog.SsoRemoveLoginUrlType)
        /// (sso) Removed sign-out URL for SSO
        case ssoRemoveLogoutUrl(TeamLog.SsoRemoveLogoutUrlType)
        /// (team_folders) Changed archival status of team folder
        case teamFolderChangeStatus(TeamLog.TeamFolderChangeStatusType)
        /// (team_folders) Created team folder in active status
        case teamFolderCreate(TeamLog.TeamFolderCreateType)
        /// (team_folders) Downgraded team folder to regular shared folder
        case teamFolderDowngrade(TeamLog.TeamFolderDowngradeType)
        /// (team_folders) Permanently deleted archived team folder
        case teamFolderPermanentlyDelete(TeamLog.TeamFolderPermanentlyDeleteType)
        /// (team_folders) Renamed active/archived team folder
        case teamFolderRename(TeamLog.TeamFolderRenameType)
        /// (team_folders) Changed sync default
        case teamSelectiveSyncSettingsChanged(TeamLog.TeamSelectiveSyncSettingsChangedType)
        /// (team_policies) Changed account capture setting on team domain
        case accountCaptureChangePolicy(TeamLog.AccountCaptureChangePolicyType)
        /// (team_policies) Disabled downloads (deprecated, no longer logged)
        case allowDownloadDisabled(TeamLog.AllowDownloadDisabledType)
        /// (team_policies) Enabled downloads (deprecated, no longer logged)
        case allowDownloadEnabled(TeamLog.AllowDownloadEnabledType)
        /// (team_policies) Changed camera uploads setting for team
        case cameraUploadsPolicyChanged(TeamLog.CameraUploadsPolicyChangedType)
        /// (team_policies) Set restrictions on data center locations where team data resides
        case dataPlacementRestrictionChangePolicy(TeamLog.DataPlacementRestrictionChangePolicyType)
        /// (team_policies) Completed restrictions on data center locations where team data resides
        case dataPlacementRestrictionSatisfyPolicy(TeamLog.DataPlacementRestrictionSatisfyPolicyType)
        /// (team_policies) Set/removed limit on number of computers member can link to team Dropbox account
        case deviceApprovalsChangeDesktopPolicy(TeamLog.DeviceApprovalsChangeDesktopPolicyType)
        /// (team_policies) Set/removed limit on number of mobile devices member can link to team Dropbox account
        case deviceApprovalsChangeMobilePolicy(TeamLog.DeviceApprovalsChangeMobilePolicyType)
        /// (team_policies) Changed device approvals setting when member is over limit
        case deviceApprovalsChangeOverageAction(TeamLog.DeviceApprovalsChangeOverageActionType)
        /// (team_policies) Changed device approvals setting when member unlinks approved device
        case deviceApprovalsChangeUnlinkAction(TeamLog.DeviceApprovalsChangeUnlinkActionType)
        /// (team_policies) Added members to directory restrictions list
        case directoryRestrictionsAddMembers(TeamLog.DirectoryRestrictionsAddMembersType)
        /// (team_policies) Removed members from directory restrictions list
        case directoryRestrictionsRemoveMembers(TeamLog.DirectoryRestrictionsRemoveMembersType)
        /// (team_policies) Added members to EMM exception list
        case emmAddException(TeamLog.EmmAddExceptionType)
        /// (team_policies) Enabled/disabled enterprise mobility management for members
        case emmChangePolicy(TeamLog.EmmChangePolicyType)
        /// (team_policies) Removed members from EMM exception list
        case emmRemoveException(TeamLog.EmmRemoveExceptionType)
        /// (team_policies) Accepted/opted out of extended version history
        case extendedVersionHistoryChangePolicy(TeamLog.ExtendedVersionHistoryChangePolicyType)
        /// (team_policies) Enabled/disabled commenting on team files
        case fileCommentsChangePolicy(TeamLog.FileCommentsChangePolicyType)
        /// (team_policies) Enabled/disabled file requests
        case fileRequestsChangePolicy(TeamLog.FileRequestsChangePolicyType)
        /// (team_policies) Enabled file request emails for everyone (deprecated, no longer logged)
        case fileRequestsEmailsEnabled(TeamLog.FileRequestsEmailsEnabledType)
        /// (team_policies) Enabled file request emails for team (deprecated, no longer logged)
        case fileRequestsEmailsRestrictedToTeamOnly(TeamLog.FileRequestsEmailsRestrictedToTeamOnlyType)
        /// (team_policies) Enabled/disabled Google single sign-on for team
        case googleSsoChangePolicy(TeamLog.GoogleSsoChangePolicyType)
        /// (team_policies) Changed who can create groups
        case groupUserManagementChangePolicy(TeamLog.GroupUserManagementChangePolicyType)
        /// (team_policies) Changed whether users can find team when not invited
        case memberRequestsChangePolicy(TeamLog.MemberRequestsChangePolicyType)
        /// (team_policies) Added members to member space limit exception list
        case memberSpaceLimitsAddException(TeamLog.MemberSpaceLimitsAddExceptionType)
        /// (team_policies) Changed member space limit type for team
        case memberSpaceLimitsChangeCapsTypePolicy(TeamLog.MemberSpaceLimitsChangeCapsTypePolicyType)
        /// (team_policies) Changed team default member space limit
        case memberSpaceLimitsChangePolicy(TeamLog.MemberSpaceLimitsChangePolicyType)
        /// (team_policies) Removed members from member space limit exception list
        case memberSpaceLimitsRemoveException(TeamLog.MemberSpaceLimitsRemoveExceptionType)
        /// (team_policies) Enabled/disabled option for team members to suggest people to add to team
        case memberSuggestionsChangePolicy(TeamLog.MemberSuggestionsChangePolicyType)
        /// (team_policies) Enabled/disabled Microsoft Office add-in
        case microsoftOfficeAddinChangePolicy(TeamLog.MicrosoftOfficeAddinChangePolicyType)
        /// (team_policies) Enabled/disabled network control
        case networkControlChangePolicy(TeamLog.NetworkControlChangePolicyType)
        /// (team_policies) Changed whether Dropbox Paper, when enabled, is deployed to all members or to specific
        /// members
        case paperChangeDeploymentPolicy(TeamLog.PaperChangeDeploymentPolicyType)
        /// (team_policies) Changed whether non-members can view Paper docs with link (deprecated, no longer logged)
        case paperChangeMemberLinkPolicy(TeamLog.PaperChangeMemberLinkPolicyType)
        /// (team_policies) Changed whether members can share Paper docs outside team, and if docs are accessible only
        /// by team members or anyone by default
        case paperChangeMemberPolicy(TeamLog.PaperChangeMemberPolicyType)
        /// (team_policies) Enabled/disabled Dropbox Paper for team
        case paperChangePolicy(TeamLog.PaperChangePolicyType)
        /// (team_policies) Added users to Paper-enabled users list
        case paperEnabledUsersGroupAddition(TeamLog.PaperEnabledUsersGroupAdditionType)
        /// (team_policies) Removed users from Paper-enabled users list
        case paperEnabledUsersGroupRemoval(TeamLog.PaperEnabledUsersGroupRemovalType)
        /// (team_policies) Enabled/disabled ability of team members to permanently delete content
        case permanentDeleteChangePolicy(TeamLog.PermanentDeleteChangePolicyType)
        /// (team_policies) Changed whether team members can join shared folders owned outside team
        case sharingChangeFolderJoinPolicy(TeamLog.SharingChangeFolderJoinPolicyType)
        /// (team_policies) Changed whether members can share links outside team, and if links are accessible only by
        /// team members or anyone by default
        case sharingChangeLinkPolicy(TeamLog.SharingChangeLinkPolicyType)
        /// (team_policies) Changed whether members can share files/folders outside team
        case sharingChangeMemberPolicy(TeamLog.SharingChangeMemberPolicyType)
        /// (team_policies) Enabled/disabled downloading files from Dropbox Showcase for team
        case showcaseChangeDownloadPolicy(TeamLog.ShowcaseChangeDownloadPolicyType)
        /// (team_policies) Enabled/disabled Dropbox Showcase for team
        case showcaseChangeEnabledPolicy(TeamLog.ShowcaseChangeEnabledPolicyType)
        /// (team_policies) Enabled/disabled sharing Dropbox Showcase externally for team
        case showcaseChangeExternalSharingPolicy(TeamLog.ShowcaseChangeExternalSharingPolicyType)
        /// (team_policies) Changed default Smart Sync setting for team members
        case smartSyncChangePolicy(TeamLog.SmartSyncChangePolicyType)
        /// (team_policies) Opted team into Smart Sync
        case smartSyncNotOptOut(TeamLog.SmartSyncNotOptOutType)
        /// (team_policies) Opted team out of Smart Sync
        case smartSyncOptOut(TeamLog.SmartSyncOptOutType)
        /// (team_policies) Changed single sign-on setting for team
        case ssoChangePolicy(TeamLog.SsoChangePolicyType)
        /// (team_policies) Enabled/disabled Team Selective Sync for team
        case teamSelectiveSyncPolicyChanged(TeamLog.TeamSelectiveSyncPolicyChangedType)
        /// (team_policies) Changed two-step verification setting for team
        case tfaChangePolicy(TeamLog.TfaChangePolicyType)
        /// (team_policies) Enabled/disabled option for members to link personal Dropbox account and team account to
        /// same computer
        case twoAccountChangePolicy(TeamLog.TwoAccountChangePolicyType)
        /// (team_policies) Changed team policy for viewer info
        case viewerInfoPolicyChanged(TeamLog.ViewerInfoPolicyChangedType)
        /// (team_policies) Changed how long members can stay signed in to Dropbox.com
        case webSessionsChangeFixedLengthPolicy(TeamLog.WebSessionsChangeFixedLengthPolicyType)
        /// (team_policies) Changed how long team members can be idle while signed in to Dropbox.com
        case webSessionsChangeIdleLengthPolicy(TeamLog.WebSessionsChangeIdleLengthPolicyType)
        /// (team_profile) Merged another team into this team
        case teamMergeFrom(TeamLog.TeamMergeFromType)
        /// (team_profile) Merged this team into another team
        case teamMergeTo(TeamLog.TeamMergeToType)
        /// (team_profile) Added team logo to display on shared link headers
        case teamProfileAddLogo(TeamLog.TeamProfileAddLogoType)
        /// (team_profile) Changed default language for team
        case teamProfileChangeDefaultLanguage(TeamLog.TeamProfileChangeDefaultLanguageType)
        /// (team_profile) Changed team logo displayed on shared link headers
        case teamProfileChangeLogo(TeamLog.TeamProfileChangeLogoType)
        /// (team_profile) Changed team name
        case teamProfileChangeName(TeamLog.TeamProfileChangeNameType)
        /// (team_profile) Removed team logo displayed on shared link headers
        case teamProfileRemoveLogo(TeamLog.TeamProfileRemoveLogoType)
        /// (tfa) Added backup phone for two-step verification
        case tfaAddBackupPhone(TeamLog.TfaAddBackupPhoneType)
        /// (tfa) Added security key for two-step verification
        case tfaAddSecurityKey(TeamLog.TfaAddSecurityKeyType)
        /// (tfa) Changed backup phone for two-step verification
        case tfaChangeBackupPhone(TeamLog.TfaChangeBackupPhoneType)
        /// (tfa) Enabled/disabled/changed two-step verification setting
        case tfaChangeStatus(TeamLog.TfaChangeStatusType)
        /// (tfa) Removed backup phone for two-step verification
        case tfaRemoveBackupPhone(TeamLog.TfaRemoveBackupPhoneType)
        /// (tfa) Removed security key for two-step verification
        case tfaRemoveSecurityKey(TeamLog.TfaRemoveSecurityKeyType)
        /// (tfa) Reset two-step verification for team member
        case tfaReset(TeamLog.TfaResetType)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(EventTypeSerializer().serialize(self)))"
        }
    }
    open class EventTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: EventType) -> JSON {
            switch value {
                case .appLinkTeam(let arg):
                    var d = Serialization.getFields(TeamLog.AppLinkTeamTypeSerializer().serialize(arg))
                    d[".tag"] = .str("app_link_team")
                    return .dictionary(d)
                case .appLinkUser(let arg):
                    var d = Serialization.getFields(TeamLog.AppLinkUserTypeSerializer().serialize(arg))
                    d[".tag"] = .str("app_link_user")
                    return .dictionary(d)
                case .appUnlinkTeam(let arg):
                    var d = Serialization.getFields(TeamLog.AppUnlinkTeamTypeSerializer().serialize(arg))
                    d[".tag"] = .str("app_unlink_team")
                    return .dictionary(d)
                case .appUnlinkUser(let arg):
                    var d = Serialization.getFields(TeamLog.AppUnlinkUserTypeSerializer().serialize(arg))
                    d[".tag"] = .str("app_unlink_user")
                    return .dictionary(d)
                case .fileAddComment(let arg):
                    var d = Serialization.getFields(TeamLog.FileAddCommentTypeSerializer().serialize(arg))
                    d[".tag"] = .str("file_add_comment")
                    return .dictionary(d)
                case .fileChangeCommentSubscription(let arg):
                    var d = Serialization.getFields(TeamLog.FileChangeCommentSubscriptionTypeSerializer().serialize(arg))
                    d[".tag"] = .str("file_change_comment_subscription")
                    return .dictionary(d)
                case .fileDeleteComment(let arg):
                    var d = Serialization.getFields(TeamLog.FileDeleteCommentTypeSerializer().serialize(arg))
                    d[".tag"] = .str("file_delete_comment")
                    return .dictionary(d)
                case .fileEditComment(let arg):
                    var d = Serialization.getFields(TeamLog.FileEditCommentTypeSerializer().serialize(arg))
                    d[".tag"] = .str("file_edit_comment")
                    return .dictionary(d)
                case .fileLikeComment(let arg):
                    var d = Serialization.getFields(TeamLog.FileLikeCommentTypeSerializer().serialize(arg))
                    d[".tag"] = .str("file_like_comment")
                    return .dictionary(d)
                case .fileResolveComment(let arg):
                    var d = Serialization.getFields(TeamLog.FileResolveCommentTypeSerializer().serialize(arg))
                    d[".tag"] = .str("file_resolve_comment")
                    return .dictionary(d)
                case .fileUnlikeComment(let arg):
                    var d = Serialization.getFields(TeamLog.FileUnlikeCommentTypeSerializer().serialize(arg))
                    d[".tag"] = .str("file_unlike_comment")
                    return .dictionary(d)
                case .fileUnresolveComment(let arg):
                    var d = Serialization.getFields(TeamLog.FileUnresolveCommentTypeSerializer().serialize(arg))
                    d[".tag"] = .str("file_unresolve_comment")
                    return .dictionary(d)
                case .deviceChangeIpDesktop(let arg):
                    var d = Serialization.getFields(TeamLog.DeviceChangeIpDesktopTypeSerializer().serialize(arg))
                    d[".tag"] = .str("device_change_ip_desktop")
                    return .dictionary(d)
                case .deviceChangeIpMobile(let arg):
                    var d = Serialization.getFields(TeamLog.DeviceChangeIpMobileTypeSerializer().serialize(arg))
                    d[".tag"] = .str("device_change_ip_mobile")
                    return .dictionary(d)
                case .deviceChangeIpWeb(let arg):
                    var d = Serialization.getFields(TeamLog.DeviceChangeIpWebTypeSerializer().serialize(arg))
                    d[".tag"] = .str("device_change_ip_web")
                    return .dictionary(d)
                case .deviceDeleteOnUnlinkFail(let arg):
                    var d = Serialization.getFields(TeamLog.DeviceDeleteOnUnlinkFailTypeSerializer().serialize(arg))
                    d[".tag"] = .str("device_delete_on_unlink_fail")
                    return .dictionary(d)
                case .deviceDeleteOnUnlinkSuccess(let arg):
                    var d = Serialization.getFields(TeamLog.DeviceDeleteOnUnlinkSuccessTypeSerializer().serialize(arg))
                    d[".tag"] = .str("device_delete_on_unlink_success")
                    return .dictionary(d)
                case .deviceLinkFail(let arg):
                    var d = Serialization.getFields(TeamLog.DeviceLinkFailTypeSerializer().serialize(arg))
                    d[".tag"] = .str("device_link_fail")
                    return .dictionary(d)
                case .deviceLinkSuccess(let arg):
                    var d = Serialization.getFields(TeamLog.DeviceLinkSuccessTypeSerializer().serialize(arg))
                    d[".tag"] = .str("device_link_success")
                    return .dictionary(d)
                case .deviceManagementDisabled(let arg):
                    var d = Serialization.getFields(TeamLog.DeviceManagementDisabledTypeSerializer().serialize(arg))
                    d[".tag"] = .str("device_management_disabled")
                    return .dictionary(d)
                case .deviceManagementEnabled(let arg):
                    var d = Serialization.getFields(TeamLog.DeviceManagementEnabledTypeSerializer().serialize(arg))
                    d[".tag"] = .str("device_management_enabled")
                    return .dictionary(d)
                case .deviceUnlink(let arg):
                    var d = Serialization.getFields(TeamLog.DeviceUnlinkTypeSerializer().serialize(arg))
                    d[".tag"] = .str("device_unlink")
                    return .dictionary(d)
                case .emmRefreshAuthToken(let arg):
                    var d = Serialization.getFields(TeamLog.EmmRefreshAuthTokenTypeSerializer().serialize(arg))
                    d[".tag"] = .str("emm_refresh_auth_token")
                    return .dictionary(d)
                case .accountCaptureChangeAvailability(let arg):
                    var d = Serialization.getFields(TeamLog.AccountCaptureChangeAvailabilityTypeSerializer().serialize(arg))
                    d[".tag"] = .str("account_capture_change_availability")
                    return .dictionary(d)
                case .accountCaptureMigrateAccount(let arg):
                    var d = Serialization.getFields(TeamLog.AccountCaptureMigrateAccountTypeSerializer().serialize(arg))
                    d[".tag"] = .str("account_capture_migrate_account")
                    return .dictionary(d)
                case .accountCaptureNotificationEmailsSent(let arg):
                    var d = Serialization.getFields(TeamLog.AccountCaptureNotificationEmailsSentTypeSerializer().serialize(arg))
                    d[".tag"] = .str("account_capture_notification_emails_sent")
                    return .dictionary(d)
                case .accountCaptureRelinquishAccount(let arg):
                    var d = Serialization.getFields(TeamLog.AccountCaptureRelinquishAccountTypeSerializer().serialize(arg))
                    d[".tag"] = .str("account_capture_relinquish_account")
                    return .dictionary(d)
                case .disabledDomainInvites(let arg):
                    var d = Serialization.getFields(TeamLog.DisabledDomainInvitesTypeSerializer().serialize(arg))
                    d[".tag"] = .str("disabled_domain_invites")
                    return .dictionary(d)
                case .domainInvitesApproveRequestToJoinTeam(let arg):
                    var d = Serialization.getFields(TeamLog.DomainInvitesApproveRequestToJoinTeamTypeSerializer().serialize(arg))
                    d[".tag"] = .str("domain_invites_approve_request_to_join_team")
                    return .dictionary(d)
                case .domainInvitesDeclineRequestToJoinTeam(let arg):
                    var d = Serialization.getFields(TeamLog.DomainInvitesDeclineRequestToJoinTeamTypeSerializer().serialize(arg))
                    d[".tag"] = .str("domain_invites_decline_request_to_join_team")
                    return .dictionary(d)
                case .domainInvitesEmailExistingUsers(let arg):
                    var d = Serialization.getFields(TeamLog.DomainInvitesEmailExistingUsersTypeSerializer().serialize(arg))
                    d[".tag"] = .str("domain_invites_email_existing_users")
                    return .dictionary(d)
                case .domainInvitesRequestToJoinTeam(let arg):
                    var d = Serialization.getFields(TeamLog.DomainInvitesRequestToJoinTeamTypeSerializer().serialize(arg))
                    d[".tag"] = .str("domain_invites_request_to_join_team")
                    return .dictionary(d)
                case .domainInvitesSetInviteNewUserPrefToNo(let arg):
                    var d = Serialization.getFields(TeamLog.DomainInvitesSetInviteNewUserPrefToNoTypeSerializer().serialize(arg))
                    d[".tag"] = .str("domain_invites_set_invite_new_user_pref_to_no")
                    return .dictionary(d)
                case .domainInvitesSetInviteNewUserPrefToYes(let arg):
                    var d = Serialization.getFields(TeamLog.DomainInvitesSetInviteNewUserPrefToYesTypeSerializer().serialize(arg))
                    d[".tag"] = .str("domain_invites_set_invite_new_user_pref_to_yes")
                    return .dictionary(d)
                case .domainVerificationAddDomainFail(let arg):
                    var d = Serialization.getFields(TeamLog.DomainVerificationAddDomainFailTypeSerializer().serialize(arg))
                    d[".tag"] = .str("domain_verification_add_domain_fail")
                    return .dictionary(d)
                case .domainVerificationAddDomainSuccess(let arg):
                    var d = Serialization.getFields(TeamLog.DomainVerificationAddDomainSuccessTypeSerializer().serialize(arg))
                    d[".tag"] = .str("domain_verification_add_domain_success")
                    return .dictionary(d)
                case .domainVerificationRemoveDomain(let arg):
                    var d = Serialization.getFields(TeamLog.DomainVerificationRemoveDomainTypeSerializer().serialize(arg))
                    d[".tag"] = .str("domain_verification_remove_domain")
                    return .dictionary(d)
                case .enabledDomainInvites(let arg):
                    var d = Serialization.getFields(TeamLog.EnabledDomainInvitesTypeSerializer().serialize(arg))
                    d[".tag"] = .str("enabled_domain_invites")
                    return .dictionary(d)
                case .createFolder(let arg):
                    var d = Serialization.getFields(TeamLog.CreateFolderTypeSerializer().serialize(arg))
                    d[".tag"] = .str("create_folder")
                    return .dictionary(d)
                case .fileAdd(let arg):
                    var d = Serialization.getFields(TeamLog.FileAddTypeSerializer().serialize(arg))
                    d[".tag"] = .str("file_add")
                    return .dictionary(d)
                case .fileCopy(let arg):
                    var d = Serialization.getFields(TeamLog.FileCopyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("file_copy")
                    return .dictionary(d)
                case .fileDelete(let arg):
                    var d = Serialization.getFields(TeamLog.FileDeleteTypeSerializer().serialize(arg))
                    d[".tag"] = .str("file_delete")
                    return .dictionary(d)
                case .fileDownload(let arg):
                    var d = Serialization.getFields(TeamLog.FileDownloadTypeSerializer().serialize(arg))
                    d[".tag"] = .str("file_download")
                    return .dictionary(d)
                case .fileEdit(let arg):
                    var d = Serialization.getFields(TeamLog.FileEditTypeSerializer().serialize(arg))
                    d[".tag"] = .str("file_edit")
                    return .dictionary(d)
                case .fileGetCopyReference(let arg):
                    var d = Serialization.getFields(TeamLog.FileGetCopyReferenceTypeSerializer().serialize(arg))
                    d[".tag"] = .str("file_get_copy_reference")
                    return .dictionary(d)
                case .fileMove(let arg):
                    var d = Serialization.getFields(TeamLog.FileMoveTypeSerializer().serialize(arg))
                    d[".tag"] = .str("file_move")
                    return .dictionary(d)
                case .filePermanentlyDelete(let arg):
                    var d = Serialization.getFields(TeamLog.FilePermanentlyDeleteTypeSerializer().serialize(arg))
                    d[".tag"] = .str("file_permanently_delete")
                    return .dictionary(d)
                case .filePreview(let arg):
                    var d = Serialization.getFields(TeamLog.FilePreviewTypeSerializer().serialize(arg))
                    d[".tag"] = .str("file_preview")
                    return .dictionary(d)
                case .fileRename(let arg):
                    var d = Serialization.getFields(TeamLog.FileRenameTypeSerializer().serialize(arg))
                    d[".tag"] = .str("file_rename")
                    return .dictionary(d)
                case .fileRestore(let arg):
                    var d = Serialization.getFields(TeamLog.FileRestoreTypeSerializer().serialize(arg))
                    d[".tag"] = .str("file_restore")
                    return .dictionary(d)
                case .fileRevert(let arg):
                    var d = Serialization.getFields(TeamLog.FileRevertTypeSerializer().serialize(arg))
                    d[".tag"] = .str("file_revert")
                    return .dictionary(d)
                case .fileRollbackChanges(let arg):
                    var d = Serialization.getFields(TeamLog.FileRollbackChangesTypeSerializer().serialize(arg))
                    d[".tag"] = .str("file_rollback_changes")
                    return .dictionary(d)
                case .fileSaveCopyReference(let arg):
                    var d = Serialization.getFields(TeamLog.FileSaveCopyReferenceTypeSerializer().serialize(arg))
                    d[".tag"] = .str("file_save_copy_reference")
                    return .dictionary(d)
                case .fileRequestChange(let arg):
                    var d = Serialization.getFields(TeamLog.FileRequestChangeTypeSerializer().serialize(arg))
                    d[".tag"] = .str("file_request_change")
                    return .dictionary(d)
                case .fileRequestClose(let arg):
                    var d = Serialization.getFields(TeamLog.FileRequestCloseTypeSerializer().serialize(arg))
                    d[".tag"] = .str("file_request_close")
                    return .dictionary(d)
                case .fileRequestCreate(let arg):
                    var d = Serialization.getFields(TeamLog.FileRequestCreateTypeSerializer().serialize(arg))
                    d[".tag"] = .str("file_request_create")
                    return .dictionary(d)
                case .fileRequestReceiveFile(let arg):
                    var d = Serialization.getFields(TeamLog.FileRequestReceiveFileTypeSerializer().serialize(arg))
                    d[".tag"] = .str("file_request_receive_file")
                    return .dictionary(d)
                case .groupAddExternalId(let arg):
                    var d = Serialization.getFields(TeamLog.GroupAddExternalIdTypeSerializer().serialize(arg))
                    d[".tag"] = .str("group_add_external_id")
                    return .dictionary(d)
                case .groupAddMember(let arg):
                    var d = Serialization.getFields(TeamLog.GroupAddMemberTypeSerializer().serialize(arg))
                    d[".tag"] = .str("group_add_member")
                    return .dictionary(d)
                case .groupChangeExternalId(let arg):
                    var d = Serialization.getFields(TeamLog.GroupChangeExternalIdTypeSerializer().serialize(arg))
                    d[".tag"] = .str("group_change_external_id")
                    return .dictionary(d)
                case .groupChangeManagementType(let arg):
                    var d = Serialization.getFields(TeamLog.GroupChangeManagementTypeTypeSerializer().serialize(arg))
                    d[".tag"] = .str("group_change_management_type")
                    return .dictionary(d)
                case .groupChangeMemberRole(let arg):
                    var d = Serialization.getFields(TeamLog.GroupChangeMemberRoleTypeSerializer().serialize(arg))
                    d[".tag"] = .str("group_change_member_role")
                    return .dictionary(d)
                case .groupCreate(let arg):
                    var d = Serialization.getFields(TeamLog.GroupCreateTypeSerializer().serialize(arg))
                    d[".tag"] = .str("group_create")
                    return .dictionary(d)
                case .groupDelete(let arg):
                    var d = Serialization.getFields(TeamLog.GroupDeleteTypeSerializer().serialize(arg))
                    d[".tag"] = .str("group_delete")
                    return .dictionary(d)
                case .groupDescriptionUpdated(let arg):
                    var d = Serialization.getFields(TeamLog.GroupDescriptionUpdatedTypeSerializer().serialize(arg))
                    d[".tag"] = .str("group_description_updated")
                    return .dictionary(d)
                case .groupJoinPolicyUpdated(let arg):
                    var d = Serialization.getFields(TeamLog.GroupJoinPolicyUpdatedTypeSerializer().serialize(arg))
                    d[".tag"] = .str("group_join_policy_updated")
                    return .dictionary(d)
                case .groupMoved(let arg):
                    var d = Serialization.getFields(TeamLog.GroupMovedTypeSerializer().serialize(arg))
                    d[".tag"] = .str("group_moved")
                    return .dictionary(d)
                case .groupRemoveExternalId(let arg):
                    var d = Serialization.getFields(TeamLog.GroupRemoveExternalIdTypeSerializer().serialize(arg))
                    d[".tag"] = .str("group_remove_external_id")
                    return .dictionary(d)
                case .groupRemoveMember(let arg):
                    var d = Serialization.getFields(TeamLog.GroupRemoveMemberTypeSerializer().serialize(arg))
                    d[".tag"] = .str("group_remove_member")
                    return .dictionary(d)
                case .groupRename(let arg):
                    var d = Serialization.getFields(TeamLog.GroupRenameTypeSerializer().serialize(arg))
                    d[".tag"] = .str("group_rename")
                    return .dictionary(d)
                case .emmError(let arg):
                    var d = Serialization.getFields(TeamLog.EmmErrorTypeSerializer().serialize(arg))
                    d[".tag"] = .str("emm_error")
                    return .dictionary(d)
                case .loginFail(let arg):
                    var d = Serialization.getFields(TeamLog.LoginFailTypeSerializer().serialize(arg))
                    d[".tag"] = .str("login_fail")
                    return .dictionary(d)
                case .loginSuccess(let arg):
                    var d = Serialization.getFields(TeamLog.LoginSuccessTypeSerializer().serialize(arg))
                    d[".tag"] = .str("login_success")
                    return .dictionary(d)
                case .logout(let arg):
                    var d = Serialization.getFields(TeamLog.LogoutTypeSerializer().serialize(arg))
                    d[".tag"] = .str("logout")
                    return .dictionary(d)
                case .resellerSupportSessionEnd(let arg):
                    var d = Serialization.getFields(TeamLog.ResellerSupportSessionEndTypeSerializer().serialize(arg))
                    d[".tag"] = .str("reseller_support_session_end")
                    return .dictionary(d)
                case .resellerSupportSessionStart(let arg):
                    var d = Serialization.getFields(TeamLog.ResellerSupportSessionStartTypeSerializer().serialize(arg))
                    d[".tag"] = .str("reseller_support_session_start")
                    return .dictionary(d)
                case .signInAsSessionEnd(let arg):
                    var d = Serialization.getFields(TeamLog.SignInAsSessionEndTypeSerializer().serialize(arg))
                    d[".tag"] = .str("sign_in_as_session_end")
                    return .dictionary(d)
                case .signInAsSessionStart(let arg):
                    var d = Serialization.getFields(TeamLog.SignInAsSessionStartTypeSerializer().serialize(arg))
                    d[".tag"] = .str("sign_in_as_session_start")
                    return .dictionary(d)
                case .ssoError(let arg):
                    var d = Serialization.getFields(TeamLog.SsoErrorTypeSerializer().serialize(arg))
                    d[".tag"] = .str("sso_error")
                    return .dictionary(d)
                case .memberAddName(let arg):
                    var d = Serialization.getFields(TeamLog.MemberAddNameTypeSerializer().serialize(arg))
                    d[".tag"] = .str("member_add_name")
                    return .dictionary(d)
                case .memberChangeAdminRole(let arg):
                    var d = Serialization.getFields(TeamLog.MemberChangeAdminRoleTypeSerializer().serialize(arg))
                    d[".tag"] = .str("member_change_admin_role")
                    return .dictionary(d)
                case .memberChangeEmail(let arg):
                    var d = Serialization.getFields(TeamLog.MemberChangeEmailTypeSerializer().serialize(arg))
                    d[".tag"] = .str("member_change_email")
                    return .dictionary(d)
                case .memberChangeMembershipType(let arg):
                    var d = Serialization.getFields(TeamLog.MemberChangeMembershipTypeTypeSerializer().serialize(arg))
                    d[".tag"] = .str("member_change_membership_type")
                    return .dictionary(d)
                case .memberChangeName(let arg):
                    var d = Serialization.getFields(TeamLog.MemberChangeNameTypeSerializer().serialize(arg))
                    d[".tag"] = .str("member_change_name")
                    return .dictionary(d)
                case .memberChangeStatus(let arg):
                    var d = Serialization.getFields(TeamLog.MemberChangeStatusTypeSerializer().serialize(arg))
                    d[".tag"] = .str("member_change_status")
                    return .dictionary(d)
                case .memberDeleteManualContacts(let arg):
                    var d = Serialization.getFields(TeamLog.MemberDeleteManualContactsTypeSerializer().serialize(arg))
                    d[".tag"] = .str("member_delete_manual_contacts")
                    return .dictionary(d)
                case .memberPermanentlyDeleteAccountContents(let arg):
                    var d = Serialization.getFields(TeamLog.MemberPermanentlyDeleteAccountContentsTypeSerializer().serialize(arg))
                    d[".tag"] = .str("member_permanently_delete_account_contents")
                    return .dictionary(d)
                case .memberSpaceLimitsAddCustomQuota(let arg):
                    var d = Serialization.getFields(TeamLog.MemberSpaceLimitsAddCustomQuotaTypeSerializer().serialize(arg))
                    d[".tag"] = .str("member_space_limits_add_custom_quota")
                    return .dictionary(d)
                case .memberSpaceLimitsChangeCustomQuota(let arg):
                    var d = Serialization.getFields(TeamLog.MemberSpaceLimitsChangeCustomQuotaTypeSerializer().serialize(arg))
                    d[".tag"] = .str("member_space_limits_change_custom_quota")
                    return .dictionary(d)
                case .memberSpaceLimitsChangeStatus(let arg):
                    var d = Serialization.getFields(TeamLog.MemberSpaceLimitsChangeStatusTypeSerializer().serialize(arg))
                    d[".tag"] = .str("member_space_limits_change_status")
                    return .dictionary(d)
                case .memberSpaceLimitsRemoveCustomQuota(let arg):
                    var d = Serialization.getFields(TeamLog.MemberSpaceLimitsRemoveCustomQuotaTypeSerializer().serialize(arg))
                    d[".tag"] = .str("member_space_limits_remove_custom_quota")
                    return .dictionary(d)
                case .memberSuggest(let arg):
                    var d = Serialization.getFields(TeamLog.MemberSuggestTypeSerializer().serialize(arg))
                    d[".tag"] = .str("member_suggest")
                    return .dictionary(d)
                case .memberTransferAccountContents(let arg):
                    var d = Serialization.getFields(TeamLog.MemberTransferAccountContentsTypeSerializer().serialize(arg))
                    d[".tag"] = .str("member_transfer_account_contents")
                    return .dictionary(d)
                case .secondaryMailsPolicyChanged(let arg):
                    var d = Serialization.getFields(TeamLog.SecondaryMailsPolicyChangedTypeSerializer().serialize(arg))
                    d[".tag"] = .str("secondary_mails_policy_changed")
                    return .dictionary(d)
                case .paperContentAddMember(let arg):
                    var d = Serialization.getFields(TeamLog.PaperContentAddMemberTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_content_add_member")
                    return .dictionary(d)
                case .paperContentAddToFolder(let arg):
                    var d = Serialization.getFields(TeamLog.PaperContentAddToFolderTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_content_add_to_folder")
                    return .dictionary(d)
                case .paperContentArchive(let arg):
                    var d = Serialization.getFields(TeamLog.PaperContentArchiveTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_content_archive")
                    return .dictionary(d)
                case .paperContentCreate(let arg):
                    var d = Serialization.getFields(TeamLog.PaperContentCreateTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_content_create")
                    return .dictionary(d)
                case .paperContentPermanentlyDelete(let arg):
                    var d = Serialization.getFields(TeamLog.PaperContentPermanentlyDeleteTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_content_permanently_delete")
                    return .dictionary(d)
                case .paperContentRemoveFromFolder(let arg):
                    var d = Serialization.getFields(TeamLog.PaperContentRemoveFromFolderTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_content_remove_from_folder")
                    return .dictionary(d)
                case .paperContentRemoveMember(let arg):
                    var d = Serialization.getFields(TeamLog.PaperContentRemoveMemberTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_content_remove_member")
                    return .dictionary(d)
                case .paperContentRename(let arg):
                    var d = Serialization.getFields(TeamLog.PaperContentRenameTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_content_rename")
                    return .dictionary(d)
                case .paperContentRestore(let arg):
                    var d = Serialization.getFields(TeamLog.PaperContentRestoreTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_content_restore")
                    return .dictionary(d)
                case .paperDocAddComment(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocAddCommentTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_add_comment")
                    return .dictionary(d)
                case .paperDocChangeMemberRole(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocChangeMemberRoleTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_change_member_role")
                    return .dictionary(d)
                case .paperDocChangeSharingPolicy(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocChangeSharingPolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_change_sharing_policy")
                    return .dictionary(d)
                case .paperDocChangeSubscription(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocChangeSubscriptionTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_change_subscription")
                    return .dictionary(d)
                case .paperDocDeleted(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocDeletedTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_deleted")
                    return .dictionary(d)
                case .paperDocDeleteComment(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocDeleteCommentTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_delete_comment")
                    return .dictionary(d)
                case .paperDocDownload(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocDownloadTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_download")
                    return .dictionary(d)
                case .paperDocEdit(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocEditTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_edit")
                    return .dictionary(d)
                case .paperDocEditComment(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocEditCommentTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_edit_comment")
                    return .dictionary(d)
                case .paperDocFollowed(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocFollowedTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_followed")
                    return .dictionary(d)
                case .paperDocMention(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocMentionTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_mention")
                    return .dictionary(d)
                case .paperDocOwnershipChanged(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocOwnershipChangedTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_ownership_changed")
                    return .dictionary(d)
                case .paperDocRequestAccess(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocRequestAccessTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_request_access")
                    return .dictionary(d)
                case .paperDocResolveComment(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocResolveCommentTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_resolve_comment")
                    return .dictionary(d)
                case .paperDocRevert(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocRevertTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_revert")
                    return .dictionary(d)
                case .paperDocSlackShare(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocSlackShareTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_slack_share")
                    return .dictionary(d)
                case .paperDocTeamInvite(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocTeamInviteTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_team_invite")
                    return .dictionary(d)
                case .paperDocTrashed(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocTrashedTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_trashed")
                    return .dictionary(d)
                case .paperDocUnresolveComment(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocUnresolveCommentTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_unresolve_comment")
                    return .dictionary(d)
                case .paperDocUntrashed(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocUntrashedTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_untrashed")
                    return .dictionary(d)
                case .paperDocView(let arg):
                    var d = Serialization.getFields(TeamLog.PaperDocViewTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_doc_view")
                    return .dictionary(d)
                case .paperExternalViewAllow(let arg):
                    var d = Serialization.getFields(TeamLog.PaperExternalViewAllowTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_external_view_allow")
                    return .dictionary(d)
                case .paperExternalViewDefaultTeam(let arg):
                    var d = Serialization.getFields(TeamLog.PaperExternalViewDefaultTeamTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_external_view_default_team")
                    return .dictionary(d)
                case .paperExternalViewForbid(let arg):
                    var d = Serialization.getFields(TeamLog.PaperExternalViewForbidTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_external_view_forbid")
                    return .dictionary(d)
                case .paperFolderChangeSubscription(let arg):
                    var d = Serialization.getFields(TeamLog.PaperFolderChangeSubscriptionTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_folder_change_subscription")
                    return .dictionary(d)
                case .paperFolderDeleted(let arg):
                    var d = Serialization.getFields(TeamLog.PaperFolderDeletedTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_folder_deleted")
                    return .dictionary(d)
                case .paperFolderFollowed(let arg):
                    var d = Serialization.getFields(TeamLog.PaperFolderFollowedTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_folder_followed")
                    return .dictionary(d)
                case .paperFolderTeamInvite(let arg):
                    var d = Serialization.getFields(TeamLog.PaperFolderTeamInviteTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_folder_team_invite")
                    return .dictionary(d)
                case .passwordChange(let arg):
                    var d = Serialization.getFields(TeamLog.PasswordChangeTypeSerializer().serialize(arg))
                    d[".tag"] = .str("password_change")
                    return .dictionary(d)
                case .passwordReset(let arg):
                    var d = Serialization.getFields(TeamLog.PasswordResetTypeSerializer().serialize(arg))
                    d[".tag"] = .str("password_reset")
                    return .dictionary(d)
                case .passwordResetAll(let arg):
                    var d = Serialization.getFields(TeamLog.PasswordResetAllTypeSerializer().serialize(arg))
                    d[".tag"] = .str("password_reset_all")
                    return .dictionary(d)
                case .emmCreateExceptionsReport(let arg):
                    var d = Serialization.getFields(TeamLog.EmmCreateExceptionsReportTypeSerializer().serialize(arg))
                    d[".tag"] = .str("emm_create_exceptions_report")
                    return .dictionary(d)
                case .emmCreateUsageReport(let arg):
                    var d = Serialization.getFields(TeamLog.EmmCreateUsageReportTypeSerializer().serialize(arg))
                    d[".tag"] = .str("emm_create_usage_report")
                    return .dictionary(d)
                case .exportMembersReport(let arg):
                    var d = Serialization.getFields(TeamLog.ExportMembersReportTypeSerializer().serialize(arg))
                    d[".tag"] = .str("export_members_report")
                    return .dictionary(d)
                case .paperAdminExportStart(let arg):
                    var d = Serialization.getFields(TeamLog.PaperAdminExportStartTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_admin_export_start")
                    return .dictionary(d)
                case .smartSyncCreateAdminPrivilegeReport(let arg):
                    var d = Serialization.getFields(TeamLog.SmartSyncCreateAdminPrivilegeReportTypeSerializer().serialize(arg))
                    d[".tag"] = .str("smart_sync_create_admin_privilege_report")
                    return .dictionary(d)
                case .teamActivityCreateReport(let arg):
                    var d = Serialization.getFields(TeamLog.TeamActivityCreateReportTypeSerializer().serialize(arg))
                    d[".tag"] = .str("team_activity_create_report")
                    return .dictionary(d)
                case .collectionShare(let arg):
                    var d = Serialization.getFields(TeamLog.CollectionShareTypeSerializer().serialize(arg))
                    d[".tag"] = .str("collection_share")
                    return .dictionary(d)
                case .noteAclInviteOnly(let arg):
                    var d = Serialization.getFields(TeamLog.NoteAclInviteOnlyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("note_acl_invite_only")
                    return .dictionary(d)
                case .noteAclLink(let arg):
                    var d = Serialization.getFields(TeamLog.NoteAclLinkTypeSerializer().serialize(arg))
                    d[".tag"] = .str("note_acl_link")
                    return .dictionary(d)
                case .noteAclTeamLink(let arg):
                    var d = Serialization.getFields(TeamLog.NoteAclTeamLinkTypeSerializer().serialize(arg))
                    d[".tag"] = .str("note_acl_team_link")
                    return .dictionary(d)
                case .noteShared(let arg):
                    var d = Serialization.getFields(TeamLog.NoteSharedTypeSerializer().serialize(arg))
                    d[".tag"] = .str("note_shared")
                    return .dictionary(d)
                case .noteShareReceive(let arg):
                    var d = Serialization.getFields(TeamLog.NoteShareReceiveTypeSerializer().serialize(arg))
                    d[".tag"] = .str("note_share_receive")
                    return .dictionary(d)
                case .openNoteShared(let arg):
                    var d = Serialization.getFields(TeamLog.OpenNoteSharedTypeSerializer().serialize(arg))
                    d[".tag"] = .str("open_note_shared")
                    return .dictionary(d)
                case .sfAddGroup(let arg):
                    var d = Serialization.getFields(TeamLog.SfAddGroupTypeSerializer().serialize(arg))
                    d[".tag"] = .str("sf_add_group")
                    return .dictionary(d)
                case .sfAllowNonMembersToViewSharedLinks(let arg):
                    var d = Serialization.getFields(TeamLog.SfAllowNonMembersToViewSharedLinksTypeSerializer().serialize(arg))
                    d[".tag"] = .str("sf_allow_non_members_to_view_shared_links")
                    return .dictionary(d)
                case .sfExternalInviteWarn(let arg):
                    var d = Serialization.getFields(TeamLog.SfExternalInviteWarnTypeSerializer().serialize(arg))
                    d[".tag"] = .str("sf_external_invite_warn")
                    return .dictionary(d)
                case .sfFbInvite(let arg):
                    var d = Serialization.getFields(TeamLog.SfFbInviteTypeSerializer().serialize(arg))
                    d[".tag"] = .str("sf_fb_invite")
                    return .dictionary(d)
                case .sfFbInviteChangeRole(let arg):
                    var d = Serialization.getFields(TeamLog.SfFbInviteChangeRoleTypeSerializer().serialize(arg))
                    d[".tag"] = .str("sf_fb_invite_change_role")
                    return .dictionary(d)
                case .sfFbUninvite(let arg):
                    var d = Serialization.getFields(TeamLog.SfFbUninviteTypeSerializer().serialize(arg))
                    d[".tag"] = .str("sf_fb_uninvite")
                    return .dictionary(d)
                case .sfInviteGroup(let arg):
                    var d = Serialization.getFields(TeamLog.SfInviteGroupTypeSerializer().serialize(arg))
                    d[".tag"] = .str("sf_invite_group")
                    return .dictionary(d)
                case .sfTeamGrantAccess(let arg):
                    var d = Serialization.getFields(TeamLog.SfTeamGrantAccessTypeSerializer().serialize(arg))
                    d[".tag"] = .str("sf_team_grant_access")
                    return .dictionary(d)
                case .sfTeamInvite(let arg):
                    var d = Serialization.getFields(TeamLog.SfTeamInviteTypeSerializer().serialize(arg))
                    d[".tag"] = .str("sf_team_invite")
                    return .dictionary(d)
                case .sfTeamInviteChangeRole(let arg):
                    var d = Serialization.getFields(TeamLog.SfTeamInviteChangeRoleTypeSerializer().serialize(arg))
                    d[".tag"] = .str("sf_team_invite_change_role")
                    return .dictionary(d)
                case .sfTeamJoin(let arg):
                    var d = Serialization.getFields(TeamLog.SfTeamJoinTypeSerializer().serialize(arg))
                    d[".tag"] = .str("sf_team_join")
                    return .dictionary(d)
                case .sfTeamJoinFromOobLink(let arg):
                    var d = Serialization.getFields(TeamLog.SfTeamJoinFromOobLinkTypeSerializer().serialize(arg))
                    d[".tag"] = .str("sf_team_join_from_oob_link")
                    return .dictionary(d)
                case .sfTeamUninvite(let arg):
                    var d = Serialization.getFields(TeamLog.SfTeamUninviteTypeSerializer().serialize(arg))
                    d[".tag"] = .str("sf_team_uninvite")
                    return .dictionary(d)
                case .sharedContentAddInvitees(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentAddInviteesTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_add_invitees")
                    return .dictionary(d)
                case .sharedContentAddLinkExpiry(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentAddLinkExpiryTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_add_link_expiry")
                    return .dictionary(d)
                case .sharedContentAddLinkPassword(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentAddLinkPasswordTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_add_link_password")
                    return .dictionary(d)
                case .sharedContentAddMember(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentAddMemberTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_add_member")
                    return .dictionary(d)
                case .sharedContentChangeDownloadsPolicy(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentChangeDownloadsPolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_change_downloads_policy")
                    return .dictionary(d)
                case .sharedContentChangeInviteeRole(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentChangeInviteeRoleTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_change_invitee_role")
                    return .dictionary(d)
                case .sharedContentChangeLinkAudience(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentChangeLinkAudienceTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_change_link_audience")
                    return .dictionary(d)
                case .sharedContentChangeLinkExpiry(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentChangeLinkExpiryTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_change_link_expiry")
                    return .dictionary(d)
                case .sharedContentChangeLinkPassword(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentChangeLinkPasswordTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_change_link_password")
                    return .dictionary(d)
                case .sharedContentChangeMemberRole(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentChangeMemberRoleTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_change_member_role")
                    return .dictionary(d)
                case .sharedContentChangeViewerInfoPolicy(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentChangeViewerInfoPolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_change_viewer_info_policy")
                    return .dictionary(d)
                case .sharedContentClaimInvitation(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentClaimInvitationTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_claim_invitation")
                    return .dictionary(d)
                case .sharedContentCopy(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentCopyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_copy")
                    return .dictionary(d)
                case .sharedContentDownload(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentDownloadTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_download")
                    return .dictionary(d)
                case .sharedContentRelinquishMembership(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentRelinquishMembershipTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_relinquish_membership")
                    return .dictionary(d)
                case .sharedContentRemoveInvitees(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentRemoveInviteesTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_remove_invitees")
                    return .dictionary(d)
                case .sharedContentRemoveLinkExpiry(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentRemoveLinkExpiryTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_remove_link_expiry")
                    return .dictionary(d)
                case .sharedContentRemoveLinkPassword(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentRemoveLinkPasswordTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_remove_link_password")
                    return .dictionary(d)
                case .sharedContentRemoveMember(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentRemoveMemberTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_remove_member")
                    return .dictionary(d)
                case .sharedContentRequestAccess(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentRequestAccessTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_request_access")
                    return .dictionary(d)
                case .sharedContentUnshare(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentUnshareTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_unshare")
                    return .dictionary(d)
                case .sharedContentView(let arg):
                    var d = Serialization.getFields(TeamLog.SharedContentViewTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_content_view")
                    return .dictionary(d)
                case .sharedFolderChangeLinkPolicy(let arg):
                    var d = Serialization.getFields(TeamLog.SharedFolderChangeLinkPolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_folder_change_link_policy")
                    return .dictionary(d)
                case .sharedFolderChangeMembersInheritancePolicy(let arg):
                    var d = Serialization.getFields(TeamLog.SharedFolderChangeMembersInheritancePolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_folder_change_members_inheritance_policy")
                    return .dictionary(d)
                case .sharedFolderChangeMembersManagementPolicy(let arg):
                    var d = Serialization.getFields(TeamLog.SharedFolderChangeMembersManagementPolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_folder_change_members_management_policy")
                    return .dictionary(d)
                case .sharedFolderChangeMembersPolicy(let arg):
                    var d = Serialization.getFields(TeamLog.SharedFolderChangeMembersPolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_folder_change_members_policy")
                    return .dictionary(d)
                case .sharedFolderCreate(let arg):
                    var d = Serialization.getFields(TeamLog.SharedFolderCreateTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_folder_create")
                    return .dictionary(d)
                case .sharedFolderDeclineInvitation(let arg):
                    var d = Serialization.getFields(TeamLog.SharedFolderDeclineInvitationTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_folder_decline_invitation")
                    return .dictionary(d)
                case .sharedFolderMount(let arg):
                    var d = Serialization.getFields(TeamLog.SharedFolderMountTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_folder_mount")
                    return .dictionary(d)
                case .sharedFolderNest(let arg):
                    var d = Serialization.getFields(TeamLog.SharedFolderNestTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_folder_nest")
                    return .dictionary(d)
                case .sharedFolderTransferOwnership(let arg):
                    var d = Serialization.getFields(TeamLog.SharedFolderTransferOwnershipTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_folder_transfer_ownership")
                    return .dictionary(d)
                case .sharedFolderUnmount(let arg):
                    var d = Serialization.getFields(TeamLog.SharedFolderUnmountTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_folder_unmount")
                    return .dictionary(d)
                case .sharedLinkAddExpiry(let arg):
                    var d = Serialization.getFields(TeamLog.SharedLinkAddExpiryTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_link_add_expiry")
                    return .dictionary(d)
                case .sharedLinkChangeExpiry(let arg):
                    var d = Serialization.getFields(TeamLog.SharedLinkChangeExpiryTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_link_change_expiry")
                    return .dictionary(d)
                case .sharedLinkChangeVisibility(let arg):
                    var d = Serialization.getFields(TeamLog.SharedLinkChangeVisibilityTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_link_change_visibility")
                    return .dictionary(d)
                case .sharedLinkCopy(let arg):
                    var d = Serialization.getFields(TeamLog.SharedLinkCopyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_link_copy")
                    return .dictionary(d)
                case .sharedLinkCreate(let arg):
                    var d = Serialization.getFields(TeamLog.SharedLinkCreateTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_link_create")
                    return .dictionary(d)
                case .sharedLinkDisable(let arg):
                    var d = Serialization.getFields(TeamLog.SharedLinkDisableTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_link_disable")
                    return .dictionary(d)
                case .sharedLinkDownload(let arg):
                    var d = Serialization.getFields(TeamLog.SharedLinkDownloadTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_link_download")
                    return .dictionary(d)
                case .sharedLinkRemoveExpiry(let arg):
                    var d = Serialization.getFields(TeamLog.SharedLinkRemoveExpiryTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_link_remove_expiry")
                    return .dictionary(d)
                case .sharedLinkShare(let arg):
                    var d = Serialization.getFields(TeamLog.SharedLinkShareTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_link_share")
                    return .dictionary(d)
                case .sharedLinkView(let arg):
                    var d = Serialization.getFields(TeamLog.SharedLinkViewTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_link_view")
                    return .dictionary(d)
                case .sharedNoteOpened(let arg):
                    var d = Serialization.getFields(TeamLog.SharedNoteOpenedTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shared_note_opened")
                    return .dictionary(d)
                case .shmodelGroupShare(let arg):
                    var d = Serialization.getFields(TeamLog.ShmodelGroupShareTypeSerializer().serialize(arg))
                    d[".tag"] = .str("shmodel_group_share")
                    return .dictionary(d)
                case .showcaseAccessGranted(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseAccessGrantedTypeSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_access_granted")
                    return .dictionary(d)
                case .showcaseAddMember(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseAddMemberTypeSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_add_member")
                    return .dictionary(d)
                case .showcaseArchived(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseArchivedTypeSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_archived")
                    return .dictionary(d)
                case .showcaseCreated(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseCreatedTypeSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_created")
                    return .dictionary(d)
                case .showcaseDeleteComment(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseDeleteCommentTypeSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_delete_comment")
                    return .dictionary(d)
                case .showcaseEdited(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseEditedTypeSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_edited")
                    return .dictionary(d)
                case .showcaseEditComment(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseEditCommentTypeSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_edit_comment")
                    return .dictionary(d)
                case .showcaseFileAdded(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseFileAddedTypeSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_file_added")
                    return .dictionary(d)
                case .showcaseFileDownload(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseFileDownloadTypeSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_file_download")
                    return .dictionary(d)
                case .showcaseFileRemoved(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseFileRemovedTypeSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_file_removed")
                    return .dictionary(d)
                case .showcaseFileView(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseFileViewTypeSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_file_view")
                    return .dictionary(d)
                case .showcasePermanentlyDeleted(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcasePermanentlyDeletedTypeSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_permanently_deleted")
                    return .dictionary(d)
                case .showcasePostComment(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcasePostCommentTypeSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_post_comment")
                    return .dictionary(d)
                case .showcaseRemoveMember(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseRemoveMemberTypeSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_remove_member")
                    return .dictionary(d)
                case .showcaseRenamed(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseRenamedTypeSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_renamed")
                    return .dictionary(d)
                case .showcaseRequestAccess(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseRequestAccessTypeSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_request_access")
                    return .dictionary(d)
                case .showcaseResolveComment(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseResolveCommentTypeSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_resolve_comment")
                    return .dictionary(d)
                case .showcaseRestored(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseRestoredTypeSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_restored")
                    return .dictionary(d)
                case .showcaseTrashed(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseTrashedTypeSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_trashed")
                    return .dictionary(d)
                case .showcaseTrashedDeprecated(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseTrashedDeprecatedTypeSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_trashed_deprecated")
                    return .dictionary(d)
                case .showcaseUnresolveComment(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseUnresolveCommentTypeSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_unresolve_comment")
                    return .dictionary(d)
                case .showcaseUntrashed(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseUntrashedTypeSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_untrashed")
                    return .dictionary(d)
                case .showcaseUntrashedDeprecated(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseUntrashedDeprecatedTypeSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_untrashed_deprecated")
                    return .dictionary(d)
                case .showcaseView(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseViewTypeSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_view")
                    return .dictionary(d)
                case .ssoAddCert(let arg):
                    var d = Serialization.getFields(TeamLog.SsoAddCertTypeSerializer().serialize(arg))
                    d[".tag"] = .str("sso_add_cert")
                    return .dictionary(d)
                case .ssoAddLoginUrl(let arg):
                    var d = Serialization.getFields(TeamLog.SsoAddLoginUrlTypeSerializer().serialize(arg))
                    d[".tag"] = .str("sso_add_login_url")
                    return .dictionary(d)
                case .ssoAddLogoutUrl(let arg):
                    var d = Serialization.getFields(TeamLog.SsoAddLogoutUrlTypeSerializer().serialize(arg))
                    d[".tag"] = .str("sso_add_logout_url")
                    return .dictionary(d)
                case .ssoChangeCert(let arg):
                    var d = Serialization.getFields(TeamLog.SsoChangeCertTypeSerializer().serialize(arg))
                    d[".tag"] = .str("sso_change_cert")
                    return .dictionary(d)
                case .ssoChangeLoginUrl(let arg):
                    var d = Serialization.getFields(TeamLog.SsoChangeLoginUrlTypeSerializer().serialize(arg))
                    d[".tag"] = .str("sso_change_login_url")
                    return .dictionary(d)
                case .ssoChangeLogoutUrl(let arg):
                    var d = Serialization.getFields(TeamLog.SsoChangeLogoutUrlTypeSerializer().serialize(arg))
                    d[".tag"] = .str("sso_change_logout_url")
                    return .dictionary(d)
                case .ssoChangeSamlIdentityMode(let arg):
                    var d = Serialization.getFields(TeamLog.SsoChangeSamlIdentityModeTypeSerializer().serialize(arg))
                    d[".tag"] = .str("sso_change_saml_identity_mode")
                    return .dictionary(d)
                case .ssoRemoveCert(let arg):
                    var d = Serialization.getFields(TeamLog.SsoRemoveCertTypeSerializer().serialize(arg))
                    d[".tag"] = .str("sso_remove_cert")
                    return .dictionary(d)
                case .ssoRemoveLoginUrl(let arg):
                    var d = Serialization.getFields(TeamLog.SsoRemoveLoginUrlTypeSerializer().serialize(arg))
                    d[".tag"] = .str("sso_remove_login_url")
                    return .dictionary(d)
                case .ssoRemoveLogoutUrl(let arg):
                    var d = Serialization.getFields(TeamLog.SsoRemoveLogoutUrlTypeSerializer().serialize(arg))
                    d[".tag"] = .str("sso_remove_logout_url")
                    return .dictionary(d)
                case .teamFolderChangeStatus(let arg):
                    var d = Serialization.getFields(TeamLog.TeamFolderChangeStatusTypeSerializer().serialize(arg))
                    d[".tag"] = .str("team_folder_change_status")
                    return .dictionary(d)
                case .teamFolderCreate(let arg):
                    var d = Serialization.getFields(TeamLog.TeamFolderCreateTypeSerializer().serialize(arg))
                    d[".tag"] = .str("team_folder_create")
                    return .dictionary(d)
                case .teamFolderDowngrade(let arg):
                    var d = Serialization.getFields(TeamLog.TeamFolderDowngradeTypeSerializer().serialize(arg))
                    d[".tag"] = .str("team_folder_downgrade")
                    return .dictionary(d)
                case .teamFolderPermanentlyDelete(let arg):
                    var d = Serialization.getFields(TeamLog.TeamFolderPermanentlyDeleteTypeSerializer().serialize(arg))
                    d[".tag"] = .str("team_folder_permanently_delete")
                    return .dictionary(d)
                case .teamFolderRename(let arg):
                    var d = Serialization.getFields(TeamLog.TeamFolderRenameTypeSerializer().serialize(arg))
                    d[".tag"] = .str("team_folder_rename")
                    return .dictionary(d)
                case .teamSelectiveSyncSettingsChanged(let arg):
                    var d = Serialization.getFields(TeamLog.TeamSelectiveSyncSettingsChangedTypeSerializer().serialize(arg))
                    d[".tag"] = .str("team_selective_sync_settings_changed")
                    return .dictionary(d)
                case .accountCaptureChangePolicy(let arg):
                    var d = Serialization.getFields(TeamLog.AccountCaptureChangePolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("account_capture_change_policy")
                    return .dictionary(d)
                case .allowDownloadDisabled(let arg):
                    var d = Serialization.getFields(TeamLog.AllowDownloadDisabledTypeSerializer().serialize(arg))
                    d[".tag"] = .str("allow_download_disabled")
                    return .dictionary(d)
                case .allowDownloadEnabled(let arg):
                    var d = Serialization.getFields(TeamLog.AllowDownloadEnabledTypeSerializer().serialize(arg))
                    d[".tag"] = .str("allow_download_enabled")
                    return .dictionary(d)
                case .cameraUploadsPolicyChanged(let arg):
                    var d = Serialization.getFields(TeamLog.CameraUploadsPolicyChangedTypeSerializer().serialize(arg))
                    d[".tag"] = .str("camera_uploads_policy_changed")
                    return .dictionary(d)
                case .dataPlacementRestrictionChangePolicy(let arg):
                    var d = Serialization.getFields(TeamLog.DataPlacementRestrictionChangePolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("data_placement_restriction_change_policy")
                    return .dictionary(d)
                case .dataPlacementRestrictionSatisfyPolicy(let arg):
                    var d = Serialization.getFields(TeamLog.DataPlacementRestrictionSatisfyPolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("data_placement_restriction_satisfy_policy")
                    return .dictionary(d)
                case .deviceApprovalsChangeDesktopPolicy(let arg):
                    var d = Serialization.getFields(TeamLog.DeviceApprovalsChangeDesktopPolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("device_approvals_change_desktop_policy")
                    return .dictionary(d)
                case .deviceApprovalsChangeMobilePolicy(let arg):
                    var d = Serialization.getFields(TeamLog.DeviceApprovalsChangeMobilePolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("device_approvals_change_mobile_policy")
                    return .dictionary(d)
                case .deviceApprovalsChangeOverageAction(let arg):
                    var d = Serialization.getFields(TeamLog.DeviceApprovalsChangeOverageActionTypeSerializer().serialize(arg))
                    d[".tag"] = .str("device_approvals_change_overage_action")
                    return .dictionary(d)
                case .deviceApprovalsChangeUnlinkAction(let arg):
                    var d = Serialization.getFields(TeamLog.DeviceApprovalsChangeUnlinkActionTypeSerializer().serialize(arg))
                    d[".tag"] = .str("device_approvals_change_unlink_action")
                    return .dictionary(d)
                case .directoryRestrictionsAddMembers(let arg):
                    var d = Serialization.getFields(TeamLog.DirectoryRestrictionsAddMembersTypeSerializer().serialize(arg))
                    d[".tag"] = .str("directory_restrictions_add_members")
                    return .dictionary(d)
                case .directoryRestrictionsRemoveMembers(let arg):
                    var d = Serialization.getFields(TeamLog.DirectoryRestrictionsRemoveMembersTypeSerializer().serialize(arg))
                    d[".tag"] = .str("directory_restrictions_remove_members")
                    return .dictionary(d)
                case .emmAddException(let arg):
                    var d = Serialization.getFields(TeamLog.EmmAddExceptionTypeSerializer().serialize(arg))
                    d[".tag"] = .str("emm_add_exception")
                    return .dictionary(d)
                case .emmChangePolicy(let arg):
                    var d = Serialization.getFields(TeamLog.EmmChangePolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("emm_change_policy")
                    return .dictionary(d)
                case .emmRemoveException(let arg):
                    var d = Serialization.getFields(TeamLog.EmmRemoveExceptionTypeSerializer().serialize(arg))
                    d[".tag"] = .str("emm_remove_exception")
                    return .dictionary(d)
                case .extendedVersionHistoryChangePolicy(let arg):
                    var d = Serialization.getFields(TeamLog.ExtendedVersionHistoryChangePolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("extended_version_history_change_policy")
                    return .dictionary(d)
                case .fileCommentsChangePolicy(let arg):
                    var d = Serialization.getFields(TeamLog.FileCommentsChangePolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("file_comments_change_policy")
                    return .dictionary(d)
                case .fileRequestsChangePolicy(let arg):
                    var d = Serialization.getFields(TeamLog.FileRequestsChangePolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("file_requests_change_policy")
                    return .dictionary(d)
                case .fileRequestsEmailsEnabled(let arg):
                    var d = Serialization.getFields(TeamLog.FileRequestsEmailsEnabledTypeSerializer().serialize(arg))
                    d[".tag"] = .str("file_requests_emails_enabled")
                    return .dictionary(d)
                case .fileRequestsEmailsRestrictedToTeamOnly(let arg):
                    var d = Serialization.getFields(TeamLog.FileRequestsEmailsRestrictedToTeamOnlyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("file_requests_emails_restricted_to_team_only")
                    return .dictionary(d)
                case .googleSsoChangePolicy(let arg):
                    var d = Serialization.getFields(TeamLog.GoogleSsoChangePolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("google_sso_change_policy")
                    return .dictionary(d)
                case .groupUserManagementChangePolicy(let arg):
                    var d = Serialization.getFields(TeamLog.GroupUserManagementChangePolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("group_user_management_change_policy")
                    return .dictionary(d)
                case .memberRequestsChangePolicy(let arg):
                    var d = Serialization.getFields(TeamLog.MemberRequestsChangePolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("member_requests_change_policy")
                    return .dictionary(d)
                case .memberSpaceLimitsAddException(let arg):
                    var d = Serialization.getFields(TeamLog.MemberSpaceLimitsAddExceptionTypeSerializer().serialize(arg))
                    d[".tag"] = .str("member_space_limits_add_exception")
                    return .dictionary(d)
                case .memberSpaceLimitsChangeCapsTypePolicy(let arg):
                    var d = Serialization.getFields(TeamLog.MemberSpaceLimitsChangeCapsTypePolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("member_space_limits_change_caps_type_policy")
                    return .dictionary(d)
                case .memberSpaceLimitsChangePolicy(let arg):
                    var d = Serialization.getFields(TeamLog.MemberSpaceLimitsChangePolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("member_space_limits_change_policy")
                    return .dictionary(d)
                case .memberSpaceLimitsRemoveException(let arg):
                    var d = Serialization.getFields(TeamLog.MemberSpaceLimitsRemoveExceptionTypeSerializer().serialize(arg))
                    d[".tag"] = .str("member_space_limits_remove_exception")
                    return .dictionary(d)
                case .memberSuggestionsChangePolicy(let arg):
                    var d = Serialization.getFields(TeamLog.MemberSuggestionsChangePolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("member_suggestions_change_policy")
                    return .dictionary(d)
                case .microsoftOfficeAddinChangePolicy(let arg):
                    var d = Serialization.getFields(TeamLog.MicrosoftOfficeAddinChangePolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("microsoft_office_addin_change_policy")
                    return .dictionary(d)
                case .networkControlChangePolicy(let arg):
                    var d = Serialization.getFields(TeamLog.NetworkControlChangePolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("network_control_change_policy")
                    return .dictionary(d)
                case .paperChangeDeploymentPolicy(let arg):
                    var d = Serialization.getFields(TeamLog.PaperChangeDeploymentPolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_change_deployment_policy")
                    return .dictionary(d)
                case .paperChangeMemberLinkPolicy(let arg):
                    var d = Serialization.getFields(TeamLog.PaperChangeMemberLinkPolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_change_member_link_policy")
                    return .dictionary(d)
                case .paperChangeMemberPolicy(let arg):
                    var d = Serialization.getFields(TeamLog.PaperChangeMemberPolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_change_member_policy")
                    return .dictionary(d)
                case .paperChangePolicy(let arg):
                    var d = Serialization.getFields(TeamLog.PaperChangePolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_change_policy")
                    return .dictionary(d)
                case .paperEnabledUsersGroupAddition(let arg):
                    var d = Serialization.getFields(TeamLog.PaperEnabledUsersGroupAdditionTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_enabled_users_group_addition")
                    return .dictionary(d)
                case .paperEnabledUsersGroupRemoval(let arg):
                    var d = Serialization.getFields(TeamLog.PaperEnabledUsersGroupRemovalTypeSerializer().serialize(arg))
                    d[".tag"] = .str("paper_enabled_users_group_removal")
                    return .dictionary(d)
                case .permanentDeleteChangePolicy(let arg):
                    var d = Serialization.getFields(TeamLog.PermanentDeleteChangePolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("permanent_delete_change_policy")
                    return .dictionary(d)
                case .sharingChangeFolderJoinPolicy(let arg):
                    var d = Serialization.getFields(TeamLog.SharingChangeFolderJoinPolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("sharing_change_folder_join_policy")
                    return .dictionary(d)
                case .sharingChangeLinkPolicy(let arg):
                    var d = Serialization.getFields(TeamLog.SharingChangeLinkPolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("sharing_change_link_policy")
                    return .dictionary(d)
                case .sharingChangeMemberPolicy(let arg):
                    var d = Serialization.getFields(TeamLog.SharingChangeMemberPolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("sharing_change_member_policy")
                    return .dictionary(d)
                case .showcaseChangeDownloadPolicy(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseChangeDownloadPolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_change_download_policy")
                    return .dictionary(d)
                case .showcaseChangeEnabledPolicy(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseChangeEnabledPolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_change_enabled_policy")
                    return .dictionary(d)
                case .showcaseChangeExternalSharingPolicy(let arg):
                    var d = Serialization.getFields(TeamLog.ShowcaseChangeExternalSharingPolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("showcase_change_external_sharing_policy")
                    return .dictionary(d)
                case .smartSyncChangePolicy(let arg):
                    var d = Serialization.getFields(TeamLog.SmartSyncChangePolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("smart_sync_change_policy")
                    return .dictionary(d)
                case .smartSyncNotOptOut(let arg):
                    var d = Serialization.getFields(TeamLog.SmartSyncNotOptOutTypeSerializer().serialize(arg))
                    d[".tag"] = .str("smart_sync_not_opt_out")
                    return .dictionary(d)
                case .smartSyncOptOut(let arg):
                    var d = Serialization.getFields(TeamLog.SmartSyncOptOutTypeSerializer().serialize(arg))
                    d[".tag"] = .str("smart_sync_opt_out")
                    return .dictionary(d)
                case .ssoChangePolicy(let arg):
                    var d = Serialization.getFields(TeamLog.SsoChangePolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("sso_change_policy")
                    return .dictionary(d)
                case .teamSelectiveSyncPolicyChanged(let arg):
                    var d = Serialization.getFields(TeamLog.TeamSelectiveSyncPolicyChangedTypeSerializer().serialize(arg))
                    d[".tag"] = .str("team_selective_sync_policy_changed")
                    return .dictionary(d)
                case .tfaChangePolicy(let arg):
                    var d = Serialization.getFields(TeamLog.TfaChangePolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("tfa_change_policy")
                    return .dictionary(d)
                case .twoAccountChangePolicy(let arg):
                    var d = Serialization.getFields(TeamLog.TwoAccountChangePolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("two_account_change_policy")
                    return .dictionary(d)
                case .viewerInfoPolicyChanged(let arg):
                    var d = Serialization.getFields(TeamLog.ViewerInfoPolicyChangedTypeSerializer().serialize(arg))
                    d[".tag"] = .str("viewer_info_policy_changed")
                    return .dictionary(d)
                case .webSessionsChangeFixedLengthPolicy(let arg):
                    var d = Serialization.getFields(TeamLog.WebSessionsChangeFixedLengthPolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("web_sessions_change_fixed_length_policy")
                    return .dictionary(d)
                case .webSessionsChangeIdleLengthPolicy(let arg):
                    var d = Serialization.getFields(TeamLog.WebSessionsChangeIdleLengthPolicyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("web_sessions_change_idle_length_policy")
                    return .dictionary(d)
                case .teamMergeFrom(let arg):
                    var d = Serialization.getFields(TeamLog.TeamMergeFromTypeSerializer().serialize(arg))
                    d[".tag"] = .str("team_merge_from")
                    return .dictionary(d)
                case .teamMergeTo(let arg):
                    var d = Serialization.getFields(TeamLog.TeamMergeToTypeSerializer().serialize(arg))
                    d[".tag"] = .str("team_merge_to")
                    return .dictionary(d)
                case .teamProfileAddLogo(let arg):
                    var d = Serialization.getFields(TeamLog.TeamProfileAddLogoTypeSerializer().serialize(arg))
                    d[".tag"] = .str("team_profile_add_logo")
                    return .dictionary(d)
                case .teamProfileChangeDefaultLanguage(let arg):
                    var d = Serialization.getFields(TeamLog.TeamProfileChangeDefaultLanguageTypeSerializer().serialize(arg))
                    d[".tag"] = .str("team_profile_change_default_language")
                    return .dictionary(d)
                case .teamProfileChangeLogo(let arg):
                    var d = Serialization.getFields(TeamLog.TeamProfileChangeLogoTypeSerializer().serialize(arg))
                    d[".tag"] = .str("team_profile_change_logo")
                    return .dictionary(d)
                case .teamProfileChangeName(let arg):
                    var d = Serialization.getFields(TeamLog.TeamProfileChangeNameTypeSerializer().serialize(arg))
                    d[".tag"] = .str("team_profile_change_name")
                    return .dictionary(d)
                case .teamProfileRemoveLogo(let arg):
                    var d = Serialization.getFields(TeamLog.TeamProfileRemoveLogoTypeSerializer().serialize(arg))
                    d[".tag"] = .str("team_profile_remove_logo")
                    return .dictionary(d)
                case .tfaAddBackupPhone(let arg):
                    var d = Serialization.getFields(TeamLog.TfaAddBackupPhoneTypeSerializer().serialize(arg))
                    d[".tag"] = .str("tfa_add_backup_phone")
                    return .dictionary(d)
                case .tfaAddSecurityKey(let arg):
                    var d = Serialization.getFields(TeamLog.TfaAddSecurityKeyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("tfa_add_security_key")
                    return .dictionary(d)
                case .tfaChangeBackupPhone(let arg):
                    var d = Serialization.getFields(TeamLog.TfaChangeBackupPhoneTypeSerializer().serialize(arg))
                    d[".tag"] = .str("tfa_change_backup_phone")
                    return .dictionary(d)
                case .tfaChangeStatus(let arg):
                    var d = Serialization.getFields(TeamLog.TfaChangeStatusTypeSerializer().serialize(arg))
                    d[".tag"] = .str("tfa_change_status")
                    return .dictionary(d)
                case .tfaRemoveBackupPhone(let arg):
                    var d = Serialization.getFields(TeamLog.TfaRemoveBackupPhoneTypeSerializer().serialize(arg))
                    d[".tag"] = .str("tfa_remove_backup_phone")
                    return .dictionary(d)
                case .tfaRemoveSecurityKey(let arg):
                    var d = Serialization.getFields(TeamLog.TfaRemoveSecurityKeyTypeSerializer().serialize(arg))
                    d[".tag"] = .str("tfa_remove_security_key")
                    return .dictionary(d)
                case .tfaReset(let arg):
                    var d = Serialization.getFields(TeamLog.TfaResetTypeSerializer().serialize(arg))
                    d[".tag"] = .str("tfa_reset")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> EventType {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "app_link_team":
                            let v = TeamLog.AppLinkTeamTypeSerializer().deserialize(json)
                            return EventType.appLinkTeam(v)
                        case "app_link_user":
                            let v = TeamLog.AppLinkUserTypeSerializer().deserialize(json)
                            return EventType.appLinkUser(v)
                        case "app_unlink_team":
                            let v = TeamLog.AppUnlinkTeamTypeSerializer().deserialize(json)
                            return EventType.appUnlinkTeam(v)
                        case "app_unlink_user":
                            let v = TeamLog.AppUnlinkUserTypeSerializer().deserialize(json)
                            return EventType.appUnlinkUser(v)
                        case "file_add_comment":
                            let v = TeamLog.FileAddCommentTypeSerializer().deserialize(json)
                            return EventType.fileAddComment(v)
                        case "file_change_comment_subscription":
                            let v = TeamLog.FileChangeCommentSubscriptionTypeSerializer().deserialize(json)
                            return EventType.fileChangeCommentSubscription(v)
                        case "file_delete_comment":
                            let v = TeamLog.FileDeleteCommentTypeSerializer().deserialize(json)
                            return EventType.fileDeleteComment(v)
                        case "file_edit_comment":
                            let v = TeamLog.FileEditCommentTypeSerializer().deserialize(json)
                            return EventType.fileEditComment(v)
                        case "file_like_comment":
                            let v = TeamLog.FileLikeCommentTypeSerializer().deserialize(json)
                            return EventType.fileLikeComment(v)
                        case "file_resolve_comment":
                            let v = TeamLog.FileResolveCommentTypeSerializer().deserialize(json)
                            return EventType.fileResolveComment(v)
                        case "file_unlike_comment":
                            let v = TeamLog.FileUnlikeCommentTypeSerializer().deserialize(json)
                            return EventType.fileUnlikeComment(v)
                        case "file_unresolve_comment":
                            let v = TeamLog.FileUnresolveCommentTypeSerializer().deserialize(json)
                            return EventType.fileUnresolveComment(v)
                        case "device_change_ip_desktop":
                            let v = TeamLog.DeviceChangeIpDesktopTypeSerializer().deserialize(json)
                            return EventType.deviceChangeIpDesktop(v)
                        case "device_change_ip_mobile":
                            let v = TeamLog.DeviceChangeIpMobileTypeSerializer().deserialize(json)
                            return EventType.deviceChangeIpMobile(v)
                        case "device_change_ip_web":
                            let v = TeamLog.DeviceChangeIpWebTypeSerializer().deserialize(json)
                            return EventType.deviceChangeIpWeb(v)
                        case "device_delete_on_unlink_fail":
                            let v = TeamLog.DeviceDeleteOnUnlinkFailTypeSerializer().deserialize(json)
                            return EventType.deviceDeleteOnUnlinkFail(v)
                        case "device_delete_on_unlink_success":
                            let v = TeamLog.DeviceDeleteOnUnlinkSuccessTypeSerializer().deserialize(json)
                            return EventType.deviceDeleteOnUnlinkSuccess(v)
                        case "device_link_fail":
                            let v = TeamLog.DeviceLinkFailTypeSerializer().deserialize(json)
                            return EventType.deviceLinkFail(v)
                        case "device_link_success":
                            let v = TeamLog.DeviceLinkSuccessTypeSerializer().deserialize(json)
                            return EventType.deviceLinkSuccess(v)
                        case "device_management_disabled":
                            let v = TeamLog.DeviceManagementDisabledTypeSerializer().deserialize(json)
                            return EventType.deviceManagementDisabled(v)
                        case "device_management_enabled":
                            let v = TeamLog.DeviceManagementEnabledTypeSerializer().deserialize(json)
                            return EventType.deviceManagementEnabled(v)
                        case "device_unlink":
                            let v = TeamLog.DeviceUnlinkTypeSerializer().deserialize(json)
                            return EventType.deviceUnlink(v)
                        case "emm_refresh_auth_token":
                            let v = TeamLog.EmmRefreshAuthTokenTypeSerializer().deserialize(json)
                            return EventType.emmRefreshAuthToken(v)
                        case "account_capture_change_availability":
                            let v = TeamLog.AccountCaptureChangeAvailabilityTypeSerializer().deserialize(json)
                            return EventType.accountCaptureChangeAvailability(v)
                        case "account_capture_migrate_account":
                            let v = TeamLog.AccountCaptureMigrateAccountTypeSerializer().deserialize(json)
                            return EventType.accountCaptureMigrateAccount(v)
                        case "account_capture_notification_emails_sent":
                            let v = TeamLog.AccountCaptureNotificationEmailsSentTypeSerializer().deserialize(json)
                            return EventType.accountCaptureNotificationEmailsSent(v)
                        case "account_capture_relinquish_account":
                            let v = TeamLog.AccountCaptureRelinquishAccountTypeSerializer().deserialize(json)
                            return EventType.accountCaptureRelinquishAccount(v)
                        case "disabled_domain_invites":
                            let v = TeamLog.DisabledDomainInvitesTypeSerializer().deserialize(json)
                            return EventType.disabledDomainInvites(v)
                        case "domain_invites_approve_request_to_join_team":
                            let v = TeamLog.DomainInvitesApproveRequestToJoinTeamTypeSerializer().deserialize(json)
                            return EventType.domainInvitesApproveRequestToJoinTeam(v)
                        case "domain_invites_decline_request_to_join_team":
                            let v = TeamLog.DomainInvitesDeclineRequestToJoinTeamTypeSerializer().deserialize(json)
                            return EventType.domainInvitesDeclineRequestToJoinTeam(v)
                        case "domain_invites_email_existing_users":
                            let v = TeamLog.DomainInvitesEmailExistingUsersTypeSerializer().deserialize(json)
                            return EventType.domainInvitesEmailExistingUsers(v)
                        case "domain_invites_request_to_join_team":
                            let v = TeamLog.DomainInvitesRequestToJoinTeamTypeSerializer().deserialize(json)
                            return EventType.domainInvitesRequestToJoinTeam(v)
                        case "domain_invites_set_invite_new_user_pref_to_no":
                            let v = TeamLog.DomainInvitesSetInviteNewUserPrefToNoTypeSerializer().deserialize(json)
                            return EventType.domainInvitesSetInviteNewUserPrefToNo(v)
                        case "domain_invites_set_invite_new_user_pref_to_yes":
                            let v = TeamLog.DomainInvitesSetInviteNewUserPrefToYesTypeSerializer().deserialize(json)
                            return EventType.domainInvitesSetInviteNewUserPrefToYes(v)
                        case "domain_verification_add_domain_fail":
                            let v = TeamLog.DomainVerificationAddDomainFailTypeSerializer().deserialize(json)
                            return EventType.domainVerificationAddDomainFail(v)
                        case "domain_verification_add_domain_success":
                            let v = TeamLog.DomainVerificationAddDomainSuccessTypeSerializer().deserialize(json)
                            return EventType.domainVerificationAddDomainSuccess(v)
                        case "domain_verification_remove_domain":
                            let v = TeamLog.DomainVerificationRemoveDomainTypeSerializer().deserialize(json)
                            return EventType.domainVerificationRemoveDomain(v)
                        case "enabled_domain_invites":
                            let v = TeamLog.EnabledDomainInvitesTypeSerializer().deserialize(json)
                            return EventType.enabledDomainInvites(v)
                        case "create_folder":
                            let v = TeamLog.CreateFolderTypeSerializer().deserialize(json)
                            return EventType.createFolder(v)
                        case "file_add":
                            let v = TeamLog.FileAddTypeSerializer().deserialize(json)
                            return EventType.fileAdd(v)
                        case "file_copy":
                            let v = TeamLog.FileCopyTypeSerializer().deserialize(json)
                            return EventType.fileCopy(v)
                        case "file_delete":
                            let v = TeamLog.FileDeleteTypeSerializer().deserialize(json)
                            return EventType.fileDelete(v)
                        case "file_download":
                            let v = TeamLog.FileDownloadTypeSerializer().deserialize(json)
                            return EventType.fileDownload(v)
                        case "file_edit":
                            let v = TeamLog.FileEditTypeSerializer().deserialize(json)
                            return EventType.fileEdit(v)
                        case "file_get_copy_reference":
                            let v = TeamLog.FileGetCopyReferenceTypeSerializer().deserialize(json)
                            return EventType.fileGetCopyReference(v)
                        case "file_move":
                            let v = TeamLog.FileMoveTypeSerializer().deserialize(json)
                            return EventType.fileMove(v)
                        case "file_permanently_delete":
                            let v = TeamLog.FilePermanentlyDeleteTypeSerializer().deserialize(json)
                            return EventType.filePermanentlyDelete(v)
                        case "file_preview":
                            let v = TeamLog.FilePreviewTypeSerializer().deserialize(json)
                            return EventType.filePreview(v)
                        case "file_rename":
                            let v = TeamLog.FileRenameTypeSerializer().deserialize(json)
                            return EventType.fileRename(v)
                        case "file_restore":
                            let v = TeamLog.FileRestoreTypeSerializer().deserialize(json)
                            return EventType.fileRestore(v)
                        case "file_revert":
                            let v = TeamLog.FileRevertTypeSerializer().deserialize(json)
                            return EventType.fileRevert(v)
                        case "file_rollback_changes":
                            let v = TeamLog.FileRollbackChangesTypeSerializer().deserialize(json)
                            return EventType.fileRollbackChanges(v)
                        case "file_save_copy_reference":
                            let v = TeamLog.FileSaveCopyReferenceTypeSerializer().deserialize(json)
                            return EventType.fileSaveCopyReference(v)
                        case "file_request_change":
                            let v = TeamLog.FileRequestChangeTypeSerializer().deserialize(json)
                            return EventType.fileRequestChange(v)
                        case "file_request_close":
                            let v = TeamLog.FileRequestCloseTypeSerializer().deserialize(json)
                            return EventType.fileRequestClose(v)
                        case "file_request_create":
                            let v = TeamLog.FileRequestCreateTypeSerializer().deserialize(json)
                            return EventType.fileRequestCreate(v)
                        case "file_request_receive_file":
                            let v = TeamLog.FileRequestReceiveFileTypeSerializer().deserialize(json)
                            return EventType.fileRequestReceiveFile(v)
                        case "group_add_external_id":
                            let v = TeamLog.GroupAddExternalIdTypeSerializer().deserialize(json)
                            return EventType.groupAddExternalId(v)
                        case "group_add_member":
                            let v = TeamLog.GroupAddMemberTypeSerializer().deserialize(json)
                            return EventType.groupAddMember(v)
                        case "group_change_external_id":
                            let v = TeamLog.GroupChangeExternalIdTypeSerializer().deserialize(json)
                            return EventType.groupChangeExternalId(v)
                        case "group_change_management_type":
                            let v = TeamLog.GroupChangeManagementTypeTypeSerializer().deserialize(json)
                            return EventType.groupChangeManagementType(v)
                        case "group_change_member_role":
                            let v = TeamLog.GroupChangeMemberRoleTypeSerializer().deserialize(json)
                            return EventType.groupChangeMemberRole(v)
                        case "group_create":
                            let v = TeamLog.GroupCreateTypeSerializer().deserialize(json)
                            return EventType.groupCreate(v)
                        case "group_delete":
                            let v = TeamLog.GroupDeleteTypeSerializer().deserialize(json)
                            return EventType.groupDelete(v)
                        case "group_description_updated":
                            let v = TeamLog.GroupDescriptionUpdatedTypeSerializer().deserialize(json)
                            return EventType.groupDescriptionUpdated(v)
                        case "group_join_policy_updated":
                            let v = TeamLog.GroupJoinPolicyUpdatedTypeSerializer().deserialize(json)
                            return EventType.groupJoinPolicyUpdated(v)
                        case "group_moved":
                            let v = TeamLog.GroupMovedTypeSerializer().deserialize(json)
                            return EventType.groupMoved(v)
                        case "group_remove_external_id":
                            let v = TeamLog.GroupRemoveExternalIdTypeSerializer().deserialize(json)
                            return EventType.groupRemoveExternalId(v)
                        case "group_remove_member":
                            let v = TeamLog.GroupRemoveMemberTypeSerializer().deserialize(json)
                            return EventType.groupRemoveMember(v)
                        case "group_rename":
                            let v = TeamLog.GroupRenameTypeSerializer().deserialize(json)
                            return EventType.groupRename(v)
                        case "emm_error":
                            let v = TeamLog.EmmErrorTypeSerializer().deserialize(json)
                            return EventType.emmError(v)
                        case "login_fail":
                            let v = TeamLog.LoginFailTypeSerializer().deserialize(json)
                            return EventType.loginFail(v)
                        case "login_success":
                            let v = TeamLog.LoginSuccessTypeSerializer().deserialize(json)
                            return EventType.loginSuccess(v)
                        case "logout":
                            let v = TeamLog.LogoutTypeSerializer().deserialize(json)
                            return EventType.logout(v)
                        case "reseller_support_session_end":
                            let v = TeamLog.ResellerSupportSessionEndTypeSerializer().deserialize(json)
                            return EventType.resellerSupportSessionEnd(v)
                        case "reseller_support_session_start":
                            let v = TeamLog.ResellerSupportSessionStartTypeSerializer().deserialize(json)
                            return EventType.resellerSupportSessionStart(v)
                        case "sign_in_as_session_end":
                            let v = TeamLog.SignInAsSessionEndTypeSerializer().deserialize(json)
                            return EventType.signInAsSessionEnd(v)
                        case "sign_in_as_session_start":
                            let v = TeamLog.SignInAsSessionStartTypeSerializer().deserialize(json)
                            return EventType.signInAsSessionStart(v)
                        case "sso_error":
                            let v = TeamLog.SsoErrorTypeSerializer().deserialize(json)
                            return EventType.ssoError(v)
                        case "member_add_name":
                            let v = TeamLog.MemberAddNameTypeSerializer().deserialize(json)
                            return EventType.memberAddName(v)
                        case "member_change_admin_role":
                            let v = TeamLog.MemberChangeAdminRoleTypeSerializer().deserialize(json)
                            return EventType.memberChangeAdminRole(v)
                        case "member_change_email":
                            let v = TeamLog.MemberChangeEmailTypeSerializer().deserialize(json)
                            return EventType.memberChangeEmail(v)
                        case "member_change_membership_type":
                            let v = TeamLog.MemberChangeMembershipTypeTypeSerializer().deserialize(json)
                            return EventType.memberChangeMembershipType(v)
                        case "member_change_name":
                            let v = TeamLog.MemberChangeNameTypeSerializer().deserialize(json)
                            return EventType.memberChangeName(v)
                        case "member_change_status":
                            let v = TeamLog.MemberChangeStatusTypeSerializer().deserialize(json)
                            return EventType.memberChangeStatus(v)
                        case "member_delete_manual_contacts":
                            let v = TeamLog.MemberDeleteManualContactsTypeSerializer().deserialize(json)
                            return EventType.memberDeleteManualContacts(v)
                        case "member_permanently_delete_account_contents":
                            let v = TeamLog.MemberPermanentlyDeleteAccountContentsTypeSerializer().deserialize(json)
                            return EventType.memberPermanentlyDeleteAccountContents(v)
                        case "member_space_limits_add_custom_quota":
                            let v = TeamLog.MemberSpaceLimitsAddCustomQuotaTypeSerializer().deserialize(json)
                            return EventType.memberSpaceLimitsAddCustomQuota(v)
                        case "member_space_limits_change_custom_quota":
                            let v = TeamLog.MemberSpaceLimitsChangeCustomQuotaTypeSerializer().deserialize(json)
                            return EventType.memberSpaceLimitsChangeCustomQuota(v)
                        case "member_space_limits_change_status":
                            let v = TeamLog.MemberSpaceLimitsChangeStatusTypeSerializer().deserialize(json)
                            return EventType.memberSpaceLimitsChangeStatus(v)
                        case "member_space_limits_remove_custom_quota":
                            let v = TeamLog.MemberSpaceLimitsRemoveCustomQuotaTypeSerializer().deserialize(json)
                            return EventType.memberSpaceLimitsRemoveCustomQuota(v)
                        case "member_suggest":
                            let v = TeamLog.MemberSuggestTypeSerializer().deserialize(json)
                            return EventType.memberSuggest(v)
                        case "member_transfer_account_contents":
                            let v = TeamLog.MemberTransferAccountContentsTypeSerializer().deserialize(json)
                            return EventType.memberTransferAccountContents(v)
                        case "secondary_mails_policy_changed":
                            let v = TeamLog.SecondaryMailsPolicyChangedTypeSerializer().deserialize(json)
                            return EventType.secondaryMailsPolicyChanged(v)
                        case "paper_content_add_member":
                            let v = TeamLog.PaperContentAddMemberTypeSerializer().deserialize(json)
                            return EventType.paperContentAddMember(v)
                        case "paper_content_add_to_folder":
                            let v = TeamLog.PaperContentAddToFolderTypeSerializer().deserialize(json)
                            return EventType.paperContentAddToFolder(v)
                        case "paper_content_archive":
                            let v = TeamLog.PaperContentArchiveTypeSerializer().deserialize(json)
                            return EventType.paperContentArchive(v)
                        case "paper_content_create":
                            let v = TeamLog.PaperContentCreateTypeSerializer().deserialize(json)
                            return EventType.paperContentCreate(v)
                        case "paper_content_permanently_delete":
                            let v = TeamLog.PaperContentPermanentlyDeleteTypeSerializer().deserialize(json)
                            return EventType.paperContentPermanentlyDelete(v)
                        case "paper_content_remove_from_folder":
                            let v = TeamLog.PaperContentRemoveFromFolderTypeSerializer().deserialize(json)
                            return EventType.paperContentRemoveFromFolder(v)
                        case "paper_content_remove_member":
                            let v = TeamLog.PaperContentRemoveMemberTypeSerializer().deserialize(json)
                            return EventType.paperContentRemoveMember(v)
                        case "paper_content_rename":
                            let v = TeamLog.PaperContentRenameTypeSerializer().deserialize(json)
                            return EventType.paperContentRename(v)
                        case "paper_content_restore":
                            let v = TeamLog.PaperContentRestoreTypeSerializer().deserialize(json)
                            return EventType.paperContentRestore(v)
                        case "paper_doc_add_comment":
                            let v = TeamLog.PaperDocAddCommentTypeSerializer().deserialize(json)
                            return EventType.paperDocAddComment(v)
                        case "paper_doc_change_member_role":
                            let v = TeamLog.PaperDocChangeMemberRoleTypeSerializer().deserialize(json)
                            return EventType.paperDocChangeMemberRole(v)
                        case "paper_doc_change_sharing_policy":
                            let v = TeamLog.PaperDocChangeSharingPolicyTypeSerializer().deserialize(json)
                            return EventType.paperDocChangeSharingPolicy(v)
                        case "paper_doc_change_subscription":
                            let v = TeamLog.PaperDocChangeSubscriptionTypeSerializer().deserialize(json)
                            return EventType.paperDocChangeSubscription(v)
                        case "paper_doc_deleted":
                            let v = TeamLog.PaperDocDeletedTypeSerializer().deserialize(json)
                            return EventType.paperDocDeleted(v)
                        case "paper_doc_delete_comment":
                            let v = TeamLog.PaperDocDeleteCommentTypeSerializer().deserialize(json)
                            return EventType.paperDocDeleteComment(v)
                        case "paper_doc_download":
                            let v = TeamLog.PaperDocDownloadTypeSerializer().deserialize(json)
                            return EventType.paperDocDownload(v)
                        case "paper_doc_edit":
                            let v = TeamLog.PaperDocEditTypeSerializer().deserialize(json)
                            return EventType.paperDocEdit(v)
                        case "paper_doc_edit_comment":
                            let v = TeamLog.PaperDocEditCommentTypeSerializer().deserialize(json)
                            return EventType.paperDocEditComment(v)
                        case "paper_doc_followed":
                            let v = TeamLog.PaperDocFollowedTypeSerializer().deserialize(json)
                            return EventType.paperDocFollowed(v)
                        case "paper_doc_mention":
                            let v = TeamLog.PaperDocMentionTypeSerializer().deserialize(json)
                            return EventType.paperDocMention(v)
                        case "paper_doc_ownership_changed":
                            let v = TeamLog.PaperDocOwnershipChangedTypeSerializer().deserialize(json)
                            return EventType.paperDocOwnershipChanged(v)
                        case "paper_doc_request_access":
                            let v = TeamLog.PaperDocRequestAccessTypeSerializer().deserialize(json)
                            return EventType.paperDocRequestAccess(v)
                        case "paper_doc_resolve_comment":
                            let v = TeamLog.PaperDocResolveCommentTypeSerializer().deserialize(json)
                            return EventType.paperDocResolveComment(v)
                        case "paper_doc_revert":
                            let v = TeamLog.PaperDocRevertTypeSerializer().deserialize(json)
                            return EventType.paperDocRevert(v)
                        case "paper_doc_slack_share":
                            let v = TeamLog.PaperDocSlackShareTypeSerializer().deserialize(json)
                            return EventType.paperDocSlackShare(v)
                        case "paper_doc_team_invite":
                            let v = TeamLog.PaperDocTeamInviteTypeSerializer().deserialize(json)
                            return EventType.paperDocTeamInvite(v)
                        case "paper_doc_trashed":
                            let v = TeamLog.PaperDocTrashedTypeSerializer().deserialize(json)
                            return EventType.paperDocTrashed(v)
                        case "paper_doc_unresolve_comment":
                            let v = TeamLog.PaperDocUnresolveCommentTypeSerializer().deserialize(json)
                            return EventType.paperDocUnresolveComment(v)
                        case "paper_doc_untrashed":
                            let v = TeamLog.PaperDocUntrashedTypeSerializer().deserialize(json)
                            return EventType.paperDocUntrashed(v)
                        case "paper_doc_view":
                            let v = TeamLog.PaperDocViewTypeSerializer().deserialize(json)
                            return EventType.paperDocView(v)
                        case "paper_external_view_allow":
                            let v = TeamLog.PaperExternalViewAllowTypeSerializer().deserialize(json)
                            return EventType.paperExternalViewAllow(v)
                        case "paper_external_view_default_team":
                            let v = TeamLog.PaperExternalViewDefaultTeamTypeSerializer().deserialize(json)
                            return EventType.paperExternalViewDefaultTeam(v)
                        case "paper_external_view_forbid":
                            let v = TeamLog.PaperExternalViewForbidTypeSerializer().deserialize(json)
                            return EventType.paperExternalViewForbid(v)
                        case "paper_folder_change_subscription":
                            let v = TeamLog.PaperFolderChangeSubscriptionTypeSerializer().deserialize(json)
                            return EventType.paperFolderChangeSubscription(v)
                        case "paper_folder_deleted":
                            let v = TeamLog.PaperFolderDeletedTypeSerializer().deserialize(json)
                            return EventType.paperFolderDeleted(v)
                        case "paper_folder_followed":
                            let v = TeamLog.PaperFolderFollowedTypeSerializer().deserialize(json)
                            return EventType.paperFolderFollowed(v)
                        case "paper_folder_team_invite":
                            let v = TeamLog.PaperFolderTeamInviteTypeSerializer().deserialize(json)
                            return EventType.paperFolderTeamInvite(v)
                        case "password_change":
                            let v = TeamLog.PasswordChangeTypeSerializer().deserialize(json)
                            return EventType.passwordChange(v)
                        case "password_reset":
                            let v = TeamLog.PasswordResetTypeSerializer().deserialize(json)
                            return EventType.passwordReset(v)
                        case "password_reset_all":
                            let v = TeamLog.PasswordResetAllTypeSerializer().deserialize(json)
                            return EventType.passwordResetAll(v)
                        case "emm_create_exceptions_report":
                            let v = TeamLog.EmmCreateExceptionsReportTypeSerializer().deserialize(json)
                            return EventType.emmCreateExceptionsReport(v)
                        case "emm_create_usage_report":
                            let v = TeamLog.EmmCreateUsageReportTypeSerializer().deserialize(json)
                            return EventType.emmCreateUsageReport(v)
                        case "export_members_report":
                            let v = TeamLog.ExportMembersReportTypeSerializer().deserialize(json)
                            return EventType.exportMembersReport(v)
                        case "paper_admin_export_start":
                            let v = TeamLog.PaperAdminExportStartTypeSerializer().deserialize(json)
                            return EventType.paperAdminExportStart(v)
                        case "smart_sync_create_admin_privilege_report":
                            let v = TeamLog.SmartSyncCreateAdminPrivilegeReportTypeSerializer().deserialize(json)
                            return EventType.smartSyncCreateAdminPrivilegeReport(v)
                        case "team_activity_create_report":
                            let v = TeamLog.TeamActivityCreateReportTypeSerializer().deserialize(json)
                            return EventType.teamActivityCreateReport(v)
                        case "collection_share":
                            let v = TeamLog.CollectionShareTypeSerializer().deserialize(json)
                            return EventType.collectionShare(v)
                        case "note_acl_invite_only":
                            let v = TeamLog.NoteAclInviteOnlyTypeSerializer().deserialize(json)
                            return EventType.noteAclInviteOnly(v)
                        case "note_acl_link":
                            let v = TeamLog.NoteAclLinkTypeSerializer().deserialize(json)
                            return EventType.noteAclLink(v)
                        case "note_acl_team_link":
                            let v = TeamLog.NoteAclTeamLinkTypeSerializer().deserialize(json)
                            return EventType.noteAclTeamLink(v)
                        case "note_shared":
                            let v = TeamLog.NoteSharedTypeSerializer().deserialize(json)
                            return EventType.noteShared(v)
                        case "note_share_receive":
                            let v = TeamLog.NoteShareReceiveTypeSerializer().deserialize(json)
                            return EventType.noteShareReceive(v)
                        case "open_note_shared":
                            let v = TeamLog.OpenNoteSharedTypeSerializer().deserialize(json)
                            return EventType.openNoteShared(v)
                        case "sf_add_group":
                            let v = TeamLog.SfAddGroupTypeSerializer().deserialize(json)
                            return EventType.sfAddGroup(v)
                        case "sf_allow_non_members_to_view_shared_links":
                            let v = TeamLog.SfAllowNonMembersToViewSharedLinksTypeSerializer().deserialize(json)
                            return EventType.sfAllowNonMembersToViewSharedLinks(v)
                        case "sf_external_invite_warn":
                            let v = TeamLog.SfExternalInviteWarnTypeSerializer().deserialize(json)
                            return EventType.sfExternalInviteWarn(v)
                        case "sf_fb_invite":
                            let v = TeamLog.SfFbInviteTypeSerializer().deserialize(json)
                            return EventType.sfFbInvite(v)
                        case "sf_fb_invite_change_role":
                            let v = TeamLog.SfFbInviteChangeRoleTypeSerializer().deserialize(json)
                            return EventType.sfFbInviteChangeRole(v)
                        case "sf_fb_uninvite":
                            let v = TeamLog.SfFbUninviteTypeSerializer().deserialize(json)
                            return EventType.sfFbUninvite(v)
                        case "sf_invite_group":
                            let v = TeamLog.SfInviteGroupTypeSerializer().deserialize(json)
                            return EventType.sfInviteGroup(v)
                        case "sf_team_grant_access":
                            let v = TeamLog.SfTeamGrantAccessTypeSerializer().deserialize(json)
                            return EventType.sfTeamGrantAccess(v)
                        case "sf_team_invite":
                            let v = TeamLog.SfTeamInviteTypeSerializer().deserialize(json)
                            return EventType.sfTeamInvite(v)
                        case "sf_team_invite_change_role":
                            let v = TeamLog.SfTeamInviteChangeRoleTypeSerializer().deserialize(json)
                            return EventType.sfTeamInviteChangeRole(v)
                        case "sf_team_join":
                            let v = TeamLog.SfTeamJoinTypeSerializer().deserialize(json)
                            return EventType.sfTeamJoin(v)
                        case "sf_team_join_from_oob_link":
                            let v = TeamLog.SfTeamJoinFromOobLinkTypeSerializer().deserialize(json)
                            return EventType.sfTeamJoinFromOobLink(v)
                        case "sf_team_uninvite":
                            let v = TeamLog.SfTeamUninviteTypeSerializer().deserialize(json)
                            return EventType.sfTeamUninvite(v)
                        case "shared_content_add_invitees":
                            let v = TeamLog.SharedContentAddInviteesTypeSerializer().deserialize(json)
                            return EventType.sharedContentAddInvitees(v)
                        case "shared_content_add_link_expiry":
                            let v = TeamLog.SharedContentAddLinkExpiryTypeSerializer().deserialize(json)
                            return EventType.sharedContentAddLinkExpiry(v)
                        case "shared_content_add_link_password":
                            let v = TeamLog.SharedContentAddLinkPasswordTypeSerializer().deserialize(json)
                            return EventType.sharedContentAddLinkPassword(v)
                        case "shared_content_add_member":
                            let v = TeamLog.SharedContentAddMemberTypeSerializer().deserialize(json)
                            return EventType.sharedContentAddMember(v)
                        case "shared_content_change_downloads_policy":
                            let v = TeamLog.SharedContentChangeDownloadsPolicyTypeSerializer().deserialize(json)
                            return EventType.sharedContentChangeDownloadsPolicy(v)
                        case "shared_content_change_invitee_role":
                            let v = TeamLog.SharedContentChangeInviteeRoleTypeSerializer().deserialize(json)
                            return EventType.sharedContentChangeInviteeRole(v)
                        case "shared_content_change_link_audience":
                            let v = TeamLog.SharedContentChangeLinkAudienceTypeSerializer().deserialize(json)
                            return EventType.sharedContentChangeLinkAudience(v)
                        case "shared_content_change_link_expiry":
                            let v = TeamLog.SharedContentChangeLinkExpiryTypeSerializer().deserialize(json)
                            return EventType.sharedContentChangeLinkExpiry(v)
                        case "shared_content_change_link_password":
                            let v = TeamLog.SharedContentChangeLinkPasswordTypeSerializer().deserialize(json)
                            return EventType.sharedContentChangeLinkPassword(v)
                        case "shared_content_change_member_role":
                            let v = TeamLog.SharedContentChangeMemberRoleTypeSerializer().deserialize(json)
                            return EventType.sharedContentChangeMemberRole(v)
                        case "shared_content_change_viewer_info_policy":
                            let v = TeamLog.SharedContentChangeViewerInfoPolicyTypeSerializer().deserialize(json)
                            return EventType.sharedContentChangeViewerInfoPolicy(v)
                        case "shared_content_claim_invitation":
                            let v = TeamLog.SharedContentClaimInvitationTypeSerializer().deserialize(json)
                            return EventType.sharedContentClaimInvitation(v)
                        case "shared_content_copy":
                            let v = TeamLog.SharedContentCopyTypeSerializer().deserialize(json)
                            return EventType.sharedContentCopy(v)
                        case "shared_content_download":
                            let v = TeamLog.SharedContentDownloadTypeSerializer().deserialize(json)
                            return EventType.sharedContentDownload(v)
                        case "shared_content_relinquish_membership":
                            let v = TeamLog.SharedContentRelinquishMembershipTypeSerializer().deserialize(json)
                            return EventType.sharedContentRelinquishMembership(v)
                        case "shared_content_remove_invitees":
                            let v = TeamLog.SharedContentRemoveInviteesTypeSerializer().deserialize(json)
                            return EventType.sharedContentRemoveInvitees(v)
                        case "shared_content_remove_link_expiry":
                            let v = TeamLog.SharedContentRemoveLinkExpiryTypeSerializer().deserialize(json)
                            return EventType.sharedContentRemoveLinkExpiry(v)
                        case "shared_content_remove_link_password":
                            let v = TeamLog.SharedContentRemoveLinkPasswordTypeSerializer().deserialize(json)
                            return EventType.sharedContentRemoveLinkPassword(v)
                        case "shared_content_remove_member":
                            let v = TeamLog.SharedContentRemoveMemberTypeSerializer().deserialize(json)
                            return EventType.sharedContentRemoveMember(v)
                        case "shared_content_request_access":
                            let v = TeamLog.SharedContentRequestAccessTypeSerializer().deserialize(json)
                            return EventType.sharedContentRequestAccess(v)
                        case "shared_content_unshare":
                            let v = TeamLog.SharedContentUnshareTypeSerializer().deserialize(json)
                            return EventType.sharedContentUnshare(v)
                        case "shared_content_view":
                            let v = TeamLog.SharedContentViewTypeSerializer().deserialize(json)
                            return EventType.sharedContentView(v)
                        case "shared_folder_change_link_policy":
                            let v = TeamLog.SharedFolderChangeLinkPolicyTypeSerializer().deserialize(json)
                            return EventType.sharedFolderChangeLinkPolicy(v)
                        case "shared_folder_change_members_inheritance_policy":
                            let v = TeamLog.SharedFolderChangeMembersInheritancePolicyTypeSerializer().deserialize(json)
                            return EventType.sharedFolderChangeMembersInheritancePolicy(v)
                        case "shared_folder_change_members_management_policy":
                            let v = TeamLog.SharedFolderChangeMembersManagementPolicyTypeSerializer().deserialize(json)
                            return EventType.sharedFolderChangeMembersManagementPolicy(v)
                        case "shared_folder_change_members_policy":
                            let v = TeamLog.SharedFolderChangeMembersPolicyTypeSerializer().deserialize(json)
                            return EventType.sharedFolderChangeMembersPolicy(v)
                        case "shared_folder_create":
                            let v = TeamLog.SharedFolderCreateTypeSerializer().deserialize(json)
                            return EventType.sharedFolderCreate(v)
                        case "shared_folder_decline_invitation":
                            let v = TeamLog.SharedFolderDeclineInvitationTypeSerializer().deserialize(json)
                            return EventType.sharedFolderDeclineInvitation(v)
                        case "shared_folder_mount":
                            let v = TeamLog.SharedFolderMountTypeSerializer().deserialize(json)
                            return EventType.sharedFolderMount(v)
                        case "shared_folder_nest":
                            let v = TeamLog.SharedFolderNestTypeSerializer().deserialize(json)
                            return EventType.sharedFolderNest(v)
                        case "shared_folder_transfer_ownership":
                            let v = TeamLog.SharedFolderTransferOwnershipTypeSerializer().deserialize(json)
                            return EventType.sharedFolderTransferOwnership(v)
                        case "shared_folder_unmount":
                            let v = TeamLog.SharedFolderUnmountTypeSerializer().deserialize(json)
                            return EventType.sharedFolderUnmount(v)
                        case "shared_link_add_expiry":
                            let v = TeamLog.SharedLinkAddExpiryTypeSerializer().deserialize(json)
                            return EventType.sharedLinkAddExpiry(v)
                        case "shared_link_change_expiry":
                            let v = TeamLog.SharedLinkChangeExpiryTypeSerializer().deserialize(json)
                            return EventType.sharedLinkChangeExpiry(v)
                        case "shared_link_change_visibility":
                            let v = TeamLog.SharedLinkChangeVisibilityTypeSerializer().deserialize(json)
                            return EventType.sharedLinkChangeVisibility(v)
                        case "shared_link_copy":
                            let v = TeamLog.SharedLinkCopyTypeSerializer().deserialize(json)
                            return EventType.sharedLinkCopy(v)
                        case "shared_link_create":
                            let v = TeamLog.SharedLinkCreateTypeSerializer().deserialize(json)
                            return EventType.sharedLinkCreate(v)
                        case "shared_link_disable":
                            let v = TeamLog.SharedLinkDisableTypeSerializer().deserialize(json)
                            return EventType.sharedLinkDisable(v)
                        case "shared_link_download":
                            let v = TeamLog.SharedLinkDownloadTypeSerializer().deserialize(json)
                            return EventType.sharedLinkDownload(v)
                        case "shared_link_remove_expiry":
                            let v = TeamLog.SharedLinkRemoveExpiryTypeSerializer().deserialize(json)
                            return EventType.sharedLinkRemoveExpiry(v)
                        case "shared_link_share":
                            let v = TeamLog.SharedLinkShareTypeSerializer().deserialize(json)
                            return EventType.sharedLinkShare(v)
                        case "shared_link_view":
                            let v = TeamLog.SharedLinkViewTypeSerializer().deserialize(json)
                            return EventType.sharedLinkView(v)
                        case "shared_note_opened":
                            let v = TeamLog.SharedNoteOpenedTypeSerializer().deserialize(json)
                            return EventType.sharedNoteOpened(v)
                        case "shmodel_group_share":
                            let v = TeamLog.ShmodelGroupShareTypeSerializer().deserialize(json)
                            return EventType.shmodelGroupShare(v)
                        case "showcase_access_granted":
                            let v = TeamLog.ShowcaseAccessGrantedTypeSerializer().deserialize(json)
                            return EventType.showcaseAccessGranted(v)
                        case "showcase_add_member":
                            let v = TeamLog.ShowcaseAddMemberTypeSerializer().deserialize(json)
                            return EventType.showcaseAddMember(v)
                        case "showcase_archived":
                            let v = TeamLog.ShowcaseArchivedTypeSerializer().deserialize(json)
                            return EventType.showcaseArchived(v)
                        case "showcase_created":
                            let v = TeamLog.ShowcaseCreatedTypeSerializer().deserialize(json)
                            return EventType.showcaseCreated(v)
                        case "showcase_delete_comment":
                            let v = TeamLog.ShowcaseDeleteCommentTypeSerializer().deserialize(json)
                            return EventType.showcaseDeleteComment(v)
                        case "showcase_edited":
                            let v = TeamLog.ShowcaseEditedTypeSerializer().deserialize(json)
                            return EventType.showcaseEdited(v)
                        case "showcase_edit_comment":
                            let v = TeamLog.ShowcaseEditCommentTypeSerializer().deserialize(json)
                            return EventType.showcaseEditComment(v)
                        case "showcase_file_added":
                            let v = TeamLog.ShowcaseFileAddedTypeSerializer().deserialize(json)
                            return EventType.showcaseFileAdded(v)
                        case "showcase_file_download":
                            let v = TeamLog.ShowcaseFileDownloadTypeSerializer().deserialize(json)
                            return EventType.showcaseFileDownload(v)
                        case "showcase_file_removed":
                            let v = TeamLog.ShowcaseFileRemovedTypeSerializer().deserialize(json)
                            return EventType.showcaseFileRemoved(v)
                        case "showcase_file_view":
                            let v = TeamLog.ShowcaseFileViewTypeSerializer().deserialize(json)
                            return EventType.showcaseFileView(v)
                        case "showcase_permanently_deleted":
                            let v = TeamLog.ShowcasePermanentlyDeletedTypeSerializer().deserialize(json)
                            return EventType.showcasePermanentlyDeleted(v)
                        case "showcase_post_comment":
                            let v = TeamLog.ShowcasePostCommentTypeSerializer().deserialize(json)
                            return EventType.showcasePostComment(v)
                        case "showcase_remove_member":
                            let v = TeamLog.ShowcaseRemoveMemberTypeSerializer().deserialize(json)
                            return EventType.showcaseRemoveMember(v)
                        case "showcase_renamed":
                            let v = TeamLog.ShowcaseRenamedTypeSerializer().deserialize(json)
                            return EventType.showcaseRenamed(v)
                        case "showcase_request_access":
                            let v = TeamLog.ShowcaseRequestAccessTypeSerializer().deserialize(json)
                            return EventType.showcaseRequestAccess(v)
                        case "showcase_resolve_comment":
                            let v = TeamLog.ShowcaseResolveCommentTypeSerializer().deserialize(json)
                            return EventType.showcaseResolveComment(v)
                        case "showcase_restored":
                            let v = TeamLog.ShowcaseRestoredTypeSerializer().deserialize(json)
                            return EventType.showcaseRestored(v)
                        case "showcase_trashed":
                            let v = TeamLog.ShowcaseTrashedTypeSerializer().deserialize(json)
                            return EventType.showcaseTrashed(v)
                        case "showcase_trashed_deprecated":
                            let v = TeamLog.ShowcaseTrashedDeprecatedTypeSerializer().deserialize(json)
                            return EventType.showcaseTrashedDeprecated(v)
                        case "showcase_unresolve_comment":
                            let v = TeamLog.ShowcaseUnresolveCommentTypeSerializer().deserialize(json)
                            return EventType.showcaseUnresolveComment(v)
                        case "showcase_untrashed":
                            let v = TeamLog.ShowcaseUntrashedTypeSerializer().deserialize(json)
                            return EventType.showcaseUntrashed(v)
                        case "showcase_untrashed_deprecated":
                            let v = TeamLog.ShowcaseUntrashedDeprecatedTypeSerializer().deserialize(json)
                            return EventType.showcaseUntrashedDeprecated(v)
                        case "showcase_view":
                            let v = TeamLog.ShowcaseViewTypeSerializer().deserialize(json)
                            return EventType.showcaseView(v)
                        case "sso_add_cert":
                            let v = TeamLog.SsoAddCertTypeSerializer().deserialize(json)
                            return EventType.ssoAddCert(v)
                        case "sso_add_login_url":
                            let v = TeamLog.SsoAddLoginUrlTypeSerializer().deserialize(json)
                            return EventType.ssoAddLoginUrl(v)
                        case "sso_add_logout_url":
                            let v = TeamLog.SsoAddLogoutUrlTypeSerializer().deserialize(json)
                            return EventType.ssoAddLogoutUrl(v)
                        case "sso_change_cert":
                            let v = TeamLog.SsoChangeCertTypeSerializer().deserialize(json)
                            return EventType.ssoChangeCert(v)
                        case "sso_change_login_url":
                            let v = TeamLog.SsoChangeLoginUrlTypeSerializer().deserialize(json)
                            return EventType.ssoChangeLoginUrl(v)
                        case "sso_change_logout_url":
                            let v = TeamLog.SsoChangeLogoutUrlTypeSerializer().deserialize(json)
                            return EventType.ssoChangeLogoutUrl(v)
                        case "sso_change_saml_identity_mode":
                            let v = TeamLog.SsoChangeSamlIdentityModeTypeSerializer().deserialize(json)
                            return EventType.ssoChangeSamlIdentityMode(v)
                        case "sso_remove_cert":
                            let v = TeamLog.SsoRemoveCertTypeSerializer().deserialize(json)
                            return EventType.ssoRemoveCert(v)
                        case "sso_remove_login_url":
                            let v = TeamLog.SsoRemoveLoginUrlTypeSerializer().deserialize(json)
                            return EventType.ssoRemoveLoginUrl(v)
                        case "sso_remove_logout_url":
                            let v = TeamLog.SsoRemoveLogoutUrlTypeSerializer().deserialize(json)
                            return EventType.ssoRemoveLogoutUrl(v)
                        case "team_folder_change_status":
                            let v = TeamLog.TeamFolderChangeStatusTypeSerializer().deserialize(json)
                            return EventType.teamFolderChangeStatus(v)
                        case "team_folder_create":
                            let v = TeamLog.TeamFolderCreateTypeSerializer().deserialize(json)
                            return EventType.teamFolderCreate(v)
                        case "team_folder_downgrade":
                            let v = TeamLog.TeamFolderDowngradeTypeSerializer().deserialize(json)
                            return EventType.teamFolderDowngrade(v)
                        case "team_folder_permanently_delete":
                            let v = TeamLog.TeamFolderPermanentlyDeleteTypeSerializer().deserialize(json)
                            return EventType.teamFolderPermanentlyDelete(v)
                        case "team_folder_rename":
                            let v = TeamLog.TeamFolderRenameTypeSerializer().deserialize(json)
                            return EventType.teamFolderRename(v)
                        case "team_selective_sync_settings_changed":
                            let v = TeamLog.TeamSelectiveSyncSettingsChangedTypeSerializer().deserialize(json)
                            return EventType.teamSelectiveSyncSettingsChanged(v)
                        case "account_capture_change_policy":
                            let v = TeamLog.AccountCaptureChangePolicyTypeSerializer().deserialize(json)
                            return EventType.accountCaptureChangePolicy(v)
                        case "allow_download_disabled":
                            let v = TeamLog.AllowDownloadDisabledTypeSerializer().deserialize(json)
                            return EventType.allowDownloadDisabled(v)
                        case "allow_download_enabled":
                            let v = TeamLog.AllowDownloadEnabledTypeSerializer().deserialize(json)
                            return EventType.allowDownloadEnabled(v)
                        case "camera_uploads_policy_changed":
                            let v = TeamLog.CameraUploadsPolicyChangedTypeSerializer().deserialize(json)
                            return EventType.cameraUploadsPolicyChanged(v)
                        case "data_placement_restriction_change_policy":
                            let v = TeamLog.DataPlacementRestrictionChangePolicyTypeSerializer().deserialize(json)
                            return EventType.dataPlacementRestrictionChangePolicy(v)
                        case "data_placement_restriction_satisfy_policy":
                            let v = TeamLog.DataPlacementRestrictionSatisfyPolicyTypeSerializer().deserialize(json)
                            return EventType.dataPlacementRestrictionSatisfyPolicy(v)
                        case "device_approvals_change_desktop_policy":
                            let v = TeamLog.DeviceApprovalsChangeDesktopPolicyTypeSerializer().deserialize(json)
                            return EventType.deviceApprovalsChangeDesktopPolicy(v)
                        case "device_approvals_change_mobile_policy":
                            let v = TeamLog.DeviceApprovalsChangeMobilePolicyTypeSerializer().deserialize(json)
                            return EventType.deviceApprovalsChangeMobilePolicy(v)
                        case "device_approvals_change_overage_action":
                            let v = TeamLog.DeviceApprovalsChangeOverageActionTypeSerializer().deserialize(json)
                            return EventType.deviceApprovalsChangeOverageAction(v)
                        case "device_approvals_change_unlink_action":
                            let v = TeamLog.DeviceApprovalsChangeUnlinkActionTypeSerializer().deserialize(json)
                            return EventType.deviceApprovalsChangeUnlinkAction(v)
                        case "directory_restrictions_add_members":
                            let v = TeamLog.DirectoryRestrictionsAddMembersTypeSerializer().deserialize(json)
                            return EventType.directoryRestrictionsAddMembers(v)
                        case "directory_restrictions_remove_members":
                            let v = TeamLog.DirectoryRestrictionsRemoveMembersTypeSerializer().deserialize(json)
                            return EventType.directoryRestrictionsRemoveMembers(v)
                        case "emm_add_exception":
                            let v = TeamLog.EmmAddExceptionTypeSerializer().deserialize(json)
                            return EventType.emmAddException(v)
                        case "emm_change_policy":
                            let v = TeamLog.EmmChangePolicyTypeSerializer().deserialize(json)
                            return EventType.emmChangePolicy(v)
                        case "emm_remove_exception":
                            let v = TeamLog.EmmRemoveExceptionTypeSerializer().deserialize(json)
                            return EventType.emmRemoveException(v)
                        case "extended_version_history_change_policy":
                            let v = TeamLog.ExtendedVersionHistoryChangePolicyTypeSerializer().deserialize(json)
                            return EventType.extendedVersionHistoryChangePolicy(v)
                        case "file_comments_change_policy":
                            let v = TeamLog.FileCommentsChangePolicyTypeSerializer().deserialize(json)
                            return EventType.fileCommentsChangePolicy(v)
                        case "file_requests_change_policy":
                            let v = TeamLog.FileRequestsChangePolicyTypeSerializer().deserialize(json)
                            return EventType.fileRequestsChangePolicy(v)
                        case "file_requests_emails_enabled":
                            let v = TeamLog.FileRequestsEmailsEnabledTypeSerializer().deserialize(json)
                            return EventType.fileRequestsEmailsEnabled(v)
                        case "file_requests_emails_restricted_to_team_only":
                            let v = TeamLog.FileRequestsEmailsRestrictedToTeamOnlyTypeSerializer().deserialize(json)
                            return EventType.fileRequestsEmailsRestrictedToTeamOnly(v)
                        case "google_sso_change_policy":
                            let v = TeamLog.GoogleSsoChangePolicyTypeSerializer().deserialize(json)
                            return EventType.googleSsoChangePolicy(v)
                        case "group_user_management_change_policy":
                            let v = TeamLog.GroupUserManagementChangePolicyTypeSerializer().deserialize(json)
                            return EventType.groupUserManagementChangePolicy(v)
                        case "member_requests_change_policy":
                            let v = TeamLog.MemberRequestsChangePolicyTypeSerializer().deserialize(json)
                            return EventType.memberRequestsChangePolicy(v)
                        case "member_space_limits_add_exception":
                            let v = TeamLog.MemberSpaceLimitsAddExceptionTypeSerializer().deserialize(json)
                            return EventType.memberSpaceLimitsAddException(v)
                        case "member_space_limits_change_caps_type_policy":
                            let v = TeamLog.MemberSpaceLimitsChangeCapsTypePolicyTypeSerializer().deserialize(json)
                            return EventType.memberSpaceLimitsChangeCapsTypePolicy(v)
                        case "member_space_limits_change_policy":
                            let v = TeamLog.MemberSpaceLimitsChangePolicyTypeSerializer().deserialize(json)
                            return EventType.memberSpaceLimitsChangePolicy(v)
                        case "member_space_limits_remove_exception":
                            let v = TeamLog.MemberSpaceLimitsRemoveExceptionTypeSerializer().deserialize(json)
                            return EventType.memberSpaceLimitsRemoveException(v)
                        case "member_suggestions_change_policy":
                            let v = TeamLog.MemberSuggestionsChangePolicyTypeSerializer().deserialize(json)
                            return EventType.memberSuggestionsChangePolicy(v)
                        case "microsoft_office_addin_change_policy":
                            let v = TeamLog.MicrosoftOfficeAddinChangePolicyTypeSerializer().deserialize(json)
                            return EventType.microsoftOfficeAddinChangePolicy(v)
                        case "network_control_change_policy":
                            let v = TeamLog.NetworkControlChangePolicyTypeSerializer().deserialize(json)
                            return EventType.networkControlChangePolicy(v)
                        case "paper_change_deployment_policy":
                            let v = TeamLog.PaperChangeDeploymentPolicyTypeSerializer().deserialize(json)
                            return EventType.paperChangeDeploymentPolicy(v)
                        case "paper_change_member_link_policy":
                            let v = TeamLog.PaperChangeMemberLinkPolicyTypeSerializer().deserialize(json)
                            return EventType.paperChangeMemberLinkPolicy(v)
                        case "paper_change_member_policy":
                            let v = TeamLog.PaperChangeMemberPolicyTypeSerializer().deserialize(json)
                            return EventType.paperChangeMemberPolicy(v)
                        case "paper_change_policy":
                            let v = TeamLog.PaperChangePolicyTypeSerializer().deserialize(json)
                            return EventType.paperChangePolicy(v)
                        case "paper_enabled_users_group_addition":
                            let v = TeamLog.PaperEnabledUsersGroupAdditionTypeSerializer().deserialize(json)
                            return EventType.paperEnabledUsersGroupAddition(v)
                        case "paper_enabled_users_group_removal":
                            let v = TeamLog.PaperEnabledUsersGroupRemovalTypeSerializer().deserialize(json)
                            return EventType.paperEnabledUsersGroupRemoval(v)
                        case "permanent_delete_change_policy":
                            let v = TeamLog.PermanentDeleteChangePolicyTypeSerializer().deserialize(json)
                            return EventType.permanentDeleteChangePolicy(v)
                        case "sharing_change_folder_join_policy":
                            let v = TeamLog.SharingChangeFolderJoinPolicyTypeSerializer().deserialize(json)
                            return EventType.sharingChangeFolderJoinPolicy(v)
                        case "sharing_change_link_policy":
                            let v = TeamLog.SharingChangeLinkPolicyTypeSerializer().deserialize(json)
                            return EventType.sharingChangeLinkPolicy(v)
                        case "sharing_change_member_policy":
                            let v = TeamLog.SharingChangeMemberPolicyTypeSerializer().deserialize(json)
                            return EventType.sharingChangeMemberPolicy(v)
                        case "showcase_change_download_policy":
                            let v = TeamLog.ShowcaseChangeDownloadPolicyTypeSerializer().deserialize(json)
                            return EventType.showcaseChangeDownloadPolicy(v)
                        case "showcase_change_enabled_policy":
                            let v = TeamLog.ShowcaseChangeEnabledPolicyTypeSerializer().deserialize(json)
                            return EventType.showcaseChangeEnabledPolicy(v)
                        case "showcase_change_external_sharing_policy":
                            let v = TeamLog.ShowcaseChangeExternalSharingPolicyTypeSerializer().deserialize(json)
                            return EventType.showcaseChangeExternalSharingPolicy(v)
                        case "smart_sync_change_policy":
                            let v = TeamLog.SmartSyncChangePolicyTypeSerializer().deserialize(json)
                            return EventType.smartSyncChangePolicy(v)
                        case "smart_sync_not_opt_out":
                            let v = TeamLog.SmartSyncNotOptOutTypeSerializer().deserialize(json)
                            return EventType.smartSyncNotOptOut(v)
                        case "smart_sync_opt_out":
                            let v = TeamLog.SmartSyncOptOutTypeSerializer().deserialize(json)
                            return EventType.smartSyncOptOut(v)
                        case "sso_change_policy":
                            let v = TeamLog.SsoChangePolicyTypeSerializer().deserialize(json)
                            return EventType.ssoChangePolicy(v)
                        case "team_selective_sync_policy_changed":
                            let v = TeamLog.TeamSelectiveSyncPolicyChangedTypeSerializer().deserialize(json)
                            return EventType.teamSelectiveSyncPolicyChanged(v)
                        case "tfa_change_policy":
                            let v = TeamLog.TfaChangePolicyTypeSerializer().deserialize(json)
                            return EventType.tfaChangePolicy(v)
                        case "two_account_change_policy":
                            let v = TeamLog.TwoAccountChangePolicyTypeSerializer().deserialize(json)
                            return EventType.twoAccountChangePolicy(v)
                        case "viewer_info_policy_changed":
                            let v = TeamLog.ViewerInfoPolicyChangedTypeSerializer().deserialize(json)
                            return EventType.viewerInfoPolicyChanged(v)
                        case "web_sessions_change_fixed_length_policy":
                            let v = TeamLog.WebSessionsChangeFixedLengthPolicyTypeSerializer().deserialize(json)
                            return EventType.webSessionsChangeFixedLengthPolicy(v)
                        case "web_sessions_change_idle_length_policy":
                            let v = TeamLog.WebSessionsChangeIdleLengthPolicyTypeSerializer().deserialize(json)
                            return EventType.webSessionsChangeIdleLengthPolicy(v)
                        case "team_merge_from":
                            let v = TeamLog.TeamMergeFromTypeSerializer().deserialize(json)
                            return EventType.teamMergeFrom(v)
                        case "team_merge_to":
                            let v = TeamLog.TeamMergeToTypeSerializer().deserialize(json)
                            return EventType.teamMergeTo(v)
                        case "team_profile_add_logo":
                            let v = TeamLog.TeamProfileAddLogoTypeSerializer().deserialize(json)
                            return EventType.teamProfileAddLogo(v)
                        case "team_profile_change_default_language":
                            let v = TeamLog.TeamProfileChangeDefaultLanguageTypeSerializer().deserialize(json)
                            return EventType.teamProfileChangeDefaultLanguage(v)
                        case "team_profile_change_logo":
                            let v = TeamLog.TeamProfileChangeLogoTypeSerializer().deserialize(json)
                            return EventType.teamProfileChangeLogo(v)
                        case "team_profile_change_name":
                            let v = TeamLog.TeamProfileChangeNameTypeSerializer().deserialize(json)
                            return EventType.teamProfileChangeName(v)
                        case "team_profile_remove_logo":
                            let v = TeamLog.TeamProfileRemoveLogoTypeSerializer().deserialize(json)
                            return EventType.teamProfileRemoveLogo(v)
                        case "tfa_add_backup_phone":
                            let v = TeamLog.TfaAddBackupPhoneTypeSerializer().deserialize(json)
                            return EventType.tfaAddBackupPhone(v)
                        case "tfa_add_security_key":
                            let v = TeamLog.TfaAddSecurityKeyTypeSerializer().deserialize(json)
                            return EventType.tfaAddSecurityKey(v)
                        case "tfa_change_backup_phone":
                            let v = TeamLog.TfaChangeBackupPhoneTypeSerializer().deserialize(json)
                            return EventType.tfaChangeBackupPhone(v)
                        case "tfa_change_status":
                            let v = TeamLog.TfaChangeStatusTypeSerializer().deserialize(json)
                            return EventType.tfaChangeStatus(v)
                        case "tfa_remove_backup_phone":
                            let v = TeamLog.TfaRemoveBackupPhoneTypeSerializer().deserialize(json)
                            return EventType.tfaRemoveBackupPhone(v)
                        case "tfa_remove_security_key":
                            let v = TeamLog.TfaRemoveSecurityKeyTypeSerializer().deserialize(json)
                            return EventType.tfaRemoveSecurityKey(v)
                        case "tfa_reset":
                            let v = TeamLog.TfaResetTypeSerializer().deserialize(json)
                            return EventType.tfaReset(v)
                        case "other":
                            return EventType.other
                        default:
                            return EventType.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Created member data report.
    open class ExportMembersReportDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ExportMembersReportDetailsSerializer().serialize(self)))"
        }
    }
    open class ExportMembersReportDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ExportMembersReportDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ExportMembersReportDetails {
            switch json {
                case .dictionary(_):
                    return ExportMembersReportDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ExportMembersReportType struct
    open class ExportMembersReportType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ExportMembersReportTypeSerializer().serialize(self)))"
        }
    }
    open class ExportMembersReportTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ExportMembersReportType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ExportMembersReportType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return ExportMembersReportType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Accepted/opted out of extended version history.
    open class ExtendedVersionHistoryChangePolicyDetails: CustomStringConvertible {
        /// New extended version history policy.
        public let newValue: TeamLog.ExtendedVersionHistoryPolicy
        /// Previous extended version history policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.ExtendedVersionHistoryPolicy?
        public init(newValue: TeamLog.ExtendedVersionHistoryPolicy, previousValue: TeamLog.ExtendedVersionHistoryPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ExtendedVersionHistoryChangePolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class ExtendedVersionHistoryChangePolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ExtendedVersionHistoryChangePolicyDetails) -> JSON {
            let output = [ 
            "new_value": TeamLog.ExtendedVersionHistoryPolicySerializer().serialize(value.newValue),
            "previous_value": NullableSerializer(TeamLog.ExtendedVersionHistoryPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ExtendedVersionHistoryChangePolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = TeamLog.ExtendedVersionHistoryPolicySerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(TeamLog.ExtendedVersionHistoryPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                    return ExtendedVersionHistoryChangePolicyDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ExtendedVersionHistoryChangePolicyType struct
    open class ExtendedVersionHistoryChangePolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ExtendedVersionHistoryChangePolicyTypeSerializer().serialize(self)))"
        }
    }
    open class ExtendedVersionHistoryChangePolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ExtendedVersionHistoryChangePolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ExtendedVersionHistoryChangePolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return ExtendedVersionHistoryChangePolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ExtendedVersionHistoryPolicy union
    public enum ExtendedVersionHistoryPolicy: CustomStringConvertible {
        /// An unspecified error.
        case explicitlyLimited
        /// An unspecified error.
        case explicitlyUnlimited
        /// An unspecified error.
        case implicitlyLimited
        /// An unspecified error.
        case implicitlyUnlimited
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ExtendedVersionHistoryPolicySerializer().serialize(self)))"
        }
    }
    open class ExtendedVersionHistoryPolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ExtendedVersionHistoryPolicy) -> JSON {
            switch value {
                case .explicitlyLimited:
                    var d = [String: JSON]()
                    d[".tag"] = .str("explicitly_limited")
                    return .dictionary(d)
                case .explicitlyUnlimited:
                    var d = [String: JSON]()
                    d[".tag"] = .str("explicitly_unlimited")
                    return .dictionary(d)
                case .implicitlyLimited:
                    var d = [String: JSON]()
                    d[".tag"] = .str("implicitly_limited")
                    return .dictionary(d)
                case .implicitlyUnlimited:
                    var d = [String: JSON]()
                    d[".tag"] = .str("implicitly_unlimited")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ExtendedVersionHistoryPolicy {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "explicitly_limited":
                            return ExtendedVersionHistoryPolicy.explicitlyLimited
                        case "explicitly_unlimited":
                            return ExtendedVersionHistoryPolicy.explicitlyUnlimited
                        case "implicitly_limited":
                            return ExtendedVersionHistoryPolicy.implicitlyLimited
                        case "implicitly_unlimited":
                            return ExtendedVersionHistoryPolicy.implicitlyUnlimited
                        case "other":
                            return ExtendedVersionHistoryPolicy.other
                        default:
                            return ExtendedVersionHistoryPolicy.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// A user without a Dropbox account.
    open class ExternalUserLogInfo: CustomStringConvertible {
        /// An external user identifier.
        public let userIdentifier: String
        /// Identifier type.
        public let identifierType: TeamLog.IdentifierType
        public init(userIdentifier: String, identifierType: TeamLog.IdentifierType) {
            stringValidator()(userIdentifier)
            self.userIdentifier = userIdentifier
            self.identifierType = identifierType
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ExternalUserLogInfoSerializer().serialize(self)))"
        }
    }
    open class ExternalUserLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ExternalUserLogInfo) -> JSON {
            let output = [ 
            "user_identifier": Serialization._StringSerializer.serialize(value.userIdentifier),
            "identifier_type": TeamLog.IdentifierTypeSerializer().serialize(value.identifierType),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ExternalUserLogInfo {
            switch json {
                case .dictionary(let dict):
                    let userIdentifier = Serialization._StringSerializer.deserialize(dict["user_identifier"] ?? .null)
                    let identifierType = TeamLog.IdentifierTypeSerializer().deserialize(dict["identifier_type"] ?? .null)
                    return ExternalUserLogInfo(userIdentifier: userIdentifier, identifierType: identifierType)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Provides details about a failure
    open class FailureDetailsLogInfo: CustomStringConvertible {
        /// A user friendly explanation of the error. Might be missing due to historical data gap.
        public let userFriendlyMessage: String?
        /// A technical explanation of the error. This is relevant for some errors.
        public let technicalErrorMessage: String?
        public init(userFriendlyMessage: String? = nil, technicalErrorMessage: String? = nil) {
            nullableValidator(stringValidator())(userFriendlyMessage)
            self.userFriendlyMessage = userFriendlyMessage
            nullableValidator(stringValidator())(technicalErrorMessage)
            self.technicalErrorMessage = technicalErrorMessage
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FailureDetailsLogInfoSerializer().serialize(self)))"
        }
    }
    open class FailureDetailsLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FailureDetailsLogInfo) -> JSON {
            let output = [ 
            "user_friendly_message": NullableSerializer(Serialization._StringSerializer).serialize(value.userFriendlyMessage),
            "technical_error_message": NullableSerializer(Serialization._StringSerializer).serialize(value.technicalErrorMessage),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FailureDetailsLogInfo {
            switch json {
                case .dictionary(let dict):
                    let userFriendlyMessage = NullableSerializer(Serialization._StringSerializer).deserialize(dict["user_friendly_message"] ?? .null)
                    let technicalErrorMessage = NullableSerializer(Serialization._StringSerializer).deserialize(dict["technical_error_message"] ?? .null)
                    return FailureDetailsLogInfo(userFriendlyMessage: userFriendlyMessage, technicalErrorMessage: technicalErrorMessage)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Added file comment.
    open class FileAddCommentDetails: CustomStringConvertible {
        /// Comment text. Might be missing due to historical data gap.
        public let commentText: String?
        public init(commentText: String? = nil) {
            nullableValidator(stringValidator())(commentText)
            self.commentText = commentText
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileAddCommentDetailsSerializer().serialize(self)))"
        }
    }
    open class FileAddCommentDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileAddCommentDetails) -> JSON {
            let output = [ 
            "comment_text": NullableSerializer(Serialization._StringSerializer).serialize(value.commentText),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileAddCommentDetails {
            switch json {
                case .dictionary(let dict):
                    let commentText = NullableSerializer(Serialization._StringSerializer).deserialize(dict["comment_text"] ?? .null)
                    return FileAddCommentDetails(commentText: commentText)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FileAddCommentType struct
    open class FileAddCommentType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileAddCommentTypeSerializer().serialize(self)))"
        }
    }
    open class FileAddCommentTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileAddCommentType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileAddCommentType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return FileAddCommentType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Added files and/or folders.
    open class FileAddDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileAddDetailsSerializer().serialize(self)))"
        }
    }
    open class FileAddDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileAddDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileAddDetails {
            switch json {
                case .dictionary(_):
                    return FileAddDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FileAddType struct
    open class FileAddType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileAddTypeSerializer().serialize(self)))"
        }
    }
    open class FileAddTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileAddType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileAddType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return FileAddType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Subscribed to or unsubscribed from comment notifications for file.
    open class FileChangeCommentSubscriptionDetails: CustomStringConvertible {
        /// New file comment subscription.
        public let newValue: TeamLog.FileCommentNotificationPolicy
        /// Previous file comment subscription. Might be missing due to historical data gap.
        public let previousValue: TeamLog.FileCommentNotificationPolicy?
        public init(newValue: TeamLog.FileCommentNotificationPolicy, previousValue: TeamLog.FileCommentNotificationPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileChangeCommentSubscriptionDetailsSerializer().serialize(self)))"
        }
    }
    open class FileChangeCommentSubscriptionDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileChangeCommentSubscriptionDetails) -> JSON {
            let output = [ 
            "new_value": TeamLog.FileCommentNotificationPolicySerializer().serialize(value.newValue),
            "previous_value": NullableSerializer(TeamLog.FileCommentNotificationPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileChangeCommentSubscriptionDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = TeamLog.FileCommentNotificationPolicySerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(TeamLog.FileCommentNotificationPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                    return FileChangeCommentSubscriptionDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FileChangeCommentSubscriptionType struct
    open class FileChangeCommentSubscriptionType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileChangeCommentSubscriptionTypeSerializer().serialize(self)))"
        }
    }
    open class FileChangeCommentSubscriptionTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileChangeCommentSubscriptionType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileChangeCommentSubscriptionType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return FileChangeCommentSubscriptionType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Enable or disable file comments notifications
    public enum FileCommentNotificationPolicy: CustomStringConvertible {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileCommentNotificationPolicySerializer().serialize(self)))"
        }
    }
    open class FileCommentNotificationPolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileCommentNotificationPolicy) -> JSON {
            switch value {
                case .disabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disabled")
                    return .dictionary(d)
                case .enabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("enabled")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> FileCommentNotificationPolicy {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "disabled":
                            return FileCommentNotificationPolicy.disabled
                        case "enabled":
                            return FileCommentNotificationPolicy.enabled
                        case "other":
                            return FileCommentNotificationPolicy.other
                        default:
                            return FileCommentNotificationPolicy.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Enabled/disabled commenting on team files.
    open class FileCommentsChangePolicyDetails: CustomStringConvertible {
        /// New commenting on team files policy.
        public let newValue: TeamLog.FileCommentsPolicy
        /// Previous commenting on team files policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.FileCommentsPolicy?
        public init(newValue: TeamLog.FileCommentsPolicy, previousValue: TeamLog.FileCommentsPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileCommentsChangePolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class FileCommentsChangePolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileCommentsChangePolicyDetails) -> JSON {
            let output = [ 
            "new_value": TeamLog.FileCommentsPolicySerializer().serialize(value.newValue),
            "previous_value": NullableSerializer(TeamLog.FileCommentsPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileCommentsChangePolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = TeamLog.FileCommentsPolicySerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(TeamLog.FileCommentsPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                    return FileCommentsChangePolicyDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FileCommentsChangePolicyType struct
    open class FileCommentsChangePolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileCommentsChangePolicyTypeSerializer().serialize(self)))"
        }
    }
    open class FileCommentsChangePolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileCommentsChangePolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileCommentsChangePolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return FileCommentsChangePolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// File comments policy
    public enum FileCommentsPolicy: CustomStringConvertible {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileCommentsPolicySerializer().serialize(self)))"
        }
    }
    open class FileCommentsPolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileCommentsPolicy) -> JSON {
            switch value {
                case .disabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disabled")
                    return .dictionary(d)
                case .enabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("enabled")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> FileCommentsPolicy {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "disabled":
                            return FileCommentsPolicy.disabled
                        case "enabled":
                            return FileCommentsPolicy.enabled
                        case "other":
                            return FileCommentsPolicy.other
                        default:
                            return FileCommentsPolicy.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Copied files and/or folders.
    open class FileCopyDetails: CustomStringConvertible {
        /// Relocate action details.
        public let relocateActionDetails: Array<TeamLog.RelocateAssetReferencesLogInfo>
        public init(relocateActionDetails: Array<TeamLog.RelocateAssetReferencesLogInfo>) {
            self.relocateActionDetails = relocateActionDetails
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileCopyDetailsSerializer().serialize(self)))"
        }
    }
    open class FileCopyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileCopyDetails) -> JSON {
            let output = [ 
            "relocate_action_details": ArraySerializer(TeamLog.RelocateAssetReferencesLogInfoSerializer()).serialize(value.relocateActionDetails),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileCopyDetails {
            switch json {
                case .dictionary(let dict):
                    let relocateActionDetails = ArraySerializer(TeamLog.RelocateAssetReferencesLogInfoSerializer()).deserialize(dict["relocate_action_details"] ?? .null)
                    return FileCopyDetails(relocateActionDetails: relocateActionDetails)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FileCopyType struct
    open class FileCopyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileCopyTypeSerializer().serialize(self)))"
        }
    }
    open class FileCopyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileCopyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileCopyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return FileCopyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Deleted file comment.
    open class FileDeleteCommentDetails: CustomStringConvertible {
        /// Comment text. Might be missing due to historical data gap.
        public let commentText: String?
        public init(commentText: String? = nil) {
            nullableValidator(stringValidator())(commentText)
            self.commentText = commentText
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileDeleteCommentDetailsSerializer().serialize(self)))"
        }
    }
    open class FileDeleteCommentDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileDeleteCommentDetails) -> JSON {
            let output = [ 
            "comment_text": NullableSerializer(Serialization._StringSerializer).serialize(value.commentText),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileDeleteCommentDetails {
            switch json {
                case .dictionary(let dict):
                    let commentText = NullableSerializer(Serialization._StringSerializer).deserialize(dict["comment_text"] ?? .null)
                    return FileDeleteCommentDetails(commentText: commentText)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FileDeleteCommentType struct
    open class FileDeleteCommentType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileDeleteCommentTypeSerializer().serialize(self)))"
        }
    }
    open class FileDeleteCommentTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileDeleteCommentType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileDeleteCommentType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return FileDeleteCommentType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Deleted files and/or folders.
    open class FileDeleteDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileDeleteDetailsSerializer().serialize(self)))"
        }
    }
    open class FileDeleteDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileDeleteDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileDeleteDetails {
            switch json {
                case .dictionary(_):
                    return FileDeleteDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FileDeleteType struct
    open class FileDeleteType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileDeleteTypeSerializer().serialize(self)))"
        }
    }
    open class FileDeleteTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileDeleteType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileDeleteType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return FileDeleteType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Downloaded files and/or folders.
    open class FileDownloadDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileDownloadDetailsSerializer().serialize(self)))"
        }
    }
    open class FileDownloadDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileDownloadDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileDownloadDetails {
            switch json {
                case .dictionary(_):
                    return FileDownloadDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FileDownloadType struct
    open class FileDownloadType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileDownloadTypeSerializer().serialize(self)))"
        }
    }
    open class FileDownloadTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileDownloadType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileDownloadType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return FileDownloadType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Edited file comment.
    open class FileEditCommentDetails: CustomStringConvertible {
        /// Comment text. Might be missing due to historical data gap.
        public let commentText: String?
        /// Previous comment text.
        public let previousCommentText: String
        public init(previousCommentText: String, commentText: String? = nil) {
            nullableValidator(stringValidator())(commentText)
            self.commentText = commentText
            stringValidator()(previousCommentText)
            self.previousCommentText = previousCommentText
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileEditCommentDetailsSerializer().serialize(self)))"
        }
    }
    open class FileEditCommentDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileEditCommentDetails) -> JSON {
            let output = [ 
            "previous_comment_text": Serialization._StringSerializer.serialize(value.previousCommentText),
            "comment_text": NullableSerializer(Serialization._StringSerializer).serialize(value.commentText),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileEditCommentDetails {
            switch json {
                case .dictionary(let dict):
                    let previousCommentText = Serialization._StringSerializer.deserialize(dict["previous_comment_text"] ?? .null)
                    let commentText = NullableSerializer(Serialization._StringSerializer).deserialize(dict["comment_text"] ?? .null)
                    return FileEditCommentDetails(previousCommentText: previousCommentText, commentText: commentText)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FileEditCommentType struct
    open class FileEditCommentType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileEditCommentTypeSerializer().serialize(self)))"
        }
    }
    open class FileEditCommentTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileEditCommentType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileEditCommentType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return FileEditCommentType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Edited files.
    open class FileEditDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileEditDetailsSerializer().serialize(self)))"
        }
    }
    open class FileEditDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileEditDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileEditDetails {
            switch json {
                case .dictionary(_):
                    return FileEditDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FileEditType struct
    open class FileEditType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileEditTypeSerializer().serialize(self)))"
        }
    }
    open class FileEditTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileEditType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileEditType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return FileEditType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Created copy reference to file/folder.
    open class FileGetCopyReferenceDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileGetCopyReferenceDetailsSerializer().serialize(self)))"
        }
    }
    open class FileGetCopyReferenceDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileGetCopyReferenceDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileGetCopyReferenceDetails {
            switch json {
                case .dictionary(_):
                    return FileGetCopyReferenceDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FileGetCopyReferenceType struct
    open class FileGetCopyReferenceType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileGetCopyReferenceTypeSerializer().serialize(self)))"
        }
    }
    open class FileGetCopyReferenceTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileGetCopyReferenceType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileGetCopyReferenceType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return FileGetCopyReferenceType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Liked file comment.
    open class FileLikeCommentDetails: CustomStringConvertible {
        /// Comment text. Might be missing due to historical data gap.
        public let commentText: String?
        public init(commentText: String? = nil) {
            nullableValidator(stringValidator())(commentText)
            self.commentText = commentText
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileLikeCommentDetailsSerializer().serialize(self)))"
        }
    }
    open class FileLikeCommentDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileLikeCommentDetails) -> JSON {
            let output = [ 
            "comment_text": NullableSerializer(Serialization._StringSerializer).serialize(value.commentText),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileLikeCommentDetails {
            switch json {
                case .dictionary(let dict):
                    let commentText = NullableSerializer(Serialization._StringSerializer).deserialize(dict["comment_text"] ?? .null)
                    return FileLikeCommentDetails(commentText: commentText)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FileLikeCommentType struct
    open class FileLikeCommentType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileLikeCommentTypeSerializer().serialize(self)))"
        }
    }
    open class FileLikeCommentTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileLikeCommentType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileLikeCommentType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return FileLikeCommentType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Generic information relevant both for files and folders
    open class FileOrFolderLogInfo: CustomStringConvertible {
        /// Path relative to event context.
        public let path: TeamLog.PathLogInfo
        /// Display name. Might be missing due to historical data gap.
        public let displayName: String?
        /// Unique ID. Might be missing due to historical data gap.
        public let fileId: String?
        public init(path: TeamLog.PathLogInfo, displayName: String? = nil, fileId: String? = nil) {
            self.path = path
            nullableValidator(stringValidator())(displayName)
            self.displayName = displayName
            nullableValidator(stringValidator())(fileId)
            self.fileId = fileId
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileOrFolderLogInfoSerializer().serialize(self)))"
        }
    }
    open class FileOrFolderLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileOrFolderLogInfo) -> JSON {
            let output = [ 
            "path": TeamLog.PathLogInfoSerializer().serialize(value.path),
            "display_name": NullableSerializer(Serialization._StringSerializer).serialize(value.displayName),
            "file_id": NullableSerializer(Serialization._StringSerializer).serialize(value.fileId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileOrFolderLogInfo {
            switch json {
                case .dictionary(let dict):
                    let path = TeamLog.PathLogInfoSerializer().deserialize(dict["path"] ?? .null)
                    let displayName = NullableSerializer(Serialization._StringSerializer).deserialize(dict["display_name"] ?? .null)
                    let fileId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["file_id"] ?? .null)
                    return FileOrFolderLogInfo(path: path, displayName: displayName, fileId: fileId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// File's logged information.
    open class FileLogInfo: TeamLog.FileOrFolderLogInfo {
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileLogInfoSerializer().serialize(self)))"
        }
    }
    open class FileLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileLogInfo) -> JSON {
            let output = [ 
            "path": TeamLog.PathLogInfoSerializer().serialize(value.path),
            "display_name": NullableSerializer(Serialization._StringSerializer).serialize(value.displayName),
            "file_id": NullableSerializer(Serialization._StringSerializer).serialize(value.fileId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileLogInfo {
            switch json {
                case .dictionary(let dict):
                    let path = TeamLog.PathLogInfoSerializer().deserialize(dict["path"] ?? .null)
                    let displayName = NullableSerializer(Serialization._StringSerializer).deserialize(dict["display_name"] ?? .null)
                    let fileId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["file_id"] ?? .null)
                    return FileLogInfo(path: path, displayName: displayName, fileId: fileId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Moved files and/or folders.
    open class FileMoveDetails: CustomStringConvertible {
        /// Relocate action details.
        public let relocateActionDetails: Array<TeamLog.RelocateAssetReferencesLogInfo>
        public init(relocateActionDetails: Array<TeamLog.RelocateAssetReferencesLogInfo>) {
            self.relocateActionDetails = relocateActionDetails
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileMoveDetailsSerializer().serialize(self)))"
        }
    }
    open class FileMoveDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileMoveDetails) -> JSON {
            let output = [ 
            "relocate_action_details": ArraySerializer(TeamLog.RelocateAssetReferencesLogInfoSerializer()).serialize(value.relocateActionDetails),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileMoveDetails {
            switch json {
                case .dictionary(let dict):
                    let relocateActionDetails = ArraySerializer(TeamLog.RelocateAssetReferencesLogInfoSerializer()).deserialize(dict["relocate_action_details"] ?? .null)
                    return FileMoveDetails(relocateActionDetails: relocateActionDetails)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FileMoveType struct
    open class FileMoveType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileMoveTypeSerializer().serialize(self)))"
        }
    }
    open class FileMoveTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileMoveType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileMoveType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return FileMoveType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Permanently deleted files and/or folders.
    open class FilePermanentlyDeleteDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FilePermanentlyDeleteDetailsSerializer().serialize(self)))"
        }
    }
    open class FilePermanentlyDeleteDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FilePermanentlyDeleteDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FilePermanentlyDeleteDetails {
            switch json {
                case .dictionary(_):
                    return FilePermanentlyDeleteDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FilePermanentlyDeleteType struct
    open class FilePermanentlyDeleteType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FilePermanentlyDeleteTypeSerializer().serialize(self)))"
        }
    }
    open class FilePermanentlyDeleteTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FilePermanentlyDeleteType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FilePermanentlyDeleteType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return FilePermanentlyDeleteType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Previewed files and/or folders.
    open class FilePreviewDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FilePreviewDetailsSerializer().serialize(self)))"
        }
    }
    open class FilePreviewDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FilePreviewDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FilePreviewDetails {
            switch json {
                case .dictionary(_):
                    return FilePreviewDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FilePreviewType struct
    open class FilePreviewType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FilePreviewTypeSerializer().serialize(self)))"
        }
    }
    open class FilePreviewTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FilePreviewType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FilePreviewType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return FilePreviewType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Renamed files and/or folders.
    open class FileRenameDetails: CustomStringConvertible {
        /// Relocate action details.
        public let relocateActionDetails: Array<TeamLog.RelocateAssetReferencesLogInfo>
        public init(relocateActionDetails: Array<TeamLog.RelocateAssetReferencesLogInfo>) {
            self.relocateActionDetails = relocateActionDetails
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileRenameDetailsSerializer().serialize(self)))"
        }
    }
    open class FileRenameDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileRenameDetails) -> JSON {
            let output = [ 
            "relocate_action_details": ArraySerializer(TeamLog.RelocateAssetReferencesLogInfoSerializer()).serialize(value.relocateActionDetails),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileRenameDetails {
            switch json {
                case .dictionary(let dict):
                    let relocateActionDetails = ArraySerializer(TeamLog.RelocateAssetReferencesLogInfoSerializer()).deserialize(dict["relocate_action_details"] ?? .null)
                    return FileRenameDetails(relocateActionDetails: relocateActionDetails)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FileRenameType struct
    open class FileRenameType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileRenameTypeSerializer().serialize(self)))"
        }
    }
    open class FileRenameTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileRenameType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileRenameType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return FileRenameType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed file request.
    open class FileRequestChangeDetails: CustomStringConvertible {
        /// File request id. Might be missing due to historical data gap.
        public let fileRequestId: String?
        /// Previous file request details. Might be missing due to historical data gap.
        public let previousDetails: TeamLog.FileRequestDetails?
        /// New file request details.
        public let newDetails: TeamLog.FileRequestDetails
        public init(newDetails: TeamLog.FileRequestDetails, fileRequestId: String? = nil, previousDetails: TeamLog.FileRequestDetails? = nil) {
            nullableValidator(stringValidator(minLength: 1, pattern: "[-_0-9a-zA-Z]+"))(fileRequestId)
            self.fileRequestId = fileRequestId
            self.previousDetails = previousDetails
            self.newDetails = newDetails
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileRequestChangeDetailsSerializer().serialize(self)))"
        }
    }
    open class FileRequestChangeDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileRequestChangeDetails) -> JSON {
            let output = [ 
            "new_details": TeamLog.FileRequestDetailsSerializer().serialize(value.newDetails),
            "file_request_id": NullableSerializer(Serialization._StringSerializer).serialize(value.fileRequestId),
            "previous_details": NullableSerializer(TeamLog.FileRequestDetailsSerializer()).serialize(value.previousDetails),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileRequestChangeDetails {
            switch json {
                case .dictionary(let dict):
                    let newDetails = TeamLog.FileRequestDetailsSerializer().deserialize(dict["new_details"] ?? .null)
                    let fileRequestId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["file_request_id"] ?? .null)
                    let previousDetails = NullableSerializer(TeamLog.FileRequestDetailsSerializer()).deserialize(dict["previous_details"] ?? .null)
                    return FileRequestChangeDetails(newDetails: newDetails, fileRequestId: fileRequestId, previousDetails: previousDetails)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FileRequestChangeType struct
    open class FileRequestChangeType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileRequestChangeTypeSerializer().serialize(self)))"
        }
    }
    open class FileRequestChangeTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileRequestChangeType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileRequestChangeType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return FileRequestChangeType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Closed file request.
    open class FileRequestCloseDetails: CustomStringConvertible {
        /// File request id. Might be missing due to historical data gap.
        public let fileRequestId: String?
        /// Previous file request details. Might be missing due to historical data gap.
        public let previousDetails: TeamLog.FileRequestDetails?
        public init(fileRequestId: String? = nil, previousDetails: TeamLog.FileRequestDetails? = nil) {
            nullableValidator(stringValidator(minLength: 1, pattern: "[-_0-9a-zA-Z]+"))(fileRequestId)
            self.fileRequestId = fileRequestId
            self.previousDetails = previousDetails
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileRequestCloseDetailsSerializer().serialize(self)))"
        }
    }
    open class FileRequestCloseDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileRequestCloseDetails) -> JSON {
            let output = [ 
            "file_request_id": NullableSerializer(Serialization._StringSerializer).serialize(value.fileRequestId),
            "previous_details": NullableSerializer(TeamLog.FileRequestDetailsSerializer()).serialize(value.previousDetails),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileRequestCloseDetails {
            switch json {
                case .dictionary(let dict):
                    let fileRequestId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["file_request_id"] ?? .null)
                    let previousDetails = NullableSerializer(TeamLog.FileRequestDetailsSerializer()).deserialize(dict["previous_details"] ?? .null)
                    return FileRequestCloseDetails(fileRequestId: fileRequestId, previousDetails: previousDetails)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FileRequestCloseType struct
    open class FileRequestCloseType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileRequestCloseTypeSerializer().serialize(self)))"
        }
    }
    open class FileRequestCloseTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileRequestCloseType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileRequestCloseType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return FileRequestCloseType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Created file request.
    open class FileRequestCreateDetails: CustomStringConvertible {
        /// File request id. Might be missing due to historical data gap.
        public let fileRequestId: String?
        /// File request details. Might be missing due to historical data gap.
        public let requestDetails: TeamLog.FileRequestDetails?
        public init(fileRequestId: String? = nil, requestDetails: TeamLog.FileRequestDetails? = nil) {
            nullableValidator(stringValidator(minLength: 1, pattern: "[-_0-9a-zA-Z]+"))(fileRequestId)
            self.fileRequestId = fileRequestId
            self.requestDetails = requestDetails
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileRequestCreateDetailsSerializer().serialize(self)))"
        }
    }
    open class FileRequestCreateDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileRequestCreateDetails) -> JSON {
            let output = [ 
            "file_request_id": NullableSerializer(Serialization._StringSerializer).serialize(value.fileRequestId),
            "request_details": NullableSerializer(TeamLog.FileRequestDetailsSerializer()).serialize(value.requestDetails),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileRequestCreateDetails {
            switch json {
                case .dictionary(let dict):
                    let fileRequestId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["file_request_id"] ?? .null)
                    let requestDetails = NullableSerializer(TeamLog.FileRequestDetailsSerializer()).deserialize(dict["request_details"] ?? .null)
                    return FileRequestCreateDetails(fileRequestId: fileRequestId, requestDetails: requestDetails)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FileRequestCreateType struct
    open class FileRequestCreateType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileRequestCreateTypeSerializer().serialize(self)))"
        }
    }
    open class FileRequestCreateTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileRequestCreateType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileRequestCreateType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return FileRequestCreateType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// File request deadline
    open class FileRequestDeadline: CustomStringConvertible {
        /// The deadline for this file request. Might be missing due to historical data gap.
        public let deadline: Date?
        /// If set, allow uploads after the deadline has passed. Might be missing due to historical data gap.
        public let allowLateUploads: String?
        public init(deadline: Date? = nil, allowLateUploads: String? = nil) {
            self.deadline = deadline
            nullableValidator(stringValidator())(allowLateUploads)
            self.allowLateUploads = allowLateUploads
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileRequestDeadlineSerializer().serialize(self)))"
        }
    }
    open class FileRequestDeadlineSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileRequestDeadline) -> JSON {
            let output = [ 
            "deadline": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.deadline),
            "allow_late_uploads": NullableSerializer(Serialization._StringSerializer).serialize(value.allowLateUploads),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileRequestDeadline {
            switch json {
                case .dictionary(let dict):
                    let deadline = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["deadline"] ?? .null)
                    let allowLateUploads = NullableSerializer(Serialization._StringSerializer).deserialize(dict["allow_late_uploads"] ?? .null)
                    return FileRequestDeadline(deadline: deadline, allowLateUploads: allowLateUploads)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// File request details
    open class FileRequestDetails: CustomStringConvertible {
        /// Asset position in the Assets list.
        public let assetIndex: UInt64
        /// File request deadline. Might be missing due to historical data gap.
        public let deadline: TeamLog.FileRequestDeadline?
        public init(assetIndex: UInt64, deadline: TeamLog.FileRequestDeadline? = nil) {
            comparableValidator()(assetIndex)
            self.assetIndex = assetIndex
            self.deadline = deadline
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileRequestDetailsSerializer().serialize(self)))"
        }
    }
    open class FileRequestDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileRequestDetails) -> JSON {
            let output = [ 
            "asset_index": Serialization._UInt64Serializer.serialize(value.assetIndex),
            "deadline": NullableSerializer(TeamLog.FileRequestDeadlineSerializer()).serialize(value.deadline),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileRequestDetails {
            switch json {
                case .dictionary(let dict):
                    let assetIndex = Serialization._UInt64Serializer.deserialize(dict["asset_index"] ?? .null)
                    let deadline = NullableSerializer(TeamLog.FileRequestDeadlineSerializer()).deserialize(dict["deadline"] ?? .null)
                    return FileRequestDetails(assetIndex: assetIndex, deadline: deadline)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Received files for file request.
    open class FileRequestReceiveFileDetails: CustomStringConvertible {
        /// File request id. Might be missing due to historical data gap.
        public let fileRequestId: String?
        /// File request details. Might be missing due to historical data gap.
        public let fileRequestDetails: TeamLog.FileRequestDetails?
        /// Submitted file names.
        public let submittedFileNames: Array<String>
        /// The name as provided by the submitter. Might be missing due to historical data gap.
        public let submitterName: String?
        /// The email as provided by the submitter. Might be missing due to historical data gap.
        public let submitterEmail: String?
        public init(submittedFileNames: Array<String>, fileRequestId: String? = nil, fileRequestDetails: TeamLog.FileRequestDetails? = nil, submitterName: String? = nil, submitterEmail: String? = nil) {
            nullableValidator(stringValidator(minLength: 1, pattern: "[-_0-9a-zA-Z]+"))(fileRequestId)
            self.fileRequestId = fileRequestId
            self.fileRequestDetails = fileRequestDetails
            arrayValidator(itemValidator: stringValidator())(submittedFileNames)
            self.submittedFileNames = submittedFileNames
            nullableValidator(stringValidator())(submitterName)
            self.submitterName = submitterName
            nullableValidator(stringValidator(maxLength: 255))(submitterEmail)
            self.submitterEmail = submitterEmail
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileRequestReceiveFileDetailsSerializer().serialize(self)))"
        }
    }
    open class FileRequestReceiveFileDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileRequestReceiveFileDetails) -> JSON {
            let output = [ 
            "submitted_file_names": ArraySerializer(Serialization._StringSerializer).serialize(value.submittedFileNames),
            "file_request_id": NullableSerializer(Serialization._StringSerializer).serialize(value.fileRequestId),
            "file_request_details": NullableSerializer(TeamLog.FileRequestDetailsSerializer()).serialize(value.fileRequestDetails),
            "submitter_name": NullableSerializer(Serialization._StringSerializer).serialize(value.submitterName),
            "submitter_email": NullableSerializer(Serialization._StringSerializer).serialize(value.submitterEmail),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileRequestReceiveFileDetails {
            switch json {
                case .dictionary(let dict):
                    let submittedFileNames = ArraySerializer(Serialization._StringSerializer).deserialize(dict["submitted_file_names"] ?? .null)
                    let fileRequestId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["file_request_id"] ?? .null)
                    let fileRequestDetails = NullableSerializer(TeamLog.FileRequestDetailsSerializer()).deserialize(dict["file_request_details"] ?? .null)
                    let submitterName = NullableSerializer(Serialization._StringSerializer).deserialize(dict["submitter_name"] ?? .null)
                    let submitterEmail = NullableSerializer(Serialization._StringSerializer).deserialize(dict["submitter_email"] ?? .null)
                    return FileRequestReceiveFileDetails(submittedFileNames: submittedFileNames, fileRequestId: fileRequestId, fileRequestDetails: fileRequestDetails, submitterName: submitterName, submitterEmail: submitterEmail)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FileRequestReceiveFileType struct
    open class FileRequestReceiveFileType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileRequestReceiveFileTypeSerializer().serialize(self)))"
        }
    }
    open class FileRequestReceiveFileTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileRequestReceiveFileType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileRequestReceiveFileType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return FileRequestReceiveFileType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Enabled/disabled file requests.
    open class FileRequestsChangePolicyDetails: CustomStringConvertible {
        /// New file requests policy.
        public let newValue: TeamLog.FileRequestsPolicy
        /// Previous file requests policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.FileRequestsPolicy?
        public init(newValue: TeamLog.FileRequestsPolicy, previousValue: TeamLog.FileRequestsPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileRequestsChangePolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class FileRequestsChangePolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileRequestsChangePolicyDetails) -> JSON {
            let output = [ 
            "new_value": TeamLog.FileRequestsPolicySerializer().serialize(value.newValue),
            "previous_value": NullableSerializer(TeamLog.FileRequestsPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileRequestsChangePolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = TeamLog.FileRequestsPolicySerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(TeamLog.FileRequestsPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                    return FileRequestsChangePolicyDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FileRequestsChangePolicyType struct
    open class FileRequestsChangePolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileRequestsChangePolicyTypeSerializer().serialize(self)))"
        }
    }
    open class FileRequestsChangePolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileRequestsChangePolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileRequestsChangePolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return FileRequestsChangePolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Enabled file request emails for everyone.
    open class FileRequestsEmailsEnabledDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileRequestsEmailsEnabledDetailsSerializer().serialize(self)))"
        }
    }
    open class FileRequestsEmailsEnabledDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileRequestsEmailsEnabledDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileRequestsEmailsEnabledDetails {
            switch json {
                case .dictionary(_):
                    return FileRequestsEmailsEnabledDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FileRequestsEmailsEnabledType struct
    open class FileRequestsEmailsEnabledType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileRequestsEmailsEnabledTypeSerializer().serialize(self)))"
        }
    }
    open class FileRequestsEmailsEnabledTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileRequestsEmailsEnabledType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileRequestsEmailsEnabledType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return FileRequestsEmailsEnabledType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Enabled file request emails for team.
    open class FileRequestsEmailsRestrictedToTeamOnlyDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileRequestsEmailsRestrictedToTeamOnlyDetailsSerializer().serialize(self)))"
        }
    }
    open class FileRequestsEmailsRestrictedToTeamOnlyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileRequestsEmailsRestrictedToTeamOnlyDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileRequestsEmailsRestrictedToTeamOnlyDetails {
            switch json {
                case .dictionary(_):
                    return FileRequestsEmailsRestrictedToTeamOnlyDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FileRequestsEmailsRestrictedToTeamOnlyType struct
    open class FileRequestsEmailsRestrictedToTeamOnlyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileRequestsEmailsRestrictedToTeamOnlyTypeSerializer().serialize(self)))"
        }
    }
    open class FileRequestsEmailsRestrictedToTeamOnlyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileRequestsEmailsRestrictedToTeamOnlyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileRequestsEmailsRestrictedToTeamOnlyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return FileRequestsEmailsRestrictedToTeamOnlyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// File requests policy
    public enum FileRequestsPolicy: CustomStringConvertible {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileRequestsPolicySerializer().serialize(self)))"
        }
    }
    open class FileRequestsPolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileRequestsPolicy) -> JSON {
            switch value {
                case .disabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disabled")
                    return .dictionary(d)
                case .enabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("enabled")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> FileRequestsPolicy {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "disabled":
                            return FileRequestsPolicy.disabled
                        case "enabled":
                            return FileRequestsPolicy.enabled
                        case "other":
                            return FileRequestsPolicy.other
                        default:
                            return FileRequestsPolicy.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Resolved file comment.
    open class FileResolveCommentDetails: CustomStringConvertible {
        /// Comment text. Might be missing due to historical data gap.
        public let commentText: String?
        public init(commentText: String? = nil) {
            nullableValidator(stringValidator())(commentText)
            self.commentText = commentText
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileResolveCommentDetailsSerializer().serialize(self)))"
        }
    }
    open class FileResolveCommentDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileResolveCommentDetails) -> JSON {
            let output = [ 
            "comment_text": NullableSerializer(Serialization._StringSerializer).serialize(value.commentText),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileResolveCommentDetails {
            switch json {
                case .dictionary(let dict):
                    let commentText = NullableSerializer(Serialization._StringSerializer).deserialize(dict["comment_text"] ?? .null)
                    return FileResolveCommentDetails(commentText: commentText)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FileResolveCommentType struct
    open class FileResolveCommentType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileResolveCommentTypeSerializer().serialize(self)))"
        }
    }
    open class FileResolveCommentTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileResolveCommentType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileResolveCommentType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return FileResolveCommentType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Restored deleted files and/or folders.
    open class FileRestoreDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileRestoreDetailsSerializer().serialize(self)))"
        }
    }
    open class FileRestoreDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileRestoreDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileRestoreDetails {
            switch json {
                case .dictionary(_):
                    return FileRestoreDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FileRestoreType struct
    open class FileRestoreType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileRestoreTypeSerializer().serialize(self)))"
        }
    }
    open class FileRestoreTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileRestoreType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileRestoreType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return FileRestoreType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Reverted files to previous version.
    open class FileRevertDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileRevertDetailsSerializer().serialize(self)))"
        }
    }
    open class FileRevertDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileRevertDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileRevertDetails {
            switch json {
                case .dictionary(_):
                    return FileRevertDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FileRevertType struct
    open class FileRevertType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileRevertTypeSerializer().serialize(self)))"
        }
    }
    open class FileRevertTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileRevertType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileRevertType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return FileRevertType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Rolled back file actions.
    open class FileRollbackChangesDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileRollbackChangesDetailsSerializer().serialize(self)))"
        }
    }
    open class FileRollbackChangesDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileRollbackChangesDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileRollbackChangesDetails {
            switch json {
                case .dictionary(_):
                    return FileRollbackChangesDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FileRollbackChangesType struct
    open class FileRollbackChangesType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileRollbackChangesTypeSerializer().serialize(self)))"
        }
    }
    open class FileRollbackChangesTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileRollbackChangesType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileRollbackChangesType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return FileRollbackChangesType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Saved file/folder using copy reference.
    open class FileSaveCopyReferenceDetails: CustomStringConvertible {
        /// Relocate action details.
        public let relocateActionDetails: Array<TeamLog.RelocateAssetReferencesLogInfo>
        public init(relocateActionDetails: Array<TeamLog.RelocateAssetReferencesLogInfo>) {
            self.relocateActionDetails = relocateActionDetails
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileSaveCopyReferenceDetailsSerializer().serialize(self)))"
        }
    }
    open class FileSaveCopyReferenceDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileSaveCopyReferenceDetails) -> JSON {
            let output = [ 
            "relocate_action_details": ArraySerializer(TeamLog.RelocateAssetReferencesLogInfoSerializer()).serialize(value.relocateActionDetails),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileSaveCopyReferenceDetails {
            switch json {
                case .dictionary(let dict):
                    let relocateActionDetails = ArraySerializer(TeamLog.RelocateAssetReferencesLogInfoSerializer()).deserialize(dict["relocate_action_details"] ?? .null)
                    return FileSaveCopyReferenceDetails(relocateActionDetails: relocateActionDetails)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FileSaveCopyReferenceType struct
    open class FileSaveCopyReferenceType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileSaveCopyReferenceTypeSerializer().serialize(self)))"
        }
    }
    open class FileSaveCopyReferenceTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileSaveCopyReferenceType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileSaveCopyReferenceType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return FileSaveCopyReferenceType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Unliked file comment.
    open class FileUnlikeCommentDetails: CustomStringConvertible {
        /// Comment text. Might be missing due to historical data gap.
        public let commentText: String?
        public init(commentText: String? = nil) {
            nullableValidator(stringValidator())(commentText)
            self.commentText = commentText
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileUnlikeCommentDetailsSerializer().serialize(self)))"
        }
    }
    open class FileUnlikeCommentDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileUnlikeCommentDetails) -> JSON {
            let output = [ 
            "comment_text": NullableSerializer(Serialization._StringSerializer).serialize(value.commentText),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileUnlikeCommentDetails {
            switch json {
                case .dictionary(let dict):
                    let commentText = NullableSerializer(Serialization._StringSerializer).deserialize(dict["comment_text"] ?? .null)
                    return FileUnlikeCommentDetails(commentText: commentText)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FileUnlikeCommentType struct
    open class FileUnlikeCommentType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileUnlikeCommentTypeSerializer().serialize(self)))"
        }
    }
    open class FileUnlikeCommentTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileUnlikeCommentType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileUnlikeCommentType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return FileUnlikeCommentType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Unresolved file comment.
    open class FileUnresolveCommentDetails: CustomStringConvertible {
        /// Comment text. Might be missing due to historical data gap.
        public let commentText: String?
        public init(commentText: String? = nil) {
            nullableValidator(stringValidator())(commentText)
            self.commentText = commentText
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileUnresolveCommentDetailsSerializer().serialize(self)))"
        }
    }
    open class FileUnresolveCommentDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileUnresolveCommentDetails) -> JSON {
            let output = [ 
            "comment_text": NullableSerializer(Serialization._StringSerializer).serialize(value.commentText),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileUnresolveCommentDetails {
            switch json {
                case .dictionary(let dict):
                    let commentText = NullableSerializer(Serialization._StringSerializer).deserialize(dict["comment_text"] ?? .null)
                    return FileUnresolveCommentDetails(commentText: commentText)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FileUnresolveCommentType struct
    open class FileUnresolveCommentType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileUnresolveCommentTypeSerializer().serialize(self)))"
        }
    }
    open class FileUnresolveCommentTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileUnresolveCommentType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileUnresolveCommentType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return FileUnresolveCommentType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Folder's logged information.
    open class FolderLogInfo: TeamLog.FileOrFolderLogInfo {
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FolderLogInfoSerializer().serialize(self)))"
        }
    }
    open class FolderLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FolderLogInfo) -> JSON {
            let output = [ 
            "path": TeamLog.PathLogInfoSerializer().serialize(value.path),
            "display_name": NullableSerializer(Serialization._StringSerializer).serialize(value.displayName),
            "file_id": NullableSerializer(Serialization._StringSerializer).serialize(value.fileId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FolderLogInfo {
            switch json {
                case .dictionary(let dict):
                    let path = TeamLog.PathLogInfoSerializer().deserialize(dict["path"] ?? .null)
                    let displayName = NullableSerializer(Serialization._StringSerializer).deserialize(dict["display_name"] ?? .null)
                    let fileId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["file_id"] ?? .null)
                    return FolderLogInfo(path: path, displayName: displayName, fileId: fileId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Geographic location details.
    open class GeoLocationLogInfo: CustomStringConvertible {
        /// City name.
        public let city: String?
        /// Region name.
        public let region: String?
        /// Country code.
        public let country: String?
        /// IP address.
        public let ipAddress: String
        public init(ipAddress: String, city: String? = nil, region: String? = nil, country: String? = nil) {
            nullableValidator(stringValidator())(city)
            self.city = city
            nullableValidator(stringValidator())(region)
            self.region = region
            nullableValidator(stringValidator())(country)
            self.country = country
            stringValidator()(ipAddress)
            self.ipAddress = ipAddress
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GeoLocationLogInfoSerializer().serialize(self)))"
        }
    }
    open class GeoLocationLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GeoLocationLogInfo) -> JSON {
            let output = [ 
            "ip_address": Serialization._StringSerializer.serialize(value.ipAddress),
            "city": NullableSerializer(Serialization._StringSerializer).serialize(value.city),
            "region": NullableSerializer(Serialization._StringSerializer).serialize(value.region),
            "country": NullableSerializer(Serialization._StringSerializer).serialize(value.country),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GeoLocationLogInfo {
            switch json {
                case .dictionary(let dict):
                    let ipAddress = Serialization._StringSerializer.deserialize(dict["ip_address"] ?? .null)
                    let city = NullableSerializer(Serialization._StringSerializer).deserialize(dict["city"] ?? .null)
                    let region = NullableSerializer(Serialization._StringSerializer).deserialize(dict["region"] ?? .null)
                    let country = NullableSerializer(Serialization._StringSerializer).deserialize(dict["country"] ?? .null)
                    return GeoLocationLogInfo(ipAddress: ipAddress, city: city, region: region, country: country)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetTeamEventsArg struct
    open class GetTeamEventsArg: CustomStringConvertible {
        /// The maximal number of results to return per call. Note that some calls may not return limit number of
        /// events, and may even return no events, even with `has_more` set to true. In this case, callers should fetch
        /// again using getEventsContinue.
        public let limit: UInt32
        /// Filter the events by account ID. Return ony events with this account_id as either Actor, Context, or
        /// Participants.
        public let accountId: String?
        /// Filter by time range.
        public let time: TeamCommon.TimeRange?
        /// Filter the returned events to a single category.
        public let category: TeamLog.EventCategory?
        public init(limit: UInt32 = 1000, accountId: String? = nil, time: TeamCommon.TimeRange? = nil, category: TeamLog.EventCategory? = nil) {
            comparableValidator(minValue: 1, maxValue: 1000)(limit)
            self.limit = limit
            nullableValidator(stringValidator(minLength: 40, maxLength: 40))(accountId)
            self.accountId = accountId
            self.time = time
            self.category = category
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetTeamEventsArgSerializer().serialize(self)))"
        }
    }
    open class GetTeamEventsArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetTeamEventsArg) -> JSON {
            let output = [ 
            "limit": Serialization._UInt32Serializer.serialize(value.limit),
            "account_id": NullableSerializer(Serialization._StringSerializer).serialize(value.accountId),
            "time": NullableSerializer(TeamCommon.TimeRangeSerializer()).serialize(value.time),
            "category": NullableSerializer(TeamLog.EventCategorySerializer()).serialize(value.category),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetTeamEventsArg {
            switch json {
                case .dictionary(let dict):
                    let limit = Serialization._UInt32Serializer.deserialize(dict["limit"] ?? .number(1000))
                    let accountId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["account_id"] ?? .null)
                    let time = NullableSerializer(TeamCommon.TimeRangeSerializer()).deserialize(dict["time"] ?? .null)
                    let category = NullableSerializer(TeamLog.EventCategorySerializer()).deserialize(dict["category"] ?? .null)
                    return GetTeamEventsArg(limit: limit, accountId: accountId, time: time, category: category)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetTeamEventsContinueArg struct
    open class GetTeamEventsContinueArg: CustomStringConvertible {
        /// Indicates from what point to get the next set of events.
        public let cursor: String
        public init(cursor: String) {
            stringValidator()(cursor)
            self.cursor = cursor
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetTeamEventsContinueArgSerializer().serialize(self)))"
        }
    }
    open class GetTeamEventsContinueArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetTeamEventsContinueArg) -> JSON {
            let output = [ 
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetTeamEventsContinueArg {
            switch json {
                case .dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                    return GetTeamEventsContinueArg(cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Errors that can be raised when calling getEventsContinue.
    public enum GetTeamEventsContinueError: CustomStringConvertible {
        /// Bad cursor.
        case badCursor
        /// Cursors are intended to be used quickly. Individual cursor values are normally valid for days, but in rare
        /// cases may be reset sooner. Cursor reset errors should be handled by fetching a new cursor from getEvents.
        /// The associated value is the approximate timestamp of the most recent event returned by the cursor. This
        /// should be used as a resumption point when calling getEvents to obtain a new cursor.
        case reset(Date)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetTeamEventsContinueErrorSerializer().serialize(self)))"
        }
    }
    open class GetTeamEventsContinueErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetTeamEventsContinueError) -> JSON {
            switch value {
                case .badCursor:
                    var d = [String: JSON]()
                    d[".tag"] = .str("bad_cursor")
                    return .dictionary(d)
                case .reset(let arg):
                    var d = ["reset": NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(arg)]
                    d[".tag"] = .str("reset")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GetTeamEventsContinueError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "bad_cursor":
                            return GetTeamEventsContinueError.badCursor
                        case "reset":
                            let v = NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(d["reset"] ?? .null)
                            return GetTeamEventsContinueError.reset(v)
                        case "other":
                            return GetTeamEventsContinueError.other
                        default:
                            return GetTeamEventsContinueError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Errors that can be raised when calling getEvents.
    public enum GetTeamEventsError: CustomStringConvertible {
        /// No user found matching the provided account_id.
        case accountIdNotFound
        /// Invalid time range.
        case invalidTimeRange
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetTeamEventsErrorSerializer().serialize(self)))"
        }
    }
    open class GetTeamEventsErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetTeamEventsError) -> JSON {
            switch value {
                case .accountIdNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("account_id_not_found")
                    return .dictionary(d)
                case .invalidTimeRange:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_time_range")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GetTeamEventsError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "account_id_not_found":
                            return GetTeamEventsError.accountIdNotFound
                        case "invalid_time_range":
                            return GetTeamEventsError.invalidTimeRange
                        case "other":
                            return GetTeamEventsError.other
                        default:
                            return GetTeamEventsError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GetTeamEventsResult struct
    open class GetTeamEventsResult: CustomStringConvertible {
        /// List of events. Note that events are not guaranteed to be sorted by their timestamp value.
        public let events: Array<TeamLog.TeamEvent>
        /// Pass the cursor into getEventsContinue to obtain additional events. The value of cursor may change for each
        /// response from getEventsContinue, regardless of the value of hasMore; older cursor strings may expire. Thus,
        /// callers should ensure that they update their cursor based on the latest value of cursor after each call, and
        /// poll regularly if they wish to poll for new events. Callers should handle reset exceptions for expired
        /// cursors.
        public let cursor: String
        /// Is true if there may be additional events that have not been returned yet. An additional call to
        /// getEventsContinue can retrieve them. Note that hasMore may be true, even if events is empty.
        public let hasMore: Bool
        public init(events: Array<TeamLog.TeamEvent>, cursor: String, hasMore: Bool) {
            self.events = events
            stringValidator()(cursor)
            self.cursor = cursor
            self.hasMore = hasMore
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetTeamEventsResultSerializer().serialize(self)))"
        }
    }
    open class GetTeamEventsResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetTeamEventsResult) -> JSON {
            let output = [ 
            "events": ArraySerializer(TeamLog.TeamEventSerializer()).serialize(value.events),
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            "has_more": Serialization._BoolSerializer.serialize(value.hasMore),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetTeamEventsResult {
            switch json {
                case .dictionary(let dict):
                    let events = ArraySerializer(TeamLog.TeamEventSerializer()).deserialize(dict["events"] ?? .null)
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                    let hasMore = Serialization._BoolSerializer.deserialize(dict["has_more"] ?? .null)
                    return GetTeamEventsResult(events: events, cursor: cursor, hasMore: hasMore)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Enabled/disabled Google single sign-on for team.
    open class GoogleSsoChangePolicyDetails: CustomStringConvertible {
        /// New Google single sign-on policy.
        public let newValue: TeamLog.GoogleSsoPolicy
        /// Previous Google single sign-on policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.GoogleSsoPolicy?
        public init(newValue: TeamLog.GoogleSsoPolicy, previousValue: TeamLog.GoogleSsoPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GoogleSsoChangePolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class GoogleSsoChangePolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GoogleSsoChangePolicyDetails) -> JSON {
            let output = [ 
            "new_value": TeamLog.GoogleSsoPolicySerializer().serialize(value.newValue),
            "previous_value": NullableSerializer(TeamLog.GoogleSsoPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GoogleSsoChangePolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = TeamLog.GoogleSsoPolicySerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(TeamLog.GoogleSsoPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                    return GoogleSsoChangePolicyDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GoogleSsoChangePolicyType struct
    open class GoogleSsoChangePolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GoogleSsoChangePolicyTypeSerializer().serialize(self)))"
        }
    }
    open class GoogleSsoChangePolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GoogleSsoChangePolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GoogleSsoChangePolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return GoogleSsoChangePolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Google SSO policy
    public enum GoogleSsoPolicy: CustomStringConvertible {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GoogleSsoPolicySerializer().serialize(self)))"
        }
    }
    open class GoogleSsoPolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GoogleSsoPolicy) -> JSON {
            switch value {
                case .disabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disabled")
                    return .dictionary(d)
                case .enabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("enabled")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GoogleSsoPolicy {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "disabled":
                            return GoogleSsoPolicy.disabled
                        case "enabled":
                            return GoogleSsoPolicy.enabled
                        case "other":
                            return GoogleSsoPolicy.other
                        default:
                            return GoogleSsoPolicy.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Added external ID for group.
    open class GroupAddExternalIdDetails: CustomStringConvertible {
        /// Current external id.
        public let newValue: String
        public init(newValue: String) {
            stringValidator()(newValue)
            self.newValue = newValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupAddExternalIdDetailsSerializer().serialize(self)))"
        }
    }
    open class GroupAddExternalIdDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupAddExternalIdDetails) -> JSON {
            let output = [ 
            "new_value": Serialization._StringSerializer.serialize(value.newValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupAddExternalIdDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = Serialization._StringSerializer.deserialize(dict["new_value"] ?? .null)
                    return GroupAddExternalIdDetails(newValue: newValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GroupAddExternalIdType struct
    open class GroupAddExternalIdType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupAddExternalIdTypeSerializer().serialize(self)))"
        }
    }
    open class GroupAddExternalIdTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupAddExternalIdType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupAddExternalIdType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return GroupAddExternalIdType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Added team members to group.
    open class GroupAddMemberDetails: CustomStringConvertible {
        /// Is group owner.
        public let isGroupOwner: Bool
        public init(isGroupOwner: Bool) {
            self.isGroupOwner = isGroupOwner
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupAddMemberDetailsSerializer().serialize(self)))"
        }
    }
    open class GroupAddMemberDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupAddMemberDetails) -> JSON {
            let output = [ 
            "is_group_owner": Serialization._BoolSerializer.serialize(value.isGroupOwner),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupAddMemberDetails {
            switch json {
                case .dictionary(let dict):
                    let isGroupOwner = Serialization._BoolSerializer.deserialize(dict["is_group_owner"] ?? .null)
                    return GroupAddMemberDetails(isGroupOwner: isGroupOwner)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GroupAddMemberType struct
    open class GroupAddMemberType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupAddMemberTypeSerializer().serialize(self)))"
        }
    }
    open class GroupAddMemberTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupAddMemberType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupAddMemberType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return GroupAddMemberType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed external ID for group.
    open class GroupChangeExternalIdDetails: CustomStringConvertible {
        /// Current external id.
        public let newValue: String
        /// Old external id.
        public let previousValue: String
        public init(newValue: String, previousValue: String) {
            stringValidator()(newValue)
            self.newValue = newValue
            stringValidator()(previousValue)
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupChangeExternalIdDetailsSerializer().serialize(self)))"
        }
    }
    open class GroupChangeExternalIdDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupChangeExternalIdDetails) -> JSON {
            let output = [ 
            "new_value": Serialization._StringSerializer.serialize(value.newValue),
            "previous_value": Serialization._StringSerializer.serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupChangeExternalIdDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = Serialization._StringSerializer.deserialize(dict["new_value"] ?? .null)
                    let previousValue = Serialization._StringSerializer.deserialize(dict["previous_value"] ?? .null)
                    return GroupChangeExternalIdDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GroupChangeExternalIdType struct
    open class GroupChangeExternalIdType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupChangeExternalIdTypeSerializer().serialize(self)))"
        }
    }
    open class GroupChangeExternalIdTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupChangeExternalIdType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupChangeExternalIdType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return GroupChangeExternalIdType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed group management type.
    open class GroupChangeManagementTypeDetails: CustomStringConvertible {
        /// New group management type.
        public let newValue: TeamCommon.GroupManagementType
        /// Previous group management type. Might be missing due to historical data gap.
        public let previousValue: TeamCommon.GroupManagementType?
        public init(newValue: TeamCommon.GroupManagementType, previousValue: TeamCommon.GroupManagementType? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupChangeManagementTypeDetailsSerializer().serialize(self)))"
        }
    }
    open class GroupChangeManagementTypeDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupChangeManagementTypeDetails) -> JSON {
            let output = [ 
            "new_value": TeamCommon.GroupManagementTypeSerializer().serialize(value.newValue),
            "previous_value": NullableSerializer(TeamCommon.GroupManagementTypeSerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupChangeManagementTypeDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = TeamCommon.GroupManagementTypeSerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(TeamCommon.GroupManagementTypeSerializer()).deserialize(dict["previous_value"] ?? .null)
                    return GroupChangeManagementTypeDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GroupChangeManagementTypeType struct
    open class GroupChangeManagementTypeType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupChangeManagementTypeTypeSerializer().serialize(self)))"
        }
    }
    open class GroupChangeManagementTypeTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupChangeManagementTypeType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupChangeManagementTypeType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return GroupChangeManagementTypeType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed manager permissions of group member.
    open class GroupChangeMemberRoleDetails: CustomStringConvertible {
        /// Is group owner.
        public let isGroupOwner: Bool
        public init(isGroupOwner: Bool) {
            self.isGroupOwner = isGroupOwner
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupChangeMemberRoleDetailsSerializer().serialize(self)))"
        }
    }
    open class GroupChangeMemberRoleDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupChangeMemberRoleDetails) -> JSON {
            let output = [ 
            "is_group_owner": Serialization._BoolSerializer.serialize(value.isGroupOwner),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupChangeMemberRoleDetails {
            switch json {
                case .dictionary(let dict):
                    let isGroupOwner = Serialization._BoolSerializer.deserialize(dict["is_group_owner"] ?? .null)
                    return GroupChangeMemberRoleDetails(isGroupOwner: isGroupOwner)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GroupChangeMemberRoleType struct
    open class GroupChangeMemberRoleType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupChangeMemberRoleTypeSerializer().serialize(self)))"
        }
    }
    open class GroupChangeMemberRoleTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupChangeMemberRoleType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupChangeMemberRoleType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return GroupChangeMemberRoleType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Created group.
    open class GroupCreateDetails: CustomStringConvertible {
        /// Is company managed group. Might be missing due to historical data gap.
        public let isCompanyManaged: Bool?
        /// Group join policy.
        public let joinPolicy: TeamLog.GroupJoinPolicy?
        public init(isCompanyManaged: Bool? = nil, joinPolicy: TeamLog.GroupJoinPolicy? = nil) {
            self.isCompanyManaged = isCompanyManaged
            self.joinPolicy = joinPolicy
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupCreateDetailsSerializer().serialize(self)))"
        }
    }
    open class GroupCreateDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupCreateDetails) -> JSON {
            let output = [ 
            "is_company_managed": NullableSerializer(Serialization._BoolSerializer).serialize(value.isCompanyManaged),
            "join_policy": NullableSerializer(TeamLog.GroupJoinPolicySerializer()).serialize(value.joinPolicy),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupCreateDetails {
            switch json {
                case .dictionary(let dict):
                    let isCompanyManaged = NullableSerializer(Serialization._BoolSerializer).deserialize(dict["is_company_managed"] ?? .null)
                    let joinPolicy = NullableSerializer(TeamLog.GroupJoinPolicySerializer()).deserialize(dict["join_policy"] ?? .null)
                    return GroupCreateDetails(isCompanyManaged: isCompanyManaged, joinPolicy: joinPolicy)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GroupCreateType struct
    open class GroupCreateType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupCreateTypeSerializer().serialize(self)))"
        }
    }
    open class GroupCreateTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupCreateType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupCreateType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return GroupCreateType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Deleted group.
    open class GroupDeleteDetails: CustomStringConvertible {
        /// Is company managed group. Might be missing due to historical data gap.
        public let isCompanyManaged: Bool?
        public init(isCompanyManaged: Bool? = nil) {
            self.isCompanyManaged = isCompanyManaged
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupDeleteDetailsSerializer().serialize(self)))"
        }
    }
    open class GroupDeleteDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupDeleteDetails) -> JSON {
            let output = [ 
            "is_company_managed": NullableSerializer(Serialization._BoolSerializer).serialize(value.isCompanyManaged),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupDeleteDetails {
            switch json {
                case .dictionary(let dict):
                    let isCompanyManaged = NullableSerializer(Serialization._BoolSerializer).deserialize(dict["is_company_managed"] ?? .null)
                    return GroupDeleteDetails(isCompanyManaged: isCompanyManaged)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GroupDeleteType struct
    open class GroupDeleteType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupDeleteTypeSerializer().serialize(self)))"
        }
    }
    open class GroupDeleteTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupDeleteType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupDeleteType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return GroupDeleteType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Updated group.
    open class GroupDescriptionUpdatedDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupDescriptionUpdatedDetailsSerializer().serialize(self)))"
        }
    }
    open class GroupDescriptionUpdatedDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupDescriptionUpdatedDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupDescriptionUpdatedDetails {
            switch json {
                case .dictionary(_):
                    return GroupDescriptionUpdatedDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GroupDescriptionUpdatedType struct
    open class GroupDescriptionUpdatedType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupDescriptionUpdatedTypeSerializer().serialize(self)))"
        }
    }
    open class GroupDescriptionUpdatedTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupDescriptionUpdatedType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupDescriptionUpdatedType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return GroupDescriptionUpdatedType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GroupJoinPolicy union
    public enum GroupJoinPolicy: CustomStringConvertible {
        /// An unspecified error.
        case open
        /// An unspecified error.
        case requestToJoin
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupJoinPolicySerializer().serialize(self)))"
        }
    }
    open class GroupJoinPolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupJoinPolicy) -> JSON {
            switch value {
                case .open:
                    var d = [String: JSON]()
                    d[".tag"] = .str("open")
                    return .dictionary(d)
                case .requestToJoin:
                    var d = [String: JSON]()
                    d[".tag"] = .str("request_to_join")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GroupJoinPolicy {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "open":
                            return GroupJoinPolicy.open
                        case "request_to_join":
                            return GroupJoinPolicy.requestToJoin
                        case "other":
                            return GroupJoinPolicy.other
                        default:
                            return GroupJoinPolicy.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Updated group join policy.
    open class GroupJoinPolicyUpdatedDetails: CustomStringConvertible {
        /// Is company managed group. Might be missing due to historical data gap.
        public let isCompanyManaged: Bool?
        /// Group join policy.
        public let joinPolicy: TeamLog.GroupJoinPolicy?
        public init(isCompanyManaged: Bool? = nil, joinPolicy: TeamLog.GroupJoinPolicy? = nil) {
            self.isCompanyManaged = isCompanyManaged
            self.joinPolicy = joinPolicy
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupJoinPolicyUpdatedDetailsSerializer().serialize(self)))"
        }
    }
    open class GroupJoinPolicyUpdatedDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupJoinPolicyUpdatedDetails) -> JSON {
            let output = [ 
            "is_company_managed": NullableSerializer(Serialization._BoolSerializer).serialize(value.isCompanyManaged),
            "join_policy": NullableSerializer(TeamLog.GroupJoinPolicySerializer()).serialize(value.joinPolicy),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupJoinPolicyUpdatedDetails {
            switch json {
                case .dictionary(let dict):
                    let isCompanyManaged = NullableSerializer(Serialization._BoolSerializer).deserialize(dict["is_company_managed"] ?? .null)
                    let joinPolicy = NullableSerializer(TeamLog.GroupJoinPolicySerializer()).deserialize(dict["join_policy"] ?? .null)
                    return GroupJoinPolicyUpdatedDetails(isCompanyManaged: isCompanyManaged, joinPolicy: joinPolicy)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GroupJoinPolicyUpdatedType struct
    open class GroupJoinPolicyUpdatedType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupJoinPolicyUpdatedTypeSerializer().serialize(self)))"
        }
    }
    open class GroupJoinPolicyUpdatedTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupJoinPolicyUpdatedType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupJoinPolicyUpdatedType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return GroupJoinPolicyUpdatedType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Group's logged information.
    open class GroupLogInfo: CustomStringConvertible {
        /// The unique id of this group. Might be missing due to historical data gap.
        public let groupId: String?
        /// The name of this group.
        public let displayName: String
        /// External group ID. Might be missing due to historical data gap.
        public let externalId: String?
        public init(displayName: String, groupId: String? = nil, externalId: String? = nil) {
            nullableValidator(stringValidator())(groupId)
            self.groupId = groupId
            stringValidator()(displayName)
            self.displayName = displayName
            nullableValidator(stringValidator())(externalId)
            self.externalId = externalId
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupLogInfoSerializer().serialize(self)))"
        }
    }
    open class GroupLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupLogInfo) -> JSON {
            let output = [ 
            "display_name": Serialization._StringSerializer.serialize(value.displayName),
            "group_id": NullableSerializer(Serialization._StringSerializer).serialize(value.groupId),
            "external_id": NullableSerializer(Serialization._StringSerializer).serialize(value.externalId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupLogInfo {
            switch json {
                case .dictionary(let dict):
                    let displayName = Serialization._StringSerializer.deserialize(dict["display_name"] ?? .null)
                    let groupId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["group_id"] ?? .null)
                    let externalId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["external_id"] ?? .null)
                    return GroupLogInfo(displayName: displayName, groupId: groupId, externalId: externalId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Moved group.
    open class GroupMovedDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupMovedDetailsSerializer().serialize(self)))"
        }
    }
    open class GroupMovedDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupMovedDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupMovedDetails {
            switch json {
                case .dictionary(_):
                    return GroupMovedDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GroupMovedType struct
    open class GroupMovedType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupMovedTypeSerializer().serialize(self)))"
        }
    }
    open class GroupMovedTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupMovedType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupMovedType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return GroupMovedType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Removed external ID for group.
    open class GroupRemoveExternalIdDetails: CustomStringConvertible {
        /// Old external id.
        public let previousValue: String
        public init(previousValue: String) {
            stringValidator()(previousValue)
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupRemoveExternalIdDetailsSerializer().serialize(self)))"
        }
    }
    open class GroupRemoveExternalIdDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupRemoveExternalIdDetails) -> JSON {
            let output = [ 
            "previous_value": Serialization._StringSerializer.serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupRemoveExternalIdDetails {
            switch json {
                case .dictionary(let dict):
                    let previousValue = Serialization._StringSerializer.deserialize(dict["previous_value"] ?? .null)
                    return GroupRemoveExternalIdDetails(previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GroupRemoveExternalIdType struct
    open class GroupRemoveExternalIdType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupRemoveExternalIdTypeSerializer().serialize(self)))"
        }
    }
    open class GroupRemoveExternalIdTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupRemoveExternalIdType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupRemoveExternalIdType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return GroupRemoveExternalIdType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Removed team members from group.
    open class GroupRemoveMemberDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupRemoveMemberDetailsSerializer().serialize(self)))"
        }
    }
    open class GroupRemoveMemberDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupRemoveMemberDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupRemoveMemberDetails {
            switch json {
                case .dictionary(_):
                    return GroupRemoveMemberDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GroupRemoveMemberType struct
    open class GroupRemoveMemberType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupRemoveMemberTypeSerializer().serialize(self)))"
        }
    }
    open class GroupRemoveMemberTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupRemoveMemberType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupRemoveMemberType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return GroupRemoveMemberType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Renamed group.
    open class GroupRenameDetails: CustomStringConvertible {
        /// Previous display name.
        public let previousValue: String
        /// New display name.
        public let newValue: String
        public init(previousValue: String, newValue: String) {
            stringValidator()(previousValue)
            self.previousValue = previousValue
            stringValidator()(newValue)
            self.newValue = newValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupRenameDetailsSerializer().serialize(self)))"
        }
    }
    open class GroupRenameDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupRenameDetails) -> JSON {
            let output = [ 
            "previous_value": Serialization._StringSerializer.serialize(value.previousValue),
            "new_value": Serialization._StringSerializer.serialize(value.newValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupRenameDetails {
            switch json {
                case .dictionary(let dict):
                    let previousValue = Serialization._StringSerializer.deserialize(dict["previous_value"] ?? .null)
                    let newValue = Serialization._StringSerializer.deserialize(dict["new_value"] ?? .null)
                    return GroupRenameDetails(previousValue: previousValue, newValue: newValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GroupRenameType struct
    open class GroupRenameType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupRenameTypeSerializer().serialize(self)))"
        }
    }
    open class GroupRenameTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupRenameType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupRenameType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return GroupRenameType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed who can create groups.
    open class GroupUserManagementChangePolicyDetails: CustomStringConvertible {
        /// New group users management policy.
        public let newValue: TeamPolicies.GroupCreation
        /// Previous group users management policy. Might be missing due to historical data gap.
        public let previousValue: TeamPolicies.GroupCreation?
        public init(newValue: TeamPolicies.GroupCreation, previousValue: TeamPolicies.GroupCreation? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupUserManagementChangePolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class GroupUserManagementChangePolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupUserManagementChangePolicyDetails) -> JSON {
            let output = [ 
            "new_value": TeamPolicies.GroupCreationSerializer().serialize(value.newValue),
            "previous_value": NullableSerializer(TeamPolicies.GroupCreationSerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupUserManagementChangePolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = TeamPolicies.GroupCreationSerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(TeamPolicies.GroupCreationSerializer()).deserialize(dict["previous_value"] ?? .null)
                    return GroupUserManagementChangePolicyDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GroupUserManagementChangePolicyType struct
    open class GroupUserManagementChangePolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupUserManagementChangePolicyTypeSerializer().serialize(self)))"
        }
    }
    open class GroupUserManagementChangePolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupUserManagementChangePolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupUserManagementChangePolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return GroupUserManagementChangePolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The IdentifierType union
    public enum IdentifierType: CustomStringConvertible {
        /// An unspecified error.
        case email
        /// An unspecified error.
        case facebookProfileName
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(IdentifierTypeSerializer().serialize(self)))"
        }
    }
    open class IdentifierTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: IdentifierType) -> JSON {
            switch value {
                case .email:
                    var d = [String: JSON]()
                    d[".tag"] = .str("email")
                    return .dictionary(d)
                case .facebookProfileName:
                    var d = [String: JSON]()
                    d[".tag"] = .str("facebook_profile_name")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> IdentifierType {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "email":
                            return IdentifierType.email
                        case "facebook_profile_name":
                            return IdentifierType.facebookProfileName
                        case "other":
                            return IdentifierType.other
                        default:
                            return IdentifierType.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Additional information relevant when a new member joins the team.
    open class JoinTeamDetails: CustomStringConvertible {
        /// Linked applications.
        public let linkedApps: Array<TeamLog.UserLinkedAppLogInfo>
        /// Linked devices.
        public let linkedDevices: Array<TeamLog.LinkedDeviceLogInfo>
        /// Linked shared folders.
        public let linkedSharedFolders: Array<TeamLog.FolderLogInfo>
        public init(linkedApps: Array<TeamLog.UserLinkedAppLogInfo>, linkedDevices: Array<TeamLog.LinkedDeviceLogInfo>, linkedSharedFolders: Array<TeamLog.FolderLogInfo>) {
            self.linkedApps = linkedApps
            self.linkedDevices = linkedDevices
            self.linkedSharedFolders = linkedSharedFolders
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(JoinTeamDetailsSerializer().serialize(self)))"
        }
    }
    open class JoinTeamDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: JoinTeamDetails) -> JSON {
            let output = [ 
            "linked_apps": ArraySerializer(TeamLog.UserLinkedAppLogInfoSerializer()).serialize(value.linkedApps),
            "linked_devices": ArraySerializer(TeamLog.LinkedDeviceLogInfoSerializer()).serialize(value.linkedDevices),
            "linked_shared_folders": ArraySerializer(TeamLog.FolderLogInfoSerializer()).serialize(value.linkedSharedFolders),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> JoinTeamDetails {
            switch json {
                case .dictionary(let dict):
                    let linkedApps = ArraySerializer(TeamLog.UserLinkedAppLogInfoSerializer()).deserialize(dict["linked_apps"] ?? .null)
                    let linkedDevices = ArraySerializer(TeamLog.LinkedDeviceLogInfoSerializer()).deserialize(dict["linked_devices"] ?? .null)
                    let linkedSharedFolders = ArraySerializer(TeamLog.FolderLogInfoSerializer()).deserialize(dict["linked_shared_folders"] ?? .null)
                    return JoinTeamDetails(linkedApps: linkedApps, linkedDevices: linkedDevices, linkedSharedFolders: linkedSharedFolders)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Information on sessions, in legacy format
    open class LegacyDeviceSessionLogInfo: TeamLog.DeviceSessionLogInfo {
        /// Session unique id. Might be missing due to historical data gap.
        public let sessionInfo: TeamLog.SessionLogInfo?
        /// The device name. Might be missing due to historical data gap.
        public let displayName: String?
        /// Is device managed by emm. Might be missing due to historical data gap.
        public let isEmmManaged: Bool?
        /// Information on the hosting platform. Might be missing due to historical data gap.
        public let platform: String?
        /// The mac address of the last activity from this session. Might be missing due to historical data gap.
        public let macAddress: String?
        /// The hosting OS version. Might be missing due to historical data gap.
        public let osVersion: String?
        /// Information on the hosting device type. Might be missing due to historical data gap.
        public let deviceType: String?
        /// The Dropbox client version. Might be missing due to historical data gap.
        public let clientVersion: String?
        /// Alternative unique device session id, instead of session id field. Might be missing due to historical data
        /// gap.
        public let legacyUniqId: String?
        public init(ipAddress: String? = nil, created: Date? = nil, updated: Date? = nil, sessionInfo: TeamLog.SessionLogInfo? = nil, displayName: String? = nil, isEmmManaged: Bool? = nil, platform: String? = nil, macAddress: String? = nil, osVersion: String? = nil, deviceType: String? = nil, clientVersion: String? = nil, legacyUniqId: String? = nil) {
            self.sessionInfo = sessionInfo
            nullableValidator(stringValidator())(displayName)
            self.displayName = displayName
            self.isEmmManaged = isEmmManaged
            nullableValidator(stringValidator())(platform)
            self.platform = platform
            nullableValidator(stringValidator())(macAddress)
            self.macAddress = macAddress
            nullableValidator(stringValidator())(osVersion)
            self.osVersion = osVersion
            nullableValidator(stringValidator())(deviceType)
            self.deviceType = deviceType
            nullableValidator(stringValidator())(clientVersion)
            self.clientVersion = clientVersion
            nullableValidator(stringValidator())(legacyUniqId)
            self.legacyUniqId = legacyUniqId
            super.init(ipAddress: ipAddress, created: created, updated: updated)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(LegacyDeviceSessionLogInfoSerializer().serialize(self)))"
        }
    }
    open class LegacyDeviceSessionLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: LegacyDeviceSessionLogInfo) -> JSON {
            let output = [ 
            "ip_address": NullableSerializer(Serialization._StringSerializer).serialize(value.ipAddress),
            "created": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.created),
            "updated": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.updated),
            "session_info": NullableSerializer(TeamLog.SessionLogInfoSerializer()).serialize(value.sessionInfo),
            "display_name": NullableSerializer(Serialization._StringSerializer).serialize(value.displayName),
            "is_emm_managed": NullableSerializer(Serialization._BoolSerializer).serialize(value.isEmmManaged),
            "platform": NullableSerializer(Serialization._StringSerializer).serialize(value.platform),
            "mac_address": NullableSerializer(Serialization._StringSerializer).serialize(value.macAddress),
            "os_version": NullableSerializer(Serialization._StringSerializer).serialize(value.osVersion),
            "device_type": NullableSerializer(Serialization._StringSerializer).serialize(value.deviceType),
            "client_version": NullableSerializer(Serialization._StringSerializer).serialize(value.clientVersion),
            "legacy_uniq_id": NullableSerializer(Serialization._StringSerializer).serialize(value.legacyUniqId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> LegacyDeviceSessionLogInfo {
            switch json {
                case .dictionary(let dict):
                    let ipAddress = NullableSerializer(Serialization._StringSerializer).deserialize(dict["ip_address"] ?? .null)
                    let created = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["created"] ?? .null)
                    let updated = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["updated"] ?? .null)
                    let sessionInfo = NullableSerializer(TeamLog.SessionLogInfoSerializer()).deserialize(dict["session_info"] ?? .null)
                    let displayName = NullableSerializer(Serialization._StringSerializer).deserialize(dict["display_name"] ?? .null)
                    let isEmmManaged = NullableSerializer(Serialization._BoolSerializer).deserialize(dict["is_emm_managed"] ?? .null)
                    let platform = NullableSerializer(Serialization._StringSerializer).deserialize(dict["platform"] ?? .null)
                    let macAddress = NullableSerializer(Serialization._StringSerializer).deserialize(dict["mac_address"] ?? .null)
                    let osVersion = NullableSerializer(Serialization._StringSerializer).deserialize(dict["os_version"] ?? .null)
                    let deviceType = NullableSerializer(Serialization._StringSerializer).deserialize(dict["device_type"] ?? .null)
                    let clientVersion = NullableSerializer(Serialization._StringSerializer).deserialize(dict["client_version"] ?? .null)
                    let legacyUniqId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["legacy_uniq_id"] ?? .null)
                    return LegacyDeviceSessionLogInfo(ipAddress: ipAddress, created: created, updated: updated, sessionInfo: sessionInfo, displayName: displayName, isEmmManaged: isEmmManaged, platform: platform, macAddress: macAddress, osVersion: osVersion, deviceType: deviceType, clientVersion: clientVersion, legacyUniqId: legacyUniqId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The device sessions that user is linked to.
    public enum LinkedDeviceLogInfo: CustomStringConvertible {
        /// mobile device session's details.
        case mobileDeviceSession(TeamLog.MobileDeviceSessionLogInfo)
        /// desktop device session's details.
        case desktopDeviceSession(TeamLog.DesktopDeviceSessionLogInfo)
        /// web device session's details.
        case webDeviceSession(TeamLog.WebDeviceSessionLogInfo)
        /// legacy device session's details.
        case legacyDeviceSession(TeamLog.LegacyDeviceSessionLogInfo)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(LinkedDeviceLogInfoSerializer().serialize(self)))"
        }
    }
    open class LinkedDeviceLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: LinkedDeviceLogInfo) -> JSON {
            switch value {
                case .mobileDeviceSession(let arg):
                    var d = Serialization.getFields(TeamLog.MobileDeviceSessionLogInfoSerializer().serialize(arg))
                    d[".tag"] = .str("mobile_device_session")
                    return .dictionary(d)
                case .desktopDeviceSession(let arg):
                    var d = Serialization.getFields(TeamLog.DesktopDeviceSessionLogInfoSerializer().serialize(arg))
                    d[".tag"] = .str("desktop_device_session")
                    return .dictionary(d)
                case .webDeviceSession(let arg):
                    var d = Serialization.getFields(TeamLog.WebDeviceSessionLogInfoSerializer().serialize(arg))
                    d[".tag"] = .str("web_device_session")
                    return .dictionary(d)
                case .legacyDeviceSession(let arg):
                    var d = Serialization.getFields(TeamLog.LegacyDeviceSessionLogInfoSerializer().serialize(arg))
                    d[".tag"] = .str("legacy_device_session")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> LinkedDeviceLogInfo {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "mobile_device_session":
                            let v = TeamLog.MobileDeviceSessionLogInfoSerializer().deserialize(json)
                            return LinkedDeviceLogInfo.mobileDeviceSession(v)
                        case "desktop_device_session":
                            let v = TeamLog.DesktopDeviceSessionLogInfoSerializer().deserialize(json)
                            return LinkedDeviceLogInfo.desktopDeviceSession(v)
                        case "web_device_session":
                            let v = TeamLog.WebDeviceSessionLogInfoSerializer().deserialize(json)
                            return LinkedDeviceLogInfo.webDeviceSession(v)
                        case "legacy_device_session":
                            let v = TeamLog.LegacyDeviceSessionLogInfoSerializer().deserialize(json)
                            return LinkedDeviceLogInfo.legacyDeviceSession(v)
                        case "other":
                            return LinkedDeviceLogInfo.other
                        default:
                            return LinkedDeviceLogInfo.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Failed to sign in.
    open class LoginFailDetails: CustomStringConvertible {
        /// Tells if the login device is EMM managed. Might be missing due to historical data gap.
        public let isEmmManaged: Bool?
        /// Login method.
        public let loginMethod: TeamLog.LoginMethod
        /// Error details.
        public let errorDetails: TeamLog.FailureDetailsLogInfo
        public init(loginMethod: TeamLog.LoginMethod, errorDetails: TeamLog.FailureDetailsLogInfo, isEmmManaged: Bool? = nil) {
            self.isEmmManaged = isEmmManaged
            self.loginMethod = loginMethod
            self.errorDetails = errorDetails
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(LoginFailDetailsSerializer().serialize(self)))"
        }
    }
    open class LoginFailDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: LoginFailDetails) -> JSON {
            let output = [ 
            "login_method": TeamLog.LoginMethodSerializer().serialize(value.loginMethod),
            "error_details": TeamLog.FailureDetailsLogInfoSerializer().serialize(value.errorDetails),
            "is_emm_managed": NullableSerializer(Serialization._BoolSerializer).serialize(value.isEmmManaged),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> LoginFailDetails {
            switch json {
                case .dictionary(let dict):
                    let loginMethod = TeamLog.LoginMethodSerializer().deserialize(dict["login_method"] ?? .null)
                    let errorDetails = TeamLog.FailureDetailsLogInfoSerializer().deserialize(dict["error_details"] ?? .null)
                    let isEmmManaged = NullableSerializer(Serialization._BoolSerializer).deserialize(dict["is_emm_managed"] ?? .null)
                    return LoginFailDetails(loginMethod: loginMethod, errorDetails: errorDetails, isEmmManaged: isEmmManaged)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The LoginFailType struct
    open class LoginFailType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(LoginFailTypeSerializer().serialize(self)))"
        }
    }
    open class LoginFailTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: LoginFailType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> LoginFailType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return LoginFailType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The LoginMethod union
    public enum LoginMethod: CustomStringConvertible {
        /// An unspecified error.
        case password
        /// An unspecified error.
        case twoFactorAuthentication
        /// An unspecified error.
        case saml
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(LoginMethodSerializer().serialize(self)))"
        }
    }
    open class LoginMethodSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: LoginMethod) -> JSON {
            switch value {
                case .password:
                    var d = [String: JSON]()
                    d[".tag"] = .str("password")
                    return .dictionary(d)
                case .twoFactorAuthentication:
                    var d = [String: JSON]()
                    d[".tag"] = .str("two_factor_authentication")
                    return .dictionary(d)
                case .saml:
                    var d = [String: JSON]()
                    d[".tag"] = .str("saml")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> LoginMethod {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "password":
                            return LoginMethod.password
                        case "two_factor_authentication":
                            return LoginMethod.twoFactorAuthentication
                        case "saml":
                            return LoginMethod.saml
                        case "other":
                            return LoginMethod.other
                        default:
                            return LoginMethod.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Signed in.
    open class LoginSuccessDetails: CustomStringConvertible {
        /// Tells if the login device is EMM managed. Might be missing due to historical data gap.
        public let isEmmManaged: Bool?
        /// Login method.
        public let loginMethod: TeamLog.LoginMethod
        public init(loginMethod: TeamLog.LoginMethod, isEmmManaged: Bool? = nil) {
            self.isEmmManaged = isEmmManaged
            self.loginMethod = loginMethod
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(LoginSuccessDetailsSerializer().serialize(self)))"
        }
    }
    open class LoginSuccessDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: LoginSuccessDetails) -> JSON {
            let output = [ 
            "login_method": TeamLog.LoginMethodSerializer().serialize(value.loginMethod),
            "is_emm_managed": NullableSerializer(Serialization._BoolSerializer).serialize(value.isEmmManaged),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> LoginSuccessDetails {
            switch json {
                case .dictionary(let dict):
                    let loginMethod = TeamLog.LoginMethodSerializer().deserialize(dict["login_method"] ?? .null)
                    let isEmmManaged = NullableSerializer(Serialization._BoolSerializer).deserialize(dict["is_emm_managed"] ?? .null)
                    return LoginSuccessDetails(loginMethod: loginMethod, isEmmManaged: isEmmManaged)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The LoginSuccessType struct
    open class LoginSuccessType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(LoginSuccessTypeSerializer().serialize(self)))"
        }
    }
    open class LoginSuccessTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: LoginSuccessType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> LoginSuccessType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return LoginSuccessType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Signed out.
    open class LogoutDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(LogoutDetailsSerializer().serialize(self)))"
        }
    }
    open class LogoutDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: LogoutDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> LogoutDetails {
            switch json {
                case .dictionary(_):
                    return LogoutDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The LogoutType struct
    open class LogoutType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(LogoutTypeSerializer().serialize(self)))"
        }
    }
    open class LogoutTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: LogoutType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> LogoutType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return LogoutType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Added team member name.
    open class MemberAddNameDetails: CustomStringConvertible {
        /// New user's name.
        public let newValue: TeamLog.UserNameLogInfo
        public init(newValue: TeamLog.UserNameLogInfo) {
            self.newValue = newValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberAddNameDetailsSerializer().serialize(self)))"
        }
    }
    open class MemberAddNameDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberAddNameDetails) -> JSON {
            let output = [ 
            "new_value": TeamLog.UserNameLogInfoSerializer().serialize(value.newValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberAddNameDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = TeamLog.UserNameLogInfoSerializer().deserialize(dict["new_value"] ?? .null)
                    return MemberAddNameDetails(newValue: newValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MemberAddNameType struct
    open class MemberAddNameType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberAddNameTypeSerializer().serialize(self)))"
        }
    }
    open class MemberAddNameTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberAddNameType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberAddNameType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return MemberAddNameType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed team member admin role.
    open class MemberChangeAdminRoleDetails: CustomStringConvertible {
        /// New admin role. This field is relevant when the admin role is changed or whenthe user role changes from no
        /// admin rights to with admin rights.
        public let newValue: TeamLog.AdminRole?
        /// Previous admin role. This field is relevant when the admin role is changed or when the admin role is
        /// removed.
        public let previousValue: TeamLog.AdminRole?
        public init(newValue: TeamLog.AdminRole? = nil, previousValue: TeamLog.AdminRole? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberChangeAdminRoleDetailsSerializer().serialize(self)))"
        }
    }
    open class MemberChangeAdminRoleDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberChangeAdminRoleDetails) -> JSON {
            let output = [ 
            "new_value": NullableSerializer(TeamLog.AdminRoleSerializer()).serialize(value.newValue),
            "previous_value": NullableSerializer(TeamLog.AdminRoleSerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberChangeAdminRoleDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = NullableSerializer(TeamLog.AdminRoleSerializer()).deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(TeamLog.AdminRoleSerializer()).deserialize(dict["previous_value"] ?? .null)
                    return MemberChangeAdminRoleDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MemberChangeAdminRoleType struct
    open class MemberChangeAdminRoleType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberChangeAdminRoleTypeSerializer().serialize(self)))"
        }
    }
    open class MemberChangeAdminRoleTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberChangeAdminRoleType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberChangeAdminRoleType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return MemberChangeAdminRoleType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed team member email.
    open class MemberChangeEmailDetails: CustomStringConvertible {
        /// New email.
        public let newValue: String
        /// Previous email. Might be missing due to historical data gap.
        public let previousValue: String?
        public init(newValue: String, previousValue: String? = nil) {
            stringValidator(maxLength: 255)(newValue)
            self.newValue = newValue
            nullableValidator(stringValidator(maxLength: 255))(previousValue)
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberChangeEmailDetailsSerializer().serialize(self)))"
        }
    }
    open class MemberChangeEmailDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberChangeEmailDetails) -> JSON {
            let output = [ 
            "new_value": Serialization._StringSerializer.serialize(value.newValue),
            "previous_value": NullableSerializer(Serialization._StringSerializer).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberChangeEmailDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = Serialization._StringSerializer.deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(Serialization._StringSerializer).deserialize(dict["previous_value"] ?? .null)
                    return MemberChangeEmailDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MemberChangeEmailType struct
    open class MemberChangeEmailType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberChangeEmailTypeSerializer().serialize(self)))"
        }
    }
    open class MemberChangeEmailTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberChangeEmailType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberChangeEmailType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return MemberChangeEmailType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed membership type (limited/full) of member.
    open class MemberChangeMembershipTypeDetails: CustomStringConvertible {
        /// Previous membership type.
        public let prevValue: TeamLog.TeamMembershipType
        /// New membership type.
        public let newValue: TeamLog.TeamMembershipType
        public init(prevValue: TeamLog.TeamMembershipType, newValue: TeamLog.TeamMembershipType) {
            self.prevValue = prevValue
            self.newValue = newValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberChangeMembershipTypeDetailsSerializer().serialize(self)))"
        }
    }
    open class MemberChangeMembershipTypeDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberChangeMembershipTypeDetails) -> JSON {
            let output = [ 
            "prev_value": TeamLog.TeamMembershipTypeSerializer().serialize(value.prevValue),
            "new_value": TeamLog.TeamMembershipTypeSerializer().serialize(value.newValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberChangeMembershipTypeDetails {
            switch json {
                case .dictionary(let dict):
                    let prevValue = TeamLog.TeamMembershipTypeSerializer().deserialize(dict["prev_value"] ?? .null)
                    let newValue = TeamLog.TeamMembershipTypeSerializer().deserialize(dict["new_value"] ?? .null)
                    return MemberChangeMembershipTypeDetails(prevValue: prevValue, newValue: newValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MemberChangeMembershipTypeType struct
    open class MemberChangeMembershipTypeType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberChangeMembershipTypeTypeSerializer().serialize(self)))"
        }
    }
    open class MemberChangeMembershipTypeTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberChangeMembershipTypeType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberChangeMembershipTypeType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return MemberChangeMembershipTypeType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed team member name.
    open class MemberChangeNameDetails: CustomStringConvertible {
        /// New user's name.
        public let newValue: TeamLog.UserNameLogInfo
        /// Previous user's name. Might be missing due to historical data gap.
        public let previousValue: TeamLog.UserNameLogInfo?
        public init(newValue: TeamLog.UserNameLogInfo, previousValue: TeamLog.UserNameLogInfo? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberChangeNameDetailsSerializer().serialize(self)))"
        }
    }
    open class MemberChangeNameDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberChangeNameDetails) -> JSON {
            let output = [ 
            "new_value": TeamLog.UserNameLogInfoSerializer().serialize(value.newValue),
            "previous_value": NullableSerializer(TeamLog.UserNameLogInfoSerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberChangeNameDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = TeamLog.UserNameLogInfoSerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(TeamLog.UserNameLogInfoSerializer()).deserialize(dict["previous_value"] ?? .null)
                    return MemberChangeNameDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MemberChangeNameType struct
    open class MemberChangeNameType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberChangeNameTypeSerializer().serialize(self)))"
        }
    }
    open class MemberChangeNameTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberChangeNameType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberChangeNameType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return MemberChangeNameType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed member status (invited, joined, suspended, etc.).
    open class MemberChangeStatusDetails: CustomStringConvertible {
        /// Previous member status. Might be missing due to historical data gap.
        public let previousValue: TeamLog.MemberStatus?
        /// New member status.
        public let newValue: TeamLog.MemberStatus
        /// Additional information indicating the action taken that caused status change.
        public let action: TeamLog.ActionDetails?
        public init(newValue: TeamLog.MemberStatus, previousValue: TeamLog.MemberStatus? = nil, action: TeamLog.ActionDetails? = nil) {
            self.previousValue = previousValue
            self.newValue = newValue
            self.action = action
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberChangeStatusDetailsSerializer().serialize(self)))"
        }
    }
    open class MemberChangeStatusDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberChangeStatusDetails) -> JSON {
            let output = [ 
            "new_value": TeamLog.MemberStatusSerializer().serialize(value.newValue),
            "previous_value": NullableSerializer(TeamLog.MemberStatusSerializer()).serialize(value.previousValue),
            "action": NullableSerializer(TeamLog.ActionDetailsSerializer()).serialize(value.action),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberChangeStatusDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = TeamLog.MemberStatusSerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(TeamLog.MemberStatusSerializer()).deserialize(dict["previous_value"] ?? .null)
                    let action = NullableSerializer(TeamLog.ActionDetailsSerializer()).deserialize(dict["action"] ?? .null)
                    return MemberChangeStatusDetails(newValue: newValue, previousValue: previousValue, action: action)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MemberChangeStatusType struct
    open class MemberChangeStatusType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberChangeStatusTypeSerializer().serialize(self)))"
        }
    }
    open class MemberChangeStatusTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberChangeStatusType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberChangeStatusType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return MemberChangeStatusType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Cleared manually added contacts.
    open class MemberDeleteManualContactsDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberDeleteManualContactsDetailsSerializer().serialize(self)))"
        }
    }
    open class MemberDeleteManualContactsDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberDeleteManualContactsDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberDeleteManualContactsDetails {
            switch json {
                case .dictionary(_):
                    return MemberDeleteManualContactsDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MemberDeleteManualContactsType struct
    open class MemberDeleteManualContactsType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberDeleteManualContactsTypeSerializer().serialize(self)))"
        }
    }
    open class MemberDeleteManualContactsTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberDeleteManualContactsType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberDeleteManualContactsType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return MemberDeleteManualContactsType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Permanently deleted contents of deleted team member account.
    open class MemberPermanentlyDeleteAccountContentsDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberPermanentlyDeleteAccountContentsDetailsSerializer().serialize(self)))"
        }
    }
    open class MemberPermanentlyDeleteAccountContentsDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberPermanentlyDeleteAccountContentsDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberPermanentlyDeleteAccountContentsDetails {
            switch json {
                case .dictionary(_):
                    return MemberPermanentlyDeleteAccountContentsDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MemberPermanentlyDeleteAccountContentsType struct
    open class MemberPermanentlyDeleteAccountContentsType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberPermanentlyDeleteAccountContentsTypeSerializer().serialize(self)))"
        }
    }
    open class MemberPermanentlyDeleteAccountContentsTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberPermanentlyDeleteAccountContentsType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberPermanentlyDeleteAccountContentsType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return MemberPermanentlyDeleteAccountContentsType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MemberRemoveActionType union
    public enum MemberRemoveActionType: CustomStringConvertible {
        /// An unspecified error.
        case delete
        /// An unspecified error.
        case offboard
        /// An unspecified error.
        case leave
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberRemoveActionTypeSerializer().serialize(self)))"
        }
    }
    open class MemberRemoveActionTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberRemoveActionType) -> JSON {
            switch value {
                case .delete:
                    var d = [String: JSON]()
                    d[".tag"] = .str("delete")
                    return .dictionary(d)
                case .offboard:
                    var d = [String: JSON]()
                    d[".tag"] = .str("offboard")
                    return .dictionary(d)
                case .leave:
                    var d = [String: JSON]()
                    d[".tag"] = .str("leave")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> MemberRemoveActionType {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "delete":
                            return MemberRemoveActionType.delete
                        case "offboard":
                            return MemberRemoveActionType.offboard
                        case "leave":
                            return MemberRemoveActionType.leave
                        case "other":
                            return MemberRemoveActionType.other
                        default:
                            return MemberRemoveActionType.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Changed whether users can find team when not invited.
    open class MemberRequestsChangePolicyDetails: CustomStringConvertible {
        /// New member change requests policy.
        public let newValue: TeamLog.MemberRequestsPolicy
        /// Previous member change requests policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.MemberRequestsPolicy?
        public init(newValue: TeamLog.MemberRequestsPolicy, previousValue: TeamLog.MemberRequestsPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberRequestsChangePolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class MemberRequestsChangePolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberRequestsChangePolicyDetails) -> JSON {
            let output = [ 
            "new_value": TeamLog.MemberRequestsPolicySerializer().serialize(value.newValue),
            "previous_value": NullableSerializer(TeamLog.MemberRequestsPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberRequestsChangePolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = TeamLog.MemberRequestsPolicySerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(TeamLog.MemberRequestsPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                    return MemberRequestsChangePolicyDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MemberRequestsChangePolicyType struct
    open class MemberRequestsChangePolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberRequestsChangePolicyTypeSerializer().serialize(self)))"
        }
    }
    open class MemberRequestsChangePolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberRequestsChangePolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberRequestsChangePolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return MemberRequestsChangePolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MemberRequestsPolicy union
    public enum MemberRequestsPolicy: CustomStringConvertible {
        /// An unspecified error.
        case autoAccept
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case requireApproval
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberRequestsPolicySerializer().serialize(self)))"
        }
    }
    open class MemberRequestsPolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberRequestsPolicy) -> JSON {
            switch value {
                case .autoAccept:
                    var d = [String: JSON]()
                    d[".tag"] = .str("auto_accept")
                    return .dictionary(d)
                case .disabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disabled")
                    return .dictionary(d)
                case .requireApproval:
                    var d = [String: JSON]()
                    d[".tag"] = .str("require_approval")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> MemberRequestsPolicy {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "auto_accept":
                            return MemberRequestsPolicy.autoAccept
                        case "disabled":
                            return MemberRequestsPolicy.disabled
                        case "require_approval":
                            return MemberRequestsPolicy.requireApproval
                        case "other":
                            return MemberRequestsPolicy.other
                        default:
                            return MemberRequestsPolicy.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Set custom member space limit.
    open class MemberSpaceLimitsAddCustomQuotaDetails: CustomStringConvertible {
        /// New custom quota value in bytes.
        public let newValue: UInt64
        public init(newValue: UInt64) {
            comparableValidator()(newValue)
            self.newValue = newValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberSpaceLimitsAddCustomQuotaDetailsSerializer().serialize(self)))"
        }
    }
    open class MemberSpaceLimitsAddCustomQuotaDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberSpaceLimitsAddCustomQuotaDetails) -> JSON {
            let output = [ 
            "new_value": Serialization._UInt64Serializer.serialize(value.newValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberSpaceLimitsAddCustomQuotaDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = Serialization._UInt64Serializer.deserialize(dict["new_value"] ?? .null)
                    return MemberSpaceLimitsAddCustomQuotaDetails(newValue: newValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MemberSpaceLimitsAddCustomQuotaType struct
    open class MemberSpaceLimitsAddCustomQuotaType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberSpaceLimitsAddCustomQuotaTypeSerializer().serialize(self)))"
        }
    }
    open class MemberSpaceLimitsAddCustomQuotaTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberSpaceLimitsAddCustomQuotaType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberSpaceLimitsAddCustomQuotaType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return MemberSpaceLimitsAddCustomQuotaType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Added members to member space limit exception list.
    open class MemberSpaceLimitsAddExceptionDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberSpaceLimitsAddExceptionDetailsSerializer().serialize(self)))"
        }
    }
    open class MemberSpaceLimitsAddExceptionDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberSpaceLimitsAddExceptionDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberSpaceLimitsAddExceptionDetails {
            switch json {
                case .dictionary(_):
                    return MemberSpaceLimitsAddExceptionDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MemberSpaceLimitsAddExceptionType struct
    open class MemberSpaceLimitsAddExceptionType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberSpaceLimitsAddExceptionTypeSerializer().serialize(self)))"
        }
    }
    open class MemberSpaceLimitsAddExceptionTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberSpaceLimitsAddExceptionType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberSpaceLimitsAddExceptionType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return MemberSpaceLimitsAddExceptionType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed member space limit type for team.
    open class MemberSpaceLimitsChangeCapsTypePolicyDetails: CustomStringConvertible {
        /// Previous space limit type.
        public let previousValue: TeamLog.SpaceCapsType
        /// New space limit type.
        public let newValue: TeamLog.SpaceCapsType
        public init(previousValue: TeamLog.SpaceCapsType, newValue: TeamLog.SpaceCapsType) {
            self.previousValue = previousValue
            self.newValue = newValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberSpaceLimitsChangeCapsTypePolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class MemberSpaceLimitsChangeCapsTypePolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberSpaceLimitsChangeCapsTypePolicyDetails) -> JSON {
            let output = [ 
            "previous_value": TeamLog.SpaceCapsTypeSerializer().serialize(value.previousValue),
            "new_value": TeamLog.SpaceCapsTypeSerializer().serialize(value.newValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberSpaceLimitsChangeCapsTypePolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let previousValue = TeamLog.SpaceCapsTypeSerializer().deserialize(dict["previous_value"] ?? .null)
                    let newValue = TeamLog.SpaceCapsTypeSerializer().deserialize(dict["new_value"] ?? .null)
                    return MemberSpaceLimitsChangeCapsTypePolicyDetails(previousValue: previousValue, newValue: newValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MemberSpaceLimitsChangeCapsTypePolicyType struct
    open class MemberSpaceLimitsChangeCapsTypePolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberSpaceLimitsChangeCapsTypePolicyTypeSerializer().serialize(self)))"
        }
    }
    open class MemberSpaceLimitsChangeCapsTypePolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberSpaceLimitsChangeCapsTypePolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberSpaceLimitsChangeCapsTypePolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return MemberSpaceLimitsChangeCapsTypePolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed custom member space limit.
    open class MemberSpaceLimitsChangeCustomQuotaDetails: CustomStringConvertible {
        /// Previous custom quota value in bytes.
        public let previousValue: UInt64
        /// New custom quota value in bytes.
        public let newValue: UInt64
        public init(previousValue: UInt64, newValue: UInt64) {
            comparableValidator()(previousValue)
            self.previousValue = previousValue
            comparableValidator()(newValue)
            self.newValue = newValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberSpaceLimitsChangeCustomQuotaDetailsSerializer().serialize(self)))"
        }
    }
    open class MemberSpaceLimitsChangeCustomQuotaDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberSpaceLimitsChangeCustomQuotaDetails) -> JSON {
            let output = [ 
            "previous_value": Serialization._UInt64Serializer.serialize(value.previousValue),
            "new_value": Serialization._UInt64Serializer.serialize(value.newValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberSpaceLimitsChangeCustomQuotaDetails {
            switch json {
                case .dictionary(let dict):
                    let previousValue = Serialization._UInt64Serializer.deserialize(dict["previous_value"] ?? .null)
                    let newValue = Serialization._UInt64Serializer.deserialize(dict["new_value"] ?? .null)
                    return MemberSpaceLimitsChangeCustomQuotaDetails(previousValue: previousValue, newValue: newValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MemberSpaceLimitsChangeCustomQuotaType struct
    open class MemberSpaceLimitsChangeCustomQuotaType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberSpaceLimitsChangeCustomQuotaTypeSerializer().serialize(self)))"
        }
    }
    open class MemberSpaceLimitsChangeCustomQuotaTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberSpaceLimitsChangeCustomQuotaType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberSpaceLimitsChangeCustomQuotaType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return MemberSpaceLimitsChangeCustomQuotaType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed team default member space limit.
    open class MemberSpaceLimitsChangePolicyDetails: CustomStringConvertible {
        /// Previous team default limit value in bytes. Might be missing due to historical data gap.
        public let previousValue: UInt64?
        /// New team default limit value in bytes. Might be missing due to historical data gap.
        public let newValue: UInt64?
        public init(previousValue: UInt64? = nil, newValue: UInt64? = nil) {
            nullableValidator(comparableValidator())(previousValue)
            self.previousValue = previousValue
            nullableValidator(comparableValidator())(newValue)
            self.newValue = newValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberSpaceLimitsChangePolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class MemberSpaceLimitsChangePolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberSpaceLimitsChangePolicyDetails) -> JSON {
            let output = [ 
            "previous_value": NullableSerializer(Serialization._UInt64Serializer).serialize(value.previousValue),
            "new_value": NullableSerializer(Serialization._UInt64Serializer).serialize(value.newValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberSpaceLimitsChangePolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let previousValue = NullableSerializer(Serialization._UInt64Serializer).deserialize(dict["previous_value"] ?? .null)
                    let newValue = NullableSerializer(Serialization._UInt64Serializer).deserialize(dict["new_value"] ?? .null)
                    return MemberSpaceLimitsChangePolicyDetails(previousValue: previousValue, newValue: newValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MemberSpaceLimitsChangePolicyType struct
    open class MemberSpaceLimitsChangePolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberSpaceLimitsChangePolicyTypeSerializer().serialize(self)))"
        }
    }
    open class MemberSpaceLimitsChangePolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberSpaceLimitsChangePolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberSpaceLimitsChangePolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return MemberSpaceLimitsChangePolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed space limit status.
    open class MemberSpaceLimitsChangeStatusDetails: CustomStringConvertible {
        /// Previous storage quota status.
        public let previousValue: TeamLog.SpaceLimitsStatus
        /// New storage quota status.
        public let newValue: TeamLog.SpaceLimitsStatus
        public init(previousValue: TeamLog.SpaceLimitsStatus, newValue: TeamLog.SpaceLimitsStatus) {
            self.previousValue = previousValue
            self.newValue = newValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberSpaceLimitsChangeStatusDetailsSerializer().serialize(self)))"
        }
    }
    open class MemberSpaceLimitsChangeStatusDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberSpaceLimitsChangeStatusDetails) -> JSON {
            let output = [ 
            "previous_value": TeamLog.SpaceLimitsStatusSerializer().serialize(value.previousValue),
            "new_value": TeamLog.SpaceLimitsStatusSerializer().serialize(value.newValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberSpaceLimitsChangeStatusDetails {
            switch json {
                case .dictionary(let dict):
                    let previousValue = TeamLog.SpaceLimitsStatusSerializer().deserialize(dict["previous_value"] ?? .null)
                    let newValue = TeamLog.SpaceLimitsStatusSerializer().deserialize(dict["new_value"] ?? .null)
                    return MemberSpaceLimitsChangeStatusDetails(previousValue: previousValue, newValue: newValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MemberSpaceLimitsChangeStatusType struct
    open class MemberSpaceLimitsChangeStatusType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberSpaceLimitsChangeStatusTypeSerializer().serialize(self)))"
        }
    }
    open class MemberSpaceLimitsChangeStatusTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberSpaceLimitsChangeStatusType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberSpaceLimitsChangeStatusType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return MemberSpaceLimitsChangeStatusType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Removed custom member space limit.
    open class MemberSpaceLimitsRemoveCustomQuotaDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberSpaceLimitsRemoveCustomQuotaDetailsSerializer().serialize(self)))"
        }
    }
    open class MemberSpaceLimitsRemoveCustomQuotaDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberSpaceLimitsRemoveCustomQuotaDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberSpaceLimitsRemoveCustomQuotaDetails {
            switch json {
                case .dictionary(_):
                    return MemberSpaceLimitsRemoveCustomQuotaDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MemberSpaceLimitsRemoveCustomQuotaType struct
    open class MemberSpaceLimitsRemoveCustomQuotaType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberSpaceLimitsRemoveCustomQuotaTypeSerializer().serialize(self)))"
        }
    }
    open class MemberSpaceLimitsRemoveCustomQuotaTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberSpaceLimitsRemoveCustomQuotaType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberSpaceLimitsRemoveCustomQuotaType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return MemberSpaceLimitsRemoveCustomQuotaType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Removed members from member space limit exception list.
    open class MemberSpaceLimitsRemoveExceptionDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberSpaceLimitsRemoveExceptionDetailsSerializer().serialize(self)))"
        }
    }
    open class MemberSpaceLimitsRemoveExceptionDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberSpaceLimitsRemoveExceptionDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberSpaceLimitsRemoveExceptionDetails {
            switch json {
                case .dictionary(_):
                    return MemberSpaceLimitsRemoveExceptionDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MemberSpaceLimitsRemoveExceptionType struct
    open class MemberSpaceLimitsRemoveExceptionType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberSpaceLimitsRemoveExceptionTypeSerializer().serialize(self)))"
        }
    }
    open class MemberSpaceLimitsRemoveExceptionTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberSpaceLimitsRemoveExceptionType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberSpaceLimitsRemoveExceptionType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return MemberSpaceLimitsRemoveExceptionType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MemberStatus union
    public enum MemberStatus: CustomStringConvertible {
        /// An unspecified error.
        case notJoined
        /// An unspecified error.
        case invited
        /// An unspecified error.
        case active
        /// An unspecified error.
        case suspended
        /// An unspecified error.
        case removed
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberStatusSerializer().serialize(self)))"
        }
    }
    open class MemberStatusSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberStatus) -> JSON {
            switch value {
                case .notJoined:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_joined")
                    return .dictionary(d)
                case .invited:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invited")
                    return .dictionary(d)
                case .active:
                    var d = [String: JSON]()
                    d[".tag"] = .str("active")
                    return .dictionary(d)
                case .suspended:
                    var d = [String: JSON]()
                    d[".tag"] = .str("suspended")
                    return .dictionary(d)
                case .removed:
                    var d = [String: JSON]()
                    d[".tag"] = .str("removed")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> MemberStatus {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "not_joined":
                            return MemberStatus.notJoined
                        case "invited":
                            return MemberStatus.invited
                        case "active":
                            return MemberStatus.active
                        case "suspended":
                            return MemberStatus.suspended
                        case "removed":
                            return MemberStatus.removed
                        case "other":
                            return MemberStatus.other
                        default:
                            return MemberStatus.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Suggested person to add to team.
    open class MemberSuggestDetails: CustomStringConvertible {
        /// suggested users emails.
        public let suggestedMembers: Array<String>
        public init(suggestedMembers: Array<String>) {
            arrayValidator(itemValidator: stringValidator(maxLength: 255))(suggestedMembers)
            self.suggestedMembers = suggestedMembers
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberSuggestDetailsSerializer().serialize(self)))"
        }
    }
    open class MemberSuggestDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberSuggestDetails) -> JSON {
            let output = [ 
            "suggested_members": ArraySerializer(Serialization._StringSerializer).serialize(value.suggestedMembers),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberSuggestDetails {
            switch json {
                case .dictionary(let dict):
                    let suggestedMembers = ArraySerializer(Serialization._StringSerializer).deserialize(dict["suggested_members"] ?? .null)
                    return MemberSuggestDetails(suggestedMembers: suggestedMembers)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MemberSuggestType struct
    open class MemberSuggestType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberSuggestTypeSerializer().serialize(self)))"
        }
    }
    open class MemberSuggestTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberSuggestType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberSuggestType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return MemberSuggestType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Enabled/disabled option for team members to suggest people to add to team.
    open class MemberSuggestionsChangePolicyDetails: CustomStringConvertible {
        /// New team member suggestions policy.
        public let newValue: TeamLog.MemberSuggestionsPolicy
        /// Previous team member suggestions policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.MemberSuggestionsPolicy?
        public init(newValue: TeamLog.MemberSuggestionsPolicy, previousValue: TeamLog.MemberSuggestionsPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberSuggestionsChangePolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class MemberSuggestionsChangePolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberSuggestionsChangePolicyDetails) -> JSON {
            let output = [ 
            "new_value": TeamLog.MemberSuggestionsPolicySerializer().serialize(value.newValue),
            "previous_value": NullableSerializer(TeamLog.MemberSuggestionsPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberSuggestionsChangePolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = TeamLog.MemberSuggestionsPolicySerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(TeamLog.MemberSuggestionsPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                    return MemberSuggestionsChangePolicyDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MemberSuggestionsChangePolicyType struct
    open class MemberSuggestionsChangePolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberSuggestionsChangePolicyTypeSerializer().serialize(self)))"
        }
    }
    open class MemberSuggestionsChangePolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberSuggestionsChangePolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberSuggestionsChangePolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return MemberSuggestionsChangePolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Member suggestions policy
    public enum MemberSuggestionsPolicy: CustomStringConvertible {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberSuggestionsPolicySerializer().serialize(self)))"
        }
    }
    open class MemberSuggestionsPolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberSuggestionsPolicy) -> JSON {
            switch value {
                case .disabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disabled")
                    return .dictionary(d)
                case .enabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("enabled")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> MemberSuggestionsPolicy {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "disabled":
                            return MemberSuggestionsPolicy.disabled
                        case "enabled":
                            return MemberSuggestionsPolicy.enabled
                        case "other":
                            return MemberSuggestionsPolicy.other
                        default:
                            return MemberSuggestionsPolicy.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Transferred contents of deleted member account to another member.
    open class MemberTransferAccountContentsDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberTransferAccountContentsDetailsSerializer().serialize(self)))"
        }
    }
    open class MemberTransferAccountContentsDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberTransferAccountContentsDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberTransferAccountContentsDetails {
            switch json {
                case .dictionary(_):
                    return MemberTransferAccountContentsDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MemberTransferAccountContentsType struct
    open class MemberTransferAccountContentsType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberTransferAccountContentsTypeSerializer().serialize(self)))"
        }
    }
    open class MemberTransferAccountContentsTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberTransferAccountContentsType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberTransferAccountContentsType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return MemberTransferAccountContentsType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Enabled/disabled Microsoft Office add-in.
    open class MicrosoftOfficeAddinChangePolicyDetails: CustomStringConvertible {
        /// New Microsoft Office addin policy.
        public let newValue: TeamLog.MicrosoftOfficeAddinPolicy
        /// Previous Microsoft Office addin policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.MicrosoftOfficeAddinPolicy?
        public init(newValue: TeamLog.MicrosoftOfficeAddinPolicy, previousValue: TeamLog.MicrosoftOfficeAddinPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MicrosoftOfficeAddinChangePolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class MicrosoftOfficeAddinChangePolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MicrosoftOfficeAddinChangePolicyDetails) -> JSON {
            let output = [ 
            "new_value": TeamLog.MicrosoftOfficeAddinPolicySerializer().serialize(value.newValue),
            "previous_value": NullableSerializer(TeamLog.MicrosoftOfficeAddinPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MicrosoftOfficeAddinChangePolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = TeamLog.MicrosoftOfficeAddinPolicySerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(TeamLog.MicrosoftOfficeAddinPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                    return MicrosoftOfficeAddinChangePolicyDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MicrosoftOfficeAddinChangePolicyType struct
    open class MicrosoftOfficeAddinChangePolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MicrosoftOfficeAddinChangePolicyTypeSerializer().serialize(self)))"
        }
    }
    open class MicrosoftOfficeAddinChangePolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MicrosoftOfficeAddinChangePolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MicrosoftOfficeAddinChangePolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return MicrosoftOfficeAddinChangePolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Microsoft Office addin policy
    public enum MicrosoftOfficeAddinPolicy: CustomStringConvertible {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MicrosoftOfficeAddinPolicySerializer().serialize(self)))"
        }
    }
    open class MicrosoftOfficeAddinPolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MicrosoftOfficeAddinPolicy) -> JSON {
            switch value {
                case .disabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disabled")
                    return .dictionary(d)
                case .enabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("enabled")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> MicrosoftOfficeAddinPolicy {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "disabled":
                            return MicrosoftOfficeAddinPolicy.disabled
                        case "enabled":
                            return MicrosoftOfficeAddinPolicy.enabled
                        case "other":
                            return MicrosoftOfficeAddinPolicy.other
                        default:
                            return MicrosoftOfficeAddinPolicy.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// An indication that an error occurred while retrieving the event. Some attributes of the event may be omitted as
    /// a result.
    open class MissingDetails: CustomStringConvertible {
        /// All the data that could be retrieved and converted from the source event.
        public let sourceEventFields: String?
        public init(sourceEventFields: String? = nil) {
            nullableValidator(stringValidator())(sourceEventFields)
            self.sourceEventFields = sourceEventFields
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MissingDetailsSerializer().serialize(self)))"
        }
    }
    open class MissingDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MissingDetails) -> JSON {
            let output = [ 
            "source_event_fields": NullableSerializer(Serialization._StringSerializer).serialize(value.sourceEventFields),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MissingDetails {
            switch json {
                case .dictionary(let dict):
                    let sourceEventFields = NullableSerializer(Serialization._StringSerializer).deserialize(dict["source_event_fields"] ?? .null)
                    return MissingDetails(sourceEventFields: sourceEventFields)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Information about linked Dropbox mobile client sessions
    open class MobileDeviceSessionLogInfo: TeamLog.DeviceSessionLogInfo {
        /// Mobile session unique id. Might be missing due to historical data gap.
        public let sessionInfo: TeamLog.MobileSessionLogInfo?
        /// The device name.
        public let deviceName: String
        /// The mobile application type.
        public let clientType: Team.MobileClientPlatform
        /// The Dropbox client version.
        public let clientVersion: String?
        /// The hosting OS version.
        public let osVersion: String?
        /// last carrier used by the device.
        public let lastCarrier: String?
        public init(deviceName: String, clientType: Team.MobileClientPlatform, ipAddress: String? = nil, created: Date? = nil, updated: Date? = nil, sessionInfo: TeamLog.MobileSessionLogInfo? = nil, clientVersion: String? = nil, osVersion: String? = nil, lastCarrier: String? = nil) {
            self.sessionInfo = sessionInfo
            stringValidator()(deviceName)
            self.deviceName = deviceName
            self.clientType = clientType
            nullableValidator(stringValidator())(clientVersion)
            self.clientVersion = clientVersion
            nullableValidator(stringValidator())(osVersion)
            self.osVersion = osVersion
            nullableValidator(stringValidator())(lastCarrier)
            self.lastCarrier = lastCarrier
            super.init(ipAddress: ipAddress, created: created, updated: updated)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MobileDeviceSessionLogInfoSerializer().serialize(self)))"
        }
    }
    open class MobileDeviceSessionLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MobileDeviceSessionLogInfo) -> JSON {
            let output = [ 
            "device_name": Serialization._StringSerializer.serialize(value.deviceName),
            "client_type": Team.MobileClientPlatformSerializer().serialize(value.clientType),
            "ip_address": NullableSerializer(Serialization._StringSerializer).serialize(value.ipAddress),
            "created": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.created),
            "updated": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.updated),
            "session_info": NullableSerializer(TeamLog.MobileSessionLogInfoSerializer()).serialize(value.sessionInfo),
            "client_version": NullableSerializer(Serialization._StringSerializer).serialize(value.clientVersion),
            "os_version": NullableSerializer(Serialization._StringSerializer).serialize(value.osVersion),
            "last_carrier": NullableSerializer(Serialization._StringSerializer).serialize(value.lastCarrier),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MobileDeviceSessionLogInfo {
            switch json {
                case .dictionary(let dict):
                    let deviceName = Serialization._StringSerializer.deserialize(dict["device_name"] ?? .null)
                    let clientType = Team.MobileClientPlatformSerializer().deserialize(dict["client_type"] ?? .null)
                    let ipAddress = NullableSerializer(Serialization._StringSerializer).deserialize(dict["ip_address"] ?? .null)
                    let created = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["created"] ?? .null)
                    let updated = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["updated"] ?? .null)
                    let sessionInfo = NullableSerializer(TeamLog.MobileSessionLogInfoSerializer()).deserialize(dict["session_info"] ?? .null)
                    let clientVersion = NullableSerializer(Serialization._StringSerializer).deserialize(dict["client_version"] ?? .null)
                    let osVersion = NullableSerializer(Serialization._StringSerializer).deserialize(dict["os_version"] ?? .null)
                    let lastCarrier = NullableSerializer(Serialization._StringSerializer).deserialize(dict["last_carrier"] ?? .null)
                    return MobileDeviceSessionLogInfo(deviceName: deviceName, clientType: clientType, ipAddress: ipAddress, created: created, updated: updated, sessionInfo: sessionInfo, clientVersion: clientVersion, osVersion: osVersion, lastCarrier: lastCarrier)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Mobile session.
    open class MobileSessionLogInfo: TeamLog.SessionLogInfo {
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MobileSessionLogInfoSerializer().serialize(self)))"
        }
    }
    open class MobileSessionLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MobileSessionLogInfo) -> JSON {
            let output = [ 
            "session_id": NullableSerializer(Serialization._StringSerializer).serialize(value.sessionId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MobileSessionLogInfo {
            switch json {
                case .dictionary(let dict):
                    let sessionId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["session_id"] ?? .null)
                    return MobileSessionLogInfo(sessionId: sessionId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Namespace relative path details.
    open class NamespaceRelativePathLogInfo: CustomStringConvertible {
        /// Namespace ID. Might be missing due to historical data gap.
        public let nsId: String?
        /// A path relative to the specified namespace ID. Might be missing due to historical data gap.
        public let relativePath: String?
        public init(nsId: String? = nil, relativePath: String? = nil) {
            nullableValidator(stringValidator())(nsId)
            self.nsId = nsId
            nullableValidator(stringValidator())(relativePath)
            self.relativePath = relativePath
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(NamespaceRelativePathLogInfoSerializer().serialize(self)))"
        }
    }
    open class NamespaceRelativePathLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: NamespaceRelativePathLogInfo) -> JSON {
            let output = [ 
            "ns_id": NullableSerializer(Serialization._StringSerializer).serialize(value.nsId),
            "relative_path": NullableSerializer(Serialization._StringSerializer).serialize(value.relativePath),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> NamespaceRelativePathLogInfo {
            switch json {
                case .dictionary(let dict):
                    let nsId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["ns_id"] ?? .null)
                    let relativePath = NullableSerializer(Serialization._StringSerializer).deserialize(dict["relative_path"] ?? .null)
                    return NamespaceRelativePathLogInfo(nsId: nsId, relativePath: relativePath)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Enabled/disabled network control.
    open class NetworkControlChangePolicyDetails: CustomStringConvertible {
        /// New network control policy.
        public let newValue: TeamLog.NetworkControlPolicy
        /// Previous network control policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.NetworkControlPolicy?
        public init(newValue: TeamLog.NetworkControlPolicy, previousValue: TeamLog.NetworkControlPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(NetworkControlChangePolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class NetworkControlChangePolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: NetworkControlChangePolicyDetails) -> JSON {
            let output = [ 
            "new_value": TeamLog.NetworkControlPolicySerializer().serialize(value.newValue),
            "previous_value": NullableSerializer(TeamLog.NetworkControlPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> NetworkControlChangePolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = TeamLog.NetworkControlPolicySerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(TeamLog.NetworkControlPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                    return NetworkControlChangePolicyDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The NetworkControlChangePolicyType struct
    open class NetworkControlChangePolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(NetworkControlChangePolicyTypeSerializer().serialize(self)))"
        }
    }
    open class NetworkControlChangePolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: NetworkControlChangePolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> NetworkControlChangePolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return NetworkControlChangePolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Network control policy
    public enum NetworkControlPolicy: CustomStringConvertible {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(NetworkControlPolicySerializer().serialize(self)))"
        }
    }
    open class NetworkControlPolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: NetworkControlPolicy) -> JSON {
            switch value {
                case .disabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disabled")
                    return .dictionary(d)
                case .enabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("enabled")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> NetworkControlPolicy {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "disabled":
                            return NetworkControlPolicy.disabled
                        case "enabled":
                            return NetworkControlPolicy.enabled
                        case "other":
                            return NetworkControlPolicy.other
                        default:
                            return NetworkControlPolicy.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// User's logged information.
    open class UserLogInfo: CustomStringConvertible {
        /// User unique ID. Might be missing due to historical data gap.
        public let accountId: String?
        /// User display name. Might be missing due to historical data gap.
        public let displayName: String?
        /// User email address. Might be missing due to historical data gap.
        public let email: String?
        public init(accountId: String? = nil, displayName: String? = nil, email: String? = nil) {
            nullableValidator(stringValidator(minLength: 40, maxLength: 40))(accountId)
            self.accountId = accountId
            nullableValidator(stringValidator())(displayName)
            self.displayName = displayName
            nullableValidator(stringValidator(maxLength: 255))(email)
            self.email = email
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UserLogInfoSerializer().serialize(self)))"
        }
    }
    open class UserLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UserLogInfo) -> JSON {
            var output = [ 
            "account_id": NullableSerializer(Serialization._StringSerializer).serialize(value.accountId),
            "display_name": NullableSerializer(Serialization._StringSerializer).serialize(value.displayName),
            "email": NullableSerializer(Serialization._StringSerializer).serialize(value.email),
            ]
            switch value {
                case let teamMember as TeamLog.TeamMemberLogInfo:
                    for (k, v) in Serialization.getFields(TeamLog.TeamMemberLogInfoSerializer().serialize(teamMember)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("team_member")
                case let trustedNonTeamMember as TeamLog.TrustedNonTeamMemberLogInfo:
                    for (k, v) in Serialization.getFields(TeamLog.TrustedNonTeamMemberLogInfoSerializer().serialize(trustedNonTeamMember)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("trusted_non_team_member")
                case let nonTeamMember as TeamLog.NonTeamMemberLogInfo:
                    for (k, v) in Serialization.getFields(TeamLog.NonTeamMemberLogInfoSerializer().serialize(nonTeamMember)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("non_team_member")
                default: fatalError("Tried to serialize unexpected subtype")
            }
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UserLogInfo {
            switch json {
                case .dictionary(let dict):
                    let tag = Serialization.getTag(dict)
                    switch tag {
                        case "team_member":
                            return TeamLog.TeamMemberLogInfoSerializer().deserialize(json)
                        case "trusted_non_team_member":
                            return TeamLog.TrustedNonTeamMemberLogInfoSerializer().deserialize(json)
                        case "non_team_member":
                            return TeamLog.NonTeamMemberLogInfoSerializer().deserialize(json)
                        default:
                            let accountId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["account_id"] ?? .null)
                            let displayName = NullableSerializer(Serialization._StringSerializer).deserialize(dict["display_name"] ?? .null)
                            let email = NullableSerializer(Serialization._StringSerializer).deserialize(dict["email"] ?? .null)
                            return UserLogInfo(accountId: accountId, displayName: displayName, email: email)
                    }
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Non team member's logged information.
    open class NonTeamMemberLogInfo: TeamLog.UserLogInfo {
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(NonTeamMemberLogInfoSerializer().serialize(self)))"
        }
    }
    open class NonTeamMemberLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: NonTeamMemberLogInfo) -> JSON {
            let output = [ 
            "account_id": NullableSerializer(Serialization._StringSerializer).serialize(value.accountId),
            "display_name": NullableSerializer(Serialization._StringSerializer).serialize(value.displayName),
            "email": NullableSerializer(Serialization._StringSerializer).serialize(value.email),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> NonTeamMemberLogInfo {
            switch json {
                case .dictionary(let dict):
                    let accountId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["account_id"] ?? .null)
                    let displayName = NullableSerializer(Serialization._StringSerializer).deserialize(dict["display_name"] ?? .null)
                    let email = NullableSerializer(Serialization._StringSerializer).deserialize(dict["email"] ?? .null)
                    return NonTeamMemberLogInfo(accountId: accountId, displayName: displayName, email: email)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed Paper doc to invite-only.
    open class NoteAclInviteOnlyDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(NoteAclInviteOnlyDetailsSerializer().serialize(self)))"
        }
    }
    open class NoteAclInviteOnlyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: NoteAclInviteOnlyDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> NoteAclInviteOnlyDetails {
            switch json {
                case .dictionary(_):
                    return NoteAclInviteOnlyDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The NoteAclInviteOnlyType struct
    open class NoteAclInviteOnlyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(NoteAclInviteOnlyTypeSerializer().serialize(self)))"
        }
    }
    open class NoteAclInviteOnlyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: NoteAclInviteOnlyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> NoteAclInviteOnlyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return NoteAclInviteOnlyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed Paper doc to link-accessible.
    open class NoteAclLinkDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(NoteAclLinkDetailsSerializer().serialize(self)))"
        }
    }
    open class NoteAclLinkDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: NoteAclLinkDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> NoteAclLinkDetails {
            switch json {
                case .dictionary(_):
                    return NoteAclLinkDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The NoteAclLinkType struct
    open class NoteAclLinkType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(NoteAclLinkTypeSerializer().serialize(self)))"
        }
    }
    open class NoteAclLinkTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: NoteAclLinkType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> NoteAclLinkType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return NoteAclLinkType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed Paper doc to link-accessible for team.
    open class NoteAclTeamLinkDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(NoteAclTeamLinkDetailsSerializer().serialize(self)))"
        }
    }
    open class NoteAclTeamLinkDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: NoteAclTeamLinkDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> NoteAclTeamLinkDetails {
            switch json {
                case .dictionary(_):
                    return NoteAclTeamLinkDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The NoteAclTeamLinkType struct
    open class NoteAclTeamLinkType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(NoteAclTeamLinkTypeSerializer().serialize(self)))"
        }
    }
    open class NoteAclTeamLinkTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: NoteAclTeamLinkType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> NoteAclTeamLinkType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return NoteAclTeamLinkType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Shared received Paper doc.
    open class NoteShareReceiveDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(NoteShareReceiveDetailsSerializer().serialize(self)))"
        }
    }
    open class NoteShareReceiveDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: NoteShareReceiveDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> NoteShareReceiveDetails {
            switch json {
                case .dictionary(_):
                    return NoteShareReceiveDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The NoteShareReceiveType struct
    open class NoteShareReceiveType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(NoteShareReceiveTypeSerializer().serialize(self)))"
        }
    }
    open class NoteShareReceiveTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: NoteShareReceiveType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> NoteShareReceiveType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return NoteShareReceiveType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Shared Paper doc.
    open class NoteSharedDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(NoteSharedDetailsSerializer().serialize(self)))"
        }
    }
    open class NoteSharedDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: NoteSharedDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> NoteSharedDetails {
            switch json {
                case .dictionary(_):
                    return NoteSharedDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The NoteSharedType struct
    open class NoteSharedType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(NoteSharedTypeSerializer().serialize(self)))"
        }
    }
    open class NoteSharedTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: NoteSharedType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> NoteSharedType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return NoteSharedType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Opened shared Paper doc.
    open class OpenNoteSharedDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(OpenNoteSharedDetailsSerializer().serialize(self)))"
        }
    }
    open class OpenNoteSharedDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: OpenNoteSharedDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> OpenNoteSharedDetails {
            switch json {
                case .dictionary(_):
                    return OpenNoteSharedDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The OpenNoteSharedType struct
    open class OpenNoteSharedType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(OpenNoteSharedTypeSerializer().serialize(self)))"
        }
    }
    open class OpenNoteSharedTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: OpenNoteSharedType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> OpenNoteSharedType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return OpenNoteSharedType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The origin from which the actor performed the action.
    open class OriginLogInfo: CustomStringConvertible {
        /// Geographic location details.
        public let geoLocation: TeamLog.GeoLocationLogInfo?
        /// The method that was used to perform the action.
        public let accessMethod: TeamLog.AccessMethodLogInfo
        public init(accessMethod: TeamLog.AccessMethodLogInfo, geoLocation: TeamLog.GeoLocationLogInfo? = nil) {
            self.geoLocation = geoLocation
            self.accessMethod = accessMethod
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(OriginLogInfoSerializer().serialize(self)))"
        }
    }
    open class OriginLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: OriginLogInfo) -> JSON {
            let output = [ 
            "access_method": TeamLog.AccessMethodLogInfoSerializer().serialize(value.accessMethod),
            "geo_location": NullableSerializer(TeamLog.GeoLocationLogInfoSerializer()).serialize(value.geoLocation),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> OriginLogInfo {
            switch json {
                case .dictionary(let dict):
                    let accessMethod = TeamLog.AccessMethodLogInfoSerializer().deserialize(dict["access_method"] ?? .null)
                    let geoLocation = NullableSerializer(TeamLog.GeoLocationLogInfoSerializer()).deserialize(dict["geo_location"] ?? .null)
                    return OriginLogInfo(accessMethod: accessMethod, geoLocation: geoLocation)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperAccessType union
    public enum PaperAccessType: CustomStringConvertible {
        /// An unspecified error.
        case viewer
        /// An unspecified error.
        case commenter
        /// An unspecified error.
        case editor
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperAccessTypeSerializer().serialize(self)))"
        }
    }
    open class PaperAccessTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperAccessType) -> JSON {
            switch value {
                case .viewer:
                    var d = [String: JSON]()
                    d[".tag"] = .str("viewer")
                    return .dictionary(d)
                case .commenter:
                    var d = [String: JSON]()
                    d[".tag"] = .str("commenter")
                    return .dictionary(d)
                case .editor:
                    var d = [String: JSON]()
                    d[".tag"] = .str("editor")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> PaperAccessType {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "viewer":
                            return PaperAccessType.viewer
                        case "commenter":
                            return PaperAccessType.commenter
                        case "editor":
                            return PaperAccessType.editor
                        case "other":
                            return PaperAccessType.other
                        default:
                            return PaperAccessType.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Exported all team Paper docs.
    open class PaperAdminExportStartDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperAdminExportStartDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperAdminExportStartDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperAdminExportStartDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperAdminExportStartDetails {
            switch json {
                case .dictionary(_):
                    return PaperAdminExportStartDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperAdminExportStartType struct
    open class PaperAdminExportStartType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperAdminExportStartTypeSerializer().serialize(self)))"
        }
    }
    open class PaperAdminExportStartTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperAdminExportStartType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperAdminExportStartType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperAdminExportStartType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed whether Dropbox Paper, when enabled, is deployed to all members or to specific members.
    open class PaperChangeDeploymentPolicyDetails: CustomStringConvertible {
        /// New Dropbox Paper deployment policy.
        public let newValue: TeamPolicies.PaperDeploymentPolicy
        /// Previous Dropbox Paper deployment policy. Might be missing due to historical data gap.
        public let previousValue: TeamPolicies.PaperDeploymentPolicy?
        public init(newValue: TeamPolicies.PaperDeploymentPolicy, previousValue: TeamPolicies.PaperDeploymentPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperChangeDeploymentPolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperChangeDeploymentPolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperChangeDeploymentPolicyDetails) -> JSON {
            let output = [ 
            "new_value": TeamPolicies.PaperDeploymentPolicySerializer().serialize(value.newValue),
            "previous_value": NullableSerializer(TeamPolicies.PaperDeploymentPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperChangeDeploymentPolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = TeamPolicies.PaperDeploymentPolicySerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(TeamPolicies.PaperDeploymentPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                    return PaperChangeDeploymentPolicyDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperChangeDeploymentPolicyType struct
    open class PaperChangeDeploymentPolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperChangeDeploymentPolicyTypeSerializer().serialize(self)))"
        }
    }
    open class PaperChangeDeploymentPolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperChangeDeploymentPolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperChangeDeploymentPolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperChangeDeploymentPolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed whether non-members can view Paper docs with link.
    open class PaperChangeMemberLinkPolicyDetails: CustomStringConvertible {
        /// New paper external link accessibility policy.
        public let newValue: TeamLog.PaperMemberPolicy
        public init(newValue: TeamLog.PaperMemberPolicy) {
            self.newValue = newValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperChangeMemberLinkPolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperChangeMemberLinkPolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperChangeMemberLinkPolicyDetails) -> JSON {
            let output = [ 
            "new_value": TeamLog.PaperMemberPolicySerializer().serialize(value.newValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperChangeMemberLinkPolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = TeamLog.PaperMemberPolicySerializer().deserialize(dict["new_value"] ?? .null)
                    return PaperChangeMemberLinkPolicyDetails(newValue: newValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperChangeMemberLinkPolicyType struct
    open class PaperChangeMemberLinkPolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperChangeMemberLinkPolicyTypeSerializer().serialize(self)))"
        }
    }
    open class PaperChangeMemberLinkPolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperChangeMemberLinkPolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperChangeMemberLinkPolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperChangeMemberLinkPolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed whether members can share Paper docs outside team, and if docs are accessible only by team members or
    /// anyone by default.
    open class PaperChangeMemberPolicyDetails: CustomStringConvertible {
        /// New paper external accessibility policy.
        public let newValue: TeamLog.PaperMemberPolicy
        /// Previous paper external accessibility policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.PaperMemberPolicy?
        public init(newValue: TeamLog.PaperMemberPolicy, previousValue: TeamLog.PaperMemberPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperChangeMemberPolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperChangeMemberPolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperChangeMemberPolicyDetails) -> JSON {
            let output = [ 
            "new_value": TeamLog.PaperMemberPolicySerializer().serialize(value.newValue),
            "previous_value": NullableSerializer(TeamLog.PaperMemberPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperChangeMemberPolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = TeamLog.PaperMemberPolicySerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(TeamLog.PaperMemberPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                    return PaperChangeMemberPolicyDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperChangeMemberPolicyType struct
    open class PaperChangeMemberPolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperChangeMemberPolicyTypeSerializer().serialize(self)))"
        }
    }
    open class PaperChangeMemberPolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperChangeMemberPolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperChangeMemberPolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperChangeMemberPolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Enabled/disabled Dropbox Paper for team.
    open class PaperChangePolicyDetails: CustomStringConvertible {
        /// New Dropbox Paper policy.
        public let newValue: TeamPolicies.PaperEnabledPolicy
        /// Previous Dropbox Paper policy. Might be missing due to historical data gap.
        public let previousValue: TeamPolicies.PaperEnabledPolicy?
        public init(newValue: TeamPolicies.PaperEnabledPolicy, previousValue: TeamPolicies.PaperEnabledPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperChangePolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperChangePolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperChangePolicyDetails) -> JSON {
            let output = [ 
            "new_value": TeamPolicies.PaperEnabledPolicySerializer().serialize(value.newValue),
            "previous_value": NullableSerializer(TeamPolicies.PaperEnabledPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperChangePolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = TeamPolicies.PaperEnabledPolicySerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(TeamPolicies.PaperEnabledPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                    return PaperChangePolicyDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperChangePolicyType struct
    open class PaperChangePolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperChangePolicyTypeSerializer().serialize(self)))"
        }
    }
    open class PaperChangePolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperChangePolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperChangePolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperChangePolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Added team member to Paper doc/folder.
    open class PaperContentAddMemberDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperContentAddMemberDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperContentAddMemberDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperContentAddMemberDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperContentAddMemberDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return PaperContentAddMemberDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperContentAddMemberType struct
    open class PaperContentAddMemberType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperContentAddMemberTypeSerializer().serialize(self)))"
        }
    }
    open class PaperContentAddMemberTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperContentAddMemberType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperContentAddMemberType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperContentAddMemberType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Added Paper doc/folder to folder.
    open class PaperContentAddToFolderDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        /// Target asset position in the Assets list.
        public let targetAssetIndex: UInt64
        /// Parent asset position in the Assets list.
        public let parentAssetIndex: UInt64
        public init(eventUuid: String, targetAssetIndex: UInt64, parentAssetIndex: UInt64) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            comparableValidator()(targetAssetIndex)
            self.targetAssetIndex = targetAssetIndex
            comparableValidator()(parentAssetIndex)
            self.parentAssetIndex = parentAssetIndex
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperContentAddToFolderDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperContentAddToFolderDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperContentAddToFolderDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            "target_asset_index": Serialization._UInt64Serializer.serialize(value.targetAssetIndex),
            "parent_asset_index": Serialization._UInt64Serializer.serialize(value.parentAssetIndex),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperContentAddToFolderDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    let targetAssetIndex = Serialization._UInt64Serializer.deserialize(dict["target_asset_index"] ?? .null)
                    let parentAssetIndex = Serialization._UInt64Serializer.deserialize(dict["parent_asset_index"] ?? .null)
                    return PaperContentAddToFolderDetails(eventUuid: eventUuid, targetAssetIndex: targetAssetIndex, parentAssetIndex: parentAssetIndex)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperContentAddToFolderType struct
    open class PaperContentAddToFolderType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperContentAddToFolderTypeSerializer().serialize(self)))"
        }
    }
    open class PaperContentAddToFolderTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperContentAddToFolderType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperContentAddToFolderType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperContentAddToFolderType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Archived Paper doc/folder.
    open class PaperContentArchiveDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperContentArchiveDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperContentArchiveDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperContentArchiveDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperContentArchiveDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return PaperContentArchiveDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperContentArchiveType struct
    open class PaperContentArchiveType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperContentArchiveTypeSerializer().serialize(self)))"
        }
    }
    open class PaperContentArchiveTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperContentArchiveType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperContentArchiveType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperContentArchiveType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Created Paper doc/folder.
    open class PaperContentCreateDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperContentCreateDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperContentCreateDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperContentCreateDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperContentCreateDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return PaperContentCreateDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperContentCreateType struct
    open class PaperContentCreateType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperContentCreateTypeSerializer().serialize(self)))"
        }
    }
    open class PaperContentCreateTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperContentCreateType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperContentCreateType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperContentCreateType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Permanently deleted Paper doc/folder.
    open class PaperContentPermanentlyDeleteDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperContentPermanentlyDeleteDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperContentPermanentlyDeleteDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperContentPermanentlyDeleteDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperContentPermanentlyDeleteDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return PaperContentPermanentlyDeleteDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperContentPermanentlyDeleteType struct
    open class PaperContentPermanentlyDeleteType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperContentPermanentlyDeleteTypeSerializer().serialize(self)))"
        }
    }
    open class PaperContentPermanentlyDeleteTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperContentPermanentlyDeleteType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperContentPermanentlyDeleteType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperContentPermanentlyDeleteType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Removed Paper doc/folder from folder.
    open class PaperContentRemoveFromFolderDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        /// Target asset position in the Assets list.
        public let targetAssetIndex: UInt64
        /// Parent asset position in the Assets list.
        public let parentAssetIndex: UInt64
        public init(eventUuid: String, targetAssetIndex: UInt64, parentAssetIndex: UInt64) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            comparableValidator()(targetAssetIndex)
            self.targetAssetIndex = targetAssetIndex
            comparableValidator()(parentAssetIndex)
            self.parentAssetIndex = parentAssetIndex
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperContentRemoveFromFolderDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperContentRemoveFromFolderDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperContentRemoveFromFolderDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            "target_asset_index": Serialization._UInt64Serializer.serialize(value.targetAssetIndex),
            "parent_asset_index": Serialization._UInt64Serializer.serialize(value.parentAssetIndex),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperContentRemoveFromFolderDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    let targetAssetIndex = Serialization._UInt64Serializer.deserialize(dict["target_asset_index"] ?? .null)
                    let parentAssetIndex = Serialization._UInt64Serializer.deserialize(dict["parent_asset_index"] ?? .null)
                    return PaperContentRemoveFromFolderDetails(eventUuid: eventUuid, targetAssetIndex: targetAssetIndex, parentAssetIndex: parentAssetIndex)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperContentRemoveFromFolderType struct
    open class PaperContentRemoveFromFolderType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperContentRemoveFromFolderTypeSerializer().serialize(self)))"
        }
    }
    open class PaperContentRemoveFromFolderTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperContentRemoveFromFolderType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperContentRemoveFromFolderType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperContentRemoveFromFolderType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Removed team member from Paper doc/folder.
    open class PaperContentRemoveMemberDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperContentRemoveMemberDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperContentRemoveMemberDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperContentRemoveMemberDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperContentRemoveMemberDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return PaperContentRemoveMemberDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperContentRemoveMemberType struct
    open class PaperContentRemoveMemberType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperContentRemoveMemberTypeSerializer().serialize(self)))"
        }
    }
    open class PaperContentRemoveMemberTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperContentRemoveMemberType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperContentRemoveMemberType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperContentRemoveMemberType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Renamed Paper doc/folder.
    open class PaperContentRenameDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperContentRenameDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperContentRenameDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperContentRenameDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperContentRenameDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return PaperContentRenameDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperContentRenameType struct
    open class PaperContentRenameType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperContentRenameTypeSerializer().serialize(self)))"
        }
    }
    open class PaperContentRenameTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperContentRenameType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperContentRenameType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperContentRenameType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Restored archived Paper doc/folder.
    open class PaperContentRestoreDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperContentRestoreDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperContentRestoreDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperContentRestoreDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperContentRestoreDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return PaperContentRestoreDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperContentRestoreType struct
    open class PaperContentRestoreType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperContentRestoreTypeSerializer().serialize(self)))"
        }
    }
    open class PaperContentRestoreTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperContentRestoreType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperContentRestoreType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperContentRestoreType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Added Paper doc comment.
    open class PaperDocAddCommentDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        /// Comment text. Might be missing due to historical data gap.
        public let commentText: String?
        public init(eventUuid: String, commentText: String? = nil) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            nullableValidator(stringValidator())(commentText)
            self.commentText = commentText
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocAddCommentDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperDocAddCommentDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocAddCommentDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            "comment_text": NullableSerializer(Serialization._StringSerializer).serialize(value.commentText),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocAddCommentDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    let commentText = NullableSerializer(Serialization._StringSerializer).deserialize(dict["comment_text"] ?? .null)
                    return PaperDocAddCommentDetails(eventUuid: eventUuid, commentText: commentText)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperDocAddCommentType struct
    open class PaperDocAddCommentType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocAddCommentTypeSerializer().serialize(self)))"
        }
    }
    open class PaperDocAddCommentTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocAddCommentType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocAddCommentType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperDocAddCommentType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed team member permissions for Paper doc.
    open class PaperDocChangeMemberRoleDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        /// Paper doc access type.
        public let accessType: TeamLog.PaperAccessType
        public init(eventUuid: String, accessType: TeamLog.PaperAccessType) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            self.accessType = accessType
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocChangeMemberRoleDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperDocChangeMemberRoleDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocChangeMemberRoleDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            "access_type": TeamLog.PaperAccessTypeSerializer().serialize(value.accessType),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocChangeMemberRoleDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    let accessType = TeamLog.PaperAccessTypeSerializer().deserialize(dict["access_type"] ?? .null)
                    return PaperDocChangeMemberRoleDetails(eventUuid: eventUuid, accessType: accessType)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperDocChangeMemberRoleType struct
    open class PaperDocChangeMemberRoleType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocChangeMemberRoleTypeSerializer().serialize(self)))"
        }
    }
    open class PaperDocChangeMemberRoleTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocChangeMemberRoleType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocChangeMemberRoleType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperDocChangeMemberRoleType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed sharing setting for Paper doc.
    open class PaperDocChangeSharingPolicyDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        /// Sharing policy with external users. Might be missing due to historical data gap.
        public let publicSharingPolicy: String?
        /// Sharing policy with team. Might be missing due to historical data gap.
        public let teamSharingPolicy: String?
        public init(eventUuid: String, publicSharingPolicy: String? = nil, teamSharingPolicy: String? = nil) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            nullableValidator(stringValidator())(publicSharingPolicy)
            self.publicSharingPolicy = publicSharingPolicy
            nullableValidator(stringValidator())(teamSharingPolicy)
            self.teamSharingPolicy = teamSharingPolicy
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocChangeSharingPolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperDocChangeSharingPolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocChangeSharingPolicyDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            "public_sharing_policy": NullableSerializer(Serialization._StringSerializer).serialize(value.publicSharingPolicy),
            "team_sharing_policy": NullableSerializer(Serialization._StringSerializer).serialize(value.teamSharingPolicy),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocChangeSharingPolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    let publicSharingPolicy = NullableSerializer(Serialization._StringSerializer).deserialize(dict["public_sharing_policy"] ?? .null)
                    let teamSharingPolicy = NullableSerializer(Serialization._StringSerializer).deserialize(dict["team_sharing_policy"] ?? .null)
                    return PaperDocChangeSharingPolicyDetails(eventUuid: eventUuid, publicSharingPolicy: publicSharingPolicy, teamSharingPolicy: teamSharingPolicy)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperDocChangeSharingPolicyType struct
    open class PaperDocChangeSharingPolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocChangeSharingPolicyTypeSerializer().serialize(self)))"
        }
    }
    open class PaperDocChangeSharingPolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocChangeSharingPolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocChangeSharingPolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperDocChangeSharingPolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Followed/unfollowed Paper doc.
    open class PaperDocChangeSubscriptionDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        /// New doc subscription level.
        public let newSubscriptionLevel: String
        /// Previous doc subscription level. Might be missing due to historical data gap.
        public let previousSubscriptionLevel: String?
        public init(eventUuid: String, newSubscriptionLevel: String, previousSubscriptionLevel: String? = nil) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            stringValidator()(newSubscriptionLevel)
            self.newSubscriptionLevel = newSubscriptionLevel
            nullableValidator(stringValidator())(previousSubscriptionLevel)
            self.previousSubscriptionLevel = previousSubscriptionLevel
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocChangeSubscriptionDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperDocChangeSubscriptionDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocChangeSubscriptionDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            "new_subscription_level": Serialization._StringSerializer.serialize(value.newSubscriptionLevel),
            "previous_subscription_level": NullableSerializer(Serialization._StringSerializer).serialize(value.previousSubscriptionLevel),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocChangeSubscriptionDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    let newSubscriptionLevel = Serialization._StringSerializer.deserialize(dict["new_subscription_level"] ?? .null)
                    let previousSubscriptionLevel = NullableSerializer(Serialization._StringSerializer).deserialize(dict["previous_subscription_level"] ?? .null)
                    return PaperDocChangeSubscriptionDetails(eventUuid: eventUuid, newSubscriptionLevel: newSubscriptionLevel, previousSubscriptionLevel: previousSubscriptionLevel)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperDocChangeSubscriptionType struct
    open class PaperDocChangeSubscriptionType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocChangeSubscriptionTypeSerializer().serialize(self)))"
        }
    }
    open class PaperDocChangeSubscriptionTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocChangeSubscriptionType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocChangeSubscriptionType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperDocChangeSubscriptionType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Deleted Paper doc comment.
    open class PaperDocDeleteCommentDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        /// Comment text. Might be missing due to historical data gap.
        public let commentText: String?
        public init(eventUuid: String, commentText: String? = nil) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            nullableValidator(stringValidator())(commentText)
            self.commentText = commentText
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocDeleteCommentDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperDocDeleteCommentDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocDeleteCommentDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            "comment_text": NullableSerializer(Serialization._StringSerializer).serialize(value.commentText),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocDeleteCommentDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    let commentText = NullableSerializer(Serialization._StringSerializer).deserialize(dict["comment_text"] ?? .null)
                    return PaperDocDeleteCommentDetails(eventUuid: eventUuid, commentText: commentText)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperDocDeleteCommentType struct
    open class PaperDocDeleteCommentType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocDeleteCommentTypeSerializer().serialize(self)))"
        }
    }
    open class PaperDocDeleteCommentTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocDeleteCommentType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocDeleteCommentType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperDocDeleteCommentType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Archived Paper doc.
    open class PaperDocDeletedDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocDeletedDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperDocDeletedDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocDeletedDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocDeletedDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return PaperDocDeletedDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperDocDeletedType struct
    open class PaperDocDeletedType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocDeletedTypeSerializer().serialize(self)))"
        }
    }
    open class PaperDocDeletedTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocDeletedType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocDeletedType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperDocDeletedType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Downloaded Paper doc in specific format.
    open class PaperDocDownloadDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        /// Export file format.
        public let exportFileFormat: TeamLog.PaperDownloadFormat
        public init(eventUuid: String, exportFileFormat: TeamLog.PaperDownloadFormat) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            self.exportFileFormat = exportFileFormat
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocDownloadDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperDocDownloadDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocDownloadDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            "export_file_format": TeamLog.PaperDownloadFormatSerializer().serialize(value.exportFileFormat),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocDownloadDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    let exportFileFormat = TeamLog.PaperDownloadFormatSerializer().deserialize(dict["export_file_format"] ?? .null)
                    return PaperDocDownloadDetails(eventUuid: eventUuid, exportFileFormat: exportFileFormat)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperDocDownloadType struct
    open class PaperDocDownloadType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocDownloadTypeSerializer().serialize(self)))"
        }
    }
    open class PaperDocDownloadTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocDownloadType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocDownloadType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperDocDownloadType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Edited Paper doc comment.
    open class PaperDocEditCommentDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        /// Comment text. Might be missing due to historical data gap.
        public let commentText: String?
        public init(eventUuid: String, commentText: String? = nil) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            nullableValidator(stringValidator())(commentText)
            self.commentText = commentText
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocEditCommentDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperDocEditCommentDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocEditCommentDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            "comment_text": NullableSerializer(Serialization._StringSerializer).serialize(value.commentText),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocEditCommentDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    let commentText = NullableSerializer(Serialization._StringSerializer).deserialize(dict["comment_text"] ?? .null)
                    return PaperDocEditCommentDetails(eventUuid: eventUuid, commentText: commentText)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperDocEditCommentType struct
    open class PaperDocEditCommentType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocEditCommentTypeSerializer().serialize(self)))"
        }
    }
    open class PaperDocEditCommentTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocEditCommentType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocEditCommentType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperDocEditCommentType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Edited Paper doc.
    open class PaperDocEditDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocEditDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperDocEditDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocEditDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocEditDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return PaperDocEditDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperDocEditType struct
    open class PaperDocEditType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocEditTypeSerializer().serialize(self)))"
        }
    }
    open class PaperDocEditTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocEditType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocEditType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperDocEditType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Followed Paper doc.
    open class PaperDocFollowedDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocFollowedDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperDocFollowedDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocFollowedDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocFollowedDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return PaperDocFollowedDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperDocFollowedType struct
    open class PaperDocFollowedType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocFollowedTypeSerializer().serialize(self)))"
        }
    }
    open class PaperDocFollowedTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocFollowedType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocFollowedType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperDocFollowedType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Mentioned team member in Paper doc.
    open class PaperDocMentionDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocMentionDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperDocMentionDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocMentionDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocMentionDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return PaperDocMentionDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperDocMentionType struct
    open class PaperDocMentionType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocMentionTypeSerializer().serialize(self)))"
        }
    }
    open class PaperDocMentionTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocMentionType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocMentionType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperDocMentionType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Transferred ownership of Paper doc.
    open class PaperDocOwnershipChangedDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        /// Previous owner.
        public let oldOwnerUserId: String?
        /// New owner.
        public let newOwnerUserId: String
        public init(eventUuid: String, newOwnerUserId: String, oldOwnerUserId: String? = nil) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            nullableValidator(stringValidator(minLength: 40, maxLength: 40))(oldOwnerUserId)
            self.oldOwnerUserId = oldOwnerUserId
            stringValidator(minLength: 40, maxLength: 40)(newOwnerUserId)
            self.newOwnerUserId = newOwnerUserId
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocOwnershipChangedDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperDocOwnershipChangedDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocOwnershipChangedDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            "new_owner_user_id": Serialization._StringSerializer.serialize(value.newOwnerUserId),
            "old_owner_user_id": NullableSerializer(Serialization._StringSerializer).serialize(value.oldOwnerUserId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocOwnershipChangedDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    let newOwnerUserId = Serialization._StringSerializer.deserialize(dict["new_owner_user_id"] ?? .null)
                    let oldOwnerUserId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["old_owner_user_id"] ?? .null)
                    return PaperDocOwnershipChangedDetails(eventUuid: eventUuid, newOwnerUserId: newOwnerUserId, oldOwnerUserId: oldOwnerUserId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperDocOwnershipChangedType struct
    open class PaperDocOwnershipChangedType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocOwnershipChangedTypeSerializer().serialize(self)))"
        }
    }
    open class PaperDocOwnershipChangedTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocOwnershipChangedType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocOwnershipChangedType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperDocOwnershipChangedType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Requested access to Paper doc.
    open class PaperDocRequestAccessDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocRequestAccessDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperDocRequestAccessDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocRequestAccessDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocRequestAccessDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return PaperDocRequestAccessDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperDocRequestAccessType struct
    open class PaperDocRequestAccessType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocRequestAccessTypeSerializer().serialize(self)))"
        }
    }
    open class PaperDocRequestAccessTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocRequestAccessType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocRequestAccessType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperDocRequestAccessType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Resolved Paper doc comment.
    open class PaperDocResolveCommentDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        /// Comment text. Might be missing due to historical data gap.
        public let commentText: String?
        public init(eventUuid: String, commentText: String? = nil) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            nullableValidator(stringValidator())(commentText)
            self.commentText = commentText
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocResolveCommentDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperDocResolveCommentDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocResolveCommentDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            "comment_text": NullableSerializer(Serialization._StringSerializer).serialize(value.commentText),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocResolveCommentDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    let commentText = NullableSerializer(Serialization._StringSerializer).deserialize(dict["comment_text"] ?? .null)
                    return PaperDocResolveCommentDetails(eventUuid: eventUuid, commentText: commentText)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperDocResolveCommentType struct
    open class PaperDocResolveCommentType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocResolveCommentTypeSerializer().serialize(self)))"
        }
    }
    open class PaperDocResolveCommentTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocResolveCommentType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocResolveCommentType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperDocResolveCommentType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Restored Paper doc to previous version.
    open class PaperDocRevertDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocRevertDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperDocRevertDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocRevertDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocRevertDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return PaperDocRevertDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperDocRevertType struct
    open class PaperDocRevertType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocRevertTypeSerializer().serialize(self)))"
        }
    }
    open class PaperDocRevertTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocRevertType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocRevertType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperDocRevertType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Shared Paper doc via Slack.
    open class PaperDocSlackShareDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocSlackShareDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperDocSlackShareDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocSlackShareDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocSlackShareDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return PaperDocSlackShareDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperDocSlackShareType struct
    open class PaperDocSlackShareType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocSlackShareTypeSerializer().serialize(self)))"
        }
    }
    open class PaperDocSlackShareTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocSlackShareType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocSlackShareType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperDocSlackShareType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Shared Paper doc with team member.
    open class PaperDocTeamInviteDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocTeamInviteDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperDocTeamInviteDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocTeamInviteDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocTeamInviteDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return PaperDocTeamInviteDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperDocTeamInviteType struct
    open class PaperDocTeamInviteType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocTeamInviteTypeSerializer().serialize(self)))"
        }
    }
    open class PaperDocTeamInviteTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocTeamInviteType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocTeamInviteType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperDocTeamInviteType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Deleted Paper doc.
    open class PaperDocTrashedDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocTrashedDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperDocTrashedDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocTrashedDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocTrashedDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return PaperDocTrashedDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperDocTrashedType struct
    open class PaperDocTrashedType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocTrashedTypeSerializer().serialize(self)))"
        }
    }
    open class PaperDocTrashedTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocTrashedType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocTrashedType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperDocTrashedType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Unresolved Paper doc comment.
    open class PaperDocUnresolveCommentDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        /// Comment text. Might be missing due to historical data gap.
        public let commentText: String?
        public init(eventUuid: String, commentText: String? = nil) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            nullableValidator(stringValidator())(commentText)
            self.commentText = commentText
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocUnresolveCommentDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperDocUnresolveCommentDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocUnresolveCommentDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            "comment_text": NullableSerializer(Serialization._StringSerializer).serialize(value.commentText),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocUnresolveCommentDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    let commentText = NullableSerializer(Serialization._StringSerializer).deserialize(dict["comment_text"] ?? .null)
                    return PaperDocUnresolveCommentDetails(eventUuid: eventUuid, commentText: commentText)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperDocUnresolveCommentType struct
    open class PaperDocUnresolveCommentType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocUnresolveCommentTypeSerializer().serialize(self)))"
        }
    }
    open class PaperDocUnresolveCommentTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocUnresolveCommentType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocUnresolveCommentType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperDocUnresolveCommentType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Restored Paper doc.
    open class PaperDocUntrashedDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocUntrashedDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperDocUntrashedDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocUntrashedDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocUntrashedDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return PaperDocUntrashedDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperDocUntrashedType struct
    open class PaperDocUntrashedType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocUntrashedTypeSerializer().serialize(self)))"
        }
    }
    open class PaperDocUntrashedTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocUntrashedType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocUntrashedType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperDocUntrashedType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Viewed Paper doc.
    open class PaperDocViewDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocViewDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperDocViewDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocViewDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocViewDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return PaperDocViewDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperDocViewType struct
    open class PaperDocViewType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocViewTypeSerializer().serialize(self)))"
        }
    }
    open class PaperDocViewTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocViewType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocViewType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperDocViewType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Paper document's logged information.
    open class PaperDocumentLogInfo: CustomStringConvertible {
        /// Papers document Id.
        public let docId: String
        /// Paper document title.
        public let docTitle: String
        public init(docId: String, docTitle: String) {
            stringValidator()(docId)
            self.docId = docId
            stringValidator()(docTitle)
            self.docTitle = docTitle
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocumentLogInfoSerializer().serialize(self)))"
        }
    }
    open class PaperDocumentLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocumentLogInfo) -> JSON {
            let output = [ 
            "doc_id": Serialization._StringSerializer.serialize(value.docId),
            "doc_title": Serialization._StringSerializer.serialize(value.docTitle),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperDocumentLogInfo {
            switch json {
                case .dictionary(let dict):
                    let docId = Serialization._StringSerializer.deserialize(dict["doc_id"] ?? .null)
                    let docTitle = Serialization._StringSerializer.deserialize(dict["doc_title"] ?? .null)
                    return PaperDocumentLogInfo(docId: docId, docTitle: docTitle)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperDownloadFormat union
    public enum PaperDownloadFormat: CustomStringConvertible {
        /// An unspecified error.
        case docx
        /// An unspecified error.
        case html
        /// An unspecified error.
        case markdown
        /// An unspecified error.
        case pdf
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDownloadFormatSerializer().serialize(self)))"
        }
    }
    open class PaperDownloadFormatSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDownloadFormat) -> JSON {
            switch value {
                case .docx:
                    var d = [String: JSON]()
                    d[".tag"] = .str("docx")
                    return .dictionary(d)
                case .html:
                    var d = [String: JSON]()
                    d[".tag"] = .str("html")
                    return .dictionary(d)
                case .markdown:
                    var d = [String: JSON]()
                    d[".tag"] = .str("markdown")
                    return .dictionary(d)
                case .pdf:
                    var d = [String: JSON]()
                    d[".tag"] = .str("pdf")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> PaperDownloadFormat {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "docx":
                            return PaperDownloadFormat.docx
                        case "html":
                            return PaperDownloadFormat.html
                        case "markdown":
                            return PaperDownloadFormat.markdown
                        case "pdf":
                            return PaperDownloadFormat.pdf
                        case "other":
                            return PaperDownloadFormat.other
                        default:
                            return PaperDownloadFormat.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Added users to Paper-enabled users list.
    open class PaperEnabledUsersGroupAdditionDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperEnabledUsersGroupAdditionDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperEnabledUsersGroupAdditionDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperEnabledUsersGroupAdditionDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperEnabledUsersGroupAdditionDetails {
            switch json {
                case .dictionary(_):
                    return PaperEnabledUsersGroupAdditionDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperEnabledUsersGroupAdditionType struct
    open class PaperEnabledUsersGroupAdditionType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperEnabledUsersGroupAdditionTypeSerializer().serialize(self)))"
        }
    }
    open class PaperEnabledUsersGroupAdditionTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperEnabledUsersGroupAdditionType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperEnabledUsersGroupAdditionType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperEnabledUsersGroupAdditionType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Removed users from Paper-enabled users list.
    open class PaperEnabledUsersGroupRemovalDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperEnabledUsersGroupRemovalDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperEnabledUsersGroupRemovalDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperEnabledUsersGroupRemovalDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperEnabledUsersGroupRemovalDetails {
            switch json {
                case .dictionary(_):
                    return PaperEnabledUsersGroupRemovalDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperEnabledUsersGroupRemovalType struct
    open class PaperEnabledUsersGroupRemovalType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperEnabledUsersGroupRemovalTypeSerializer().serialize(self)))"
        }
    }
    open class PaperEnabledUsersGroupRemovalTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperEnabledUsersGroupRemovalType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperEnabledUsersGroupRemovalType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperEnabledUsersGroupRemovalType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed Paper external sharing setting to anyone.
    open class PaperExternalViewAllowDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperExternalViewAllowDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperExternalViewAllowDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperExternalViewAllowDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperExternalViewAllowDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return PaperExternalViewAllowDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperExternalViewAllowType struct
    open class PaperExternalViewAllowType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperExternalViewAllowTypeSerializer().serialize(self)))"
        }
    }
    open class PaperExternalViewAllowTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperExternalViewAllowType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperExternalViewAllowType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperExternalViewAllowType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed Paper external sharing setting to default team.
    open class PaperExternalViewDefaultTeamDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperExternalViewDefaultTeamDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperExternalViewDefaultTeamDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperExternalViewDefaultTeamDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperExternalViewDefaultTeamDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return PaperExternalViewDefaultTeamDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperExternalViewDefaultTeamType struct
    open class PaperExternalViewDefaultTeamType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperExternalViewDefaultTeamTypeSerializer().serialize(self)))"
        }
    }
    open class PaperExternalViewDefaultTeamTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperExternalViewDefaultTeamType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperExternalViewDefaultTeamType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperExternalViewDefaultTeamType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed Paper external sharing setting to team-only.
    open class PaperExternalViewForbidDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperExternalViewForbidDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperExternalViewForbidDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperExternalViewForbidDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperExternalViewForbidDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return PaperExternalViewForbidDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperExternalViewForbidType struct
    open class PaperExternalViewForbidType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperExternalViewForbidTypeSerializer().serialize(self)))"
        }
    }
    open class PaperExternalViewForbidTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperExternalViewForbidType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperExternalViewForbidType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperExternalViewForbidType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Followed/unfollowed Paper folder.
    open class PaperFolderChangeSubscriptionDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        /// New folder subscription level.
        public let newSubscriptionLevel: String
        /// Previous folder subscription level. Might be missing due to historical data gap.
        public let previousSubscriptionLevel: String?
        public init(eventUuid: String, newSubscriptionLevel: String, previousSubscriptionLevel: String? = nil) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            stringValidator()(newSubscriptionLevel)
            self.newSubscriptionLevel = newSubscriptionLevel
            nullableValidator(stringValidator())(previousSubscriptionLevel)
            self.previousSubscriptionLevel = previousSubscriptionLevel
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperFolderChangeSubscriptionDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperFolderChangeSubscriptionDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperFolderChangeSubscriptionDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            "new_subscription_level": Serialization._StringSerializer.serialize(value.newSubscriptionLevel),
            "previous_subscription_level": NullableSerializer(Serialization._StringSerializer).serialize(value.previousSubscriptionLevel),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperFolderChangeSubscriptionDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    let newSubscriptionLevel = Serialization._StringSerializer.deserialize(dict["new_subscription_level"] ?? .null)
                    let previousSubscriptionLevel = NullableSerializer(Serialization._StringSerializer).deserialize(dict["previous_subscription_level"] ?? .null)
                    return PaperFolderChangeSubscriptionDetails(eventUuid: eventUuid, newSubscriptionLevel: newSubscriptionLevel, previousSubscriptionLevel: previousSubscriptionLevel)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperFolderChangeSubscriptionType struct
    open class PaperFolderChangeSubscriptionType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperFolderChangeSubscriptionTypeSerializer().serialize(self)))"
        }
    }
    open class PaperFolderChangeSubscriptionTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperFolderChangeSubscriptionType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperFolderChangeSubscriptionType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperFolderChangeSubscriptionType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Archived Paper folder.
    open class PaperFolderDeletedDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperFolderDeletedDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperFolderDeletedDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperFolderDeletedDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperFolderDeletedDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return PaperFolderDeletedDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperFolderDeletedType struct
    open class PaperFolderDeletedType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperFolderDeletedTypeSerializer().serialize(self)))"
        }
    }
    open class PaperFolderDeletedTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperFolderDeletedType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperFolderDeletedType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperFolderDeletedType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Followed Paper folder.
    open class PaperFolderFollowedDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperFolderFollowedDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperFolderFollowedDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperFolderFollowedDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperFolderFollowedDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return PaperFolderFollowedDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperFolderFollowedType struct
    open class PaperFolderFollowedType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperFolderFollowedTypeSerializer().serialize(self)))"
        }
    }
    open class PaperFolderFollowedTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperFolderFollowedType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperFolderFollowedType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperFolderFollowedType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Paper folder's logged information.
    open class PaperFolderLogInfo: CustomStringConvertible {
        /// Papers folder Id.
        public let folderId: String
        /// Paper folder name.
        public let folderName: String
        public init(folderId: String, folderName: String) {
            stringValidator()(folderId)
            self.folderId = folderId
            stringValidator()(folderName)
            self.folderName = folderName
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperFolderLogInfoSerializer().serialize(self)))"
        }
    }
    open class PaperFolderLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperFolderLogInfo) -> JSON {
            let output = [ 
            "folder_id": Serialization._StringSerializer.serialize(value.folderId),
            "folder_name": Serialization._StringSerializer.serialize(value.folderName),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperFolderLogInfo {
            switch json {
                case .dictionary(let dict):
                    let folderId = Serialization._StringSerializer.deserialize(dict["folder_id"] ?? .null)
                    let folderName = Serialization._StringSerializer.deserialize(dict["folder_name"] ?? .null)
                    return PaperFolderLogInfo(folderId: folderId, folderName: folderName)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Shared Paper folder with member.
    open class PaperFolderTeamInviteDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperFolderTeamInviteDetailsSerializer().serialize(self)))"
        }
    }
    open class PaperFolderTeamInviteDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperFolderTeamInviteDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperFolderTeamInviteDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return PaperFolderTeamInviteDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperFolderTeamInviteType struct
    open class PaperFolderTeamInviteType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperFolderTeamInviteTypeSerializer().serialize(self)))"
        }
    }
    open class PaperFolderTeamInviteTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperFolderTeamInviteType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperFolderTeamInviteType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PaperFolderTeamInviteType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Policy for controlling if team members can share Paper documents externally.
    public enum PaperMemberPolicy: CustomStringConvertible {
        /// An unspecified error.
        case anyoneWithLink
        /// An unspecified error.
        case onlyTeam
        /// An unspecified error.
        case teamAndExplicitlyShared
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperMemberPolicySerializer().serialize(self)))"
        }
    }
    open class PaperMemberPolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperMemberPolicy) -> JSON {
            switch value {
                case .anyoneWithLink:
                    var d = [String: JSON]()
                    d[".tag"] = .str("anyone_with_link")
                    return .dictionary(d)
                case .onlyTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .str("only_team")
                    return .dictionary(d)
                case .teamAndExplicitlyShared:
                    var d = [String: JSON]()
                    d[".tag"] = .str("team_and_explicitly_shared")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> PaperMemberPolicy {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "anyone_with_link":
                            return PaperMemberPolicy.anyoneWithLink
                        case "only_team":
                            return PaperMemberPolicy.onlyTeam
                        case "team_and_explicitly_shared":
                            return PaperMemberPolicy.teamAndExplicitlyShared
                        case "other":
                            return PaperMemberPolicy.other
                        default:
                            return PaperMemberPolicy.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// A user or group
    public enum ParticipantLogInfo: CustomStringConvertible {
        /// A user with a Dropbox account.
        case user(TeamLog.UserLogInfo)
        /// Group details.
        case group(TeamLog.GroupLogInfo)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ParticipantLogInfoSerializer().serialize(self)))"
        }
    }
    open class ParticipantLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ParticipantLogInfo) -> JSON {
            switch value {
                case .user(let arg):
                    var d = ["user": TeamLog.UserLogInfoSerializer().serialize(arg)]
                    d[".tag"] = .str("user")
                    return .dictionary(d)
                case .group(let arg):
                    var d = Serialization.getFields(TeamLog.GroupLogInfoSerializer().serialize(arg))
                    d[".tag"] = .str("group")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ParticipantLogInfo {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "user":
                            let v = TeamLog.UserLogInfoSerializer().deserialize(d["user"] ?? .null)
                            return ParticipantLogInfo.user(v)
                        case "group":
                            let v = TeamLog.GroupLogInfoSerializer().deserialize(json)
                            return ParticipantLogInfo.group(v)
                        case "other":
                            return ParticipantLogInfo.other
                        default:
                            return ParticipantLogInfo.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The PassPolicy union
    public enum PassPolicy: CustomStringConvertible {
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case allow
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PassPolicySerializer().serialize(self)))"
        }
    }
    open class PassPolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PassPolicy) -> JSON {
            switch value {
                case .enabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("enabled")
                    return .dictionary(d)
                case .allow:
                    var d = [String: JSON]()
                    d[".tag"] = .str("allow")
                    return .dictionary(d)
                case .disabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disabled")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> PassPolicy {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "enabled":
                            return PassPolicy.enabled
                        case "allow":
                            return PassPolicy.allow
                        case "disabled":
                            return PassPolicy.disabled
                        case "other":
                            return PassPolicy.other
                        default:
                            return PassPolicy.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Changed password.
    open class PasswordChangeDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PasswordChangeDetailsSerializer().serialize(self)))"
        }
    }
    open class PasswordChangeDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PasswordChangeDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PasswordChangeDetails {
            switch json {
                case .dictionary(_):
                    return PasswordChangeDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PasswordChangeType struct
    open class PasswordChangeType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PasswordChangeTypeSerializer().serialize(self)))"
        }
    }
    open class PasswordChangeTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PasswordChangeType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PasswordChangeType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PasswordChangeType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Reset all team member passwords.
    open class PasswordResetAllDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PasswordResetAllDetailsSerializer().serialize(self)))"
        }
    }
    open class PasswordResetAllDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PasswordResetAllDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PasswordResetAllDetails {
            switch json {
                case .dictionary(_):
                    return PasswordResetAllDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PasswordResetAllType struct
    open class PasswordResetAllType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PasswordResetAllTypeSerializer().serialize(self)))"
        }
    }
    open class PasswordResetAllTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PasswordResetAllType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PasswordResetAllType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PasswordResetAllType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Reset password.
    open class PasswordResetDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PasswordResetDetailsSerializer().serialize(self)))"
        }
    }
    open class PasswordResetDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PasswordResetDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PasswordResetDetails {
            switch json {
                case .dictionary(_):
                    return PasswordResetDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PasswordResetType struct
    open class PasswordResetType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PasswordResetTypeSerializer().serialize(self)))"
        }
    }
    open class PasswordResetTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PasswordResetType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PasswordResetType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PasswordResetType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Path's details.
    open class PathLogInfo: CustomStringConvertible {
        /// Fully qualified path relative to event's context. Might be missing due to historical data gap.
        public let contextual: String?
        /// Path relative to the namespace containing the content.
        public let namespaceRelative: TeamLog.NamespaceRelativePathLogInfo
        public init(namespaceRelative: TeamLog.NamespaceRelativePathLogInfo, contextual: String? = nil) {
            nullableValidator(stringValidator())(contextual)
            self.contextual = contextual
            self.namespaceRelative = namespaceRelative
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PathLogInfoSerializer().serialize(self)))"
        }
    }
    open class PathLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PathLogInfo) -> JSON {
            let output = [ 
            "namespace_relative": TeamLog.NamespaceRelativePathLogInfoSerializer().serialize(value.namespaceRelative),
            "contextual": NullableSerializer(Serialization._StringSerializer).serialize(value.contextual),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PathLogInfo {
            switch json {
                case .dictionary(let dict):
                    let namespaceRelative = TeamLog.NamespaceRelativePathLogInfoSerializer().deserialize(dict["namespace_relative"] ?? .null)
                    let contextual = NullableSerializer(Serialization._StringSerializer).deserialize(dict["contextual"] ?? .null)
                    return PathLogInfo(namespaceRelative: namespaceRelative, contextual: contextual)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Enabled/disabled ability of team members to permanently delete content.
    open class PermanentDeleteChangePolicyDetails: CustomStringConvertible {
        /// New permanent delete content policy.
        public let newValue: TeamLog.ContentPermanentDeletePolicy
        /// Previous permanent delete content policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.ContentPermanentDeletePolicy?
        public init(newValue: TeamLog.ContentPermanentDeletePolicy, previousValue: TeamLog.ContentPermanentDeletePolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PermanentDeleteChangePolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class PermanentDeleteChangePolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PermanentDeleteChangePolicyDetails) -> JSON {
            let output = [ 
            "new_value": TeamLog.ContentPermanentDeletePolicySerializer().serialize(value.newValue),
            "previous_value": NullableSerializer(TeamLog.ContentPermanentDeletePolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PermanentDeleteChangePolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = TeamLog.ContentPermanentDeletePolicySerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(TeamLog.ContentPermanentDeletePolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                    return PermanentDeleteChangePolicyDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PermanentDeleteChangePolicyType struct
    open class PermanentDeleteChangePolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PermanentDeleteChangePolicyTypeSerializer().serialize(self)))"
        }
    }
    open class PermanentDeleteChangePolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PermanentDeleteChangePolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PermanentDeleteChangePolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return PermanentDeleteChangePolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PlacementRestriction union
    public enum PlacementRestriction: CustomStringConvertible {
        /// An unspecified error.
        case europeOnly
        /// An unspecified error.
        case none
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PlacementRestrictionSerializer().serialize(self)))"
        }
    }
    open class PlacementRestrictionSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PlacementRestriction) -> JSON {
            switch value {
                case .europeOnly:
                    var d = [String: JSON]()
                    d[".tag"] = .str("europe_only")
                    return .dictionary(d)
                case .none:
                    var d = [String: JSON]()
                    d[".tag"] = .str("none")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> PlacementRestriction {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "europe_only":
                            return PlacementRestriction.europeOnly
                        case "none":
                            return PlacementRestriction.none
                        case "other":
                            return PlacementRestriction.other
                        default:
                            return PlacementRestriction.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Quick action type.
    public enum QuickActionType: CustomStringConvertible {
        /// An unspecified error.
        case deleteSharedLink
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(QuickActionTypeSerializer().serialize(self)))"
        }
    }
    open class QuickActionTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: QuickActionType) -> JSON {
            switch value {
                case .deleteSharedLink:
                    var d = [String: JSON]()
                    d[".tag"] = .str("delete_shared_link")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> QuickActionType {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "delete_shared_link":
                            return QuickActionType.deleteSharedLink
                        case "other":
                            return QuickActionType.other
                        default:
                            return QuickActionType.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Provides the indices of the source asset and the destination asset for a relocate action.
    open class RelocateAssetReferencesLogInfo: CustomStringConvertible {
        /// Source asset position in the Assets list.
        public let srcAssetIndex: UInt64
        /// Destination asset position in the Assets list.
        public let destAssetIndex: UInt64
        public init(srcAssetIndex: UInt64, destAssetIndex: UInt64) {
            comparableValidator()(srcAssetIndex)
            self.srcAssetIndex = srcAssetIndex
            comparableValidator()(destAssetIndex)
            self.destAssetIndex = destAssetIndex
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelocateAssetReferencesLogInfoSerializer().serialize(self)))"
        }
    }
    open class RelocateAssetReferencesLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelocateAssetReferencesLogInfo) -> JSON {
            let output = [ 
            "src_asset_index": Serialization._UInt64Serializer.serialize(value.srcAssetIndex),
            "dest_asset_index": Serialization._UInt64Serializer.serialize(value.destAssetIndex),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RelocateAssetReferencesLogInfo {
            switch json {
                case .dictionary(let dict):
                    let srcAssetIndex = Serialization._UInt64Serializer.deserialize(dict["src_asset_index"] ?? .null)
                    let destAssetIndex = Serialization._UInt64Serializer.deserialize(dict["dest_asset_index"] ?? .null)
                    return RelocateAssetReferencesLogInfo(srcAssetIndex: srcAssetIndex, destAssetIndex: destAssetIndex)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Reseller information.
    open class ResellerLogInfo: CustomStringConvertible {
        /// Reseller name.
        public let resellerName: String
        /// Reseller email.
        public let resellerEmail: String
        public init(resellerName: String, resellerEmail: String) {
            stringValidator()(resellerName)
            self.resellerName = resellerName
            stringValidator(maxLength: 255)(resellerEmail)
            self.resellerEmail = resellerEmail
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ResellerLogInfoSerializer().serialize(self)))"
        }
    }
    open class ResellerLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ResellerLogInfo) -> JSON {
            let output = [ 
            "reseller_name": Serialization._StringSerializer.serialize(value.resellerName),
            "reseller_email": Serialization._StringSerializer.serialize(value.resellerEmail),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ResellerLogInfo {
            switch json {
                case .dictionary(let dict):
                    let resellerName = Serialization._StringSerializer.deserialize(dict["reseller_name"] ?? .null)
                    let resellerEmail = Serialization._StringSerializer.deserialize(dict["reseller_email"] ?? .null)
                    return ResellerLogInfo(resellerName: resellerName, resellerEmail: resellerEmail)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Ended reseller support session.
    open class ResellerSupportSessionEndDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ResellerSupportSessionEndDetailsSerializer().serialize(self)))"
        }
    }
    open class ResellerSupportSessionEndDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ResellerSupportSessionEndDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ResellerSupportSessionEndDetails {
            switch json {
                case .dictionary(_):
                    return ResellerSupportSessionEndDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ResellerSupportSessionEndType struct
    open class ResellerSupportSessionEndType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ResellerSupportSessionEndTypeSerializer().serialize(self)))"
        }
    }
    open class ResellerSupportSessionEndTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ResellerSupportSessionEndType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ResellerSupportSessionEndType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return ResellerSupportSessionEndType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Started reseller support session.
    open class ResellerSupportSessionStartDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ResellerSupportSessionStartDetailsSerializer().serialize(self)))"
        }
    }
    open class ResellerSupportSessionStartDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ResellerSupportSessionStartDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ResellerSupportSessionStartDetails {
            switch json {
                case .dictionary(_):
                    return ResellerSupportSessionStartDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ResellerSupportSessionStartType struct
    open class ResellerSupportSessionStartType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ResellerSupportSessionStartTypeSerializer().serialize(self)))"
        }
    }
    open class ResellerSupportSessionStartTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ResellerSupportSessionStartType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ResellerSupportSessionStartType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return ResellerSupportSessionStartType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SecondaryMailsPolicy union
    public enum SecondaryMailsPolicy: CustomStringConvertible {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SecondaryMailsPolicySerializer().serialize(self)))"
        }
    }
    open class SecondaryMailsPolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SecondaryMailsPolicy) -> JSON {
            switch value {
                case .disabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disabled")
                    return .dictionary(d)
                case .enabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("enabled")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SecondaryMailsPolicy {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "disabled":
                            return SecondaryMailsPolicy.disabled
                        case "enabled":
                            return SecondaryMailsPolicy.enabled
                        case "other":
                            return SecondaryMailsPolicy.other
                        default:
                            return SecondaryMailsPolicy.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Secondary mails policy changed.
    open class SecondaryMailsPolicyChangedDetails: CustomStringConvertible {
        /// Previous secondary mails policy.
        public let previousValue: TeamLog.SecondaryMailsPolicy
        /// New secondary mails policy.
        public let newValue: TeamLog.SecondaryMailsPolicy
        public init(previousValue: TeamLog.SecondaryMailsPolicy, newValue: TeamLog.SecondaryMailsPolicy) {
            self.previousValue = previousValue
            self.newValue = newValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SecondaryMailsPolicyChangedDetailsSerializer().serialize(self)))"
        }
    }
    open class SecondaryMailsPolicyChangedDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SecondaryMailsPolicyChangedDetails) -> JSON {
            let output = [ 
            "previous_value": TeamLog.SecondaryMailsPolicySerializer().serialize(value.previousValue),
            "new_value": TeamLog.SecondaryMailsPolicySerializer().serialize(value.newValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SecondaryMailsPolicyChangedDetails {
            switch json {
                case .dictionary(let dict):
                    let previousValue = TeamLog.SecondaryMailsPolicySerializer().deserialize(dict["previous_value"] ?? .null)
                    let newValue = TeamLog.SecondaryMailsPolicySerializer().deserialize(dict["new_value"] ?? .null)
                    return SecondaryMailsPolicyChangedDetails(previousValue: previousValue, newValue: newValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SecondaryMailsPolicyChangedType struct
    open class SecondaryMailsPolicyChangedType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SecondaryMailsPolicyChangedTypeSerializer().serialize(self)))"
        }
    }
    open class SecondaryMailsPolicyChangedTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SecondaryMailsPolicyChangedType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SecondaryMailsPolicyChangedType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SecondaryMailsPolicyChangedType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Added team to shared folder.
    open class SfAddGroupDetails: CustomStringConvertible {
        /// Target asset position in the Assets list.
        public let targetAssetIndex: UInt64
        /// Original shared folder name.
        public let originalFolderName: String
        /// Sharing permission. Might be missing due to historical data gap.
        public let sharingPermission: String?
        /// Team name.
        public let teamName: String
        public init(targetAssetIndex: UInt64, originalFolderName: String, teamName: String, sharingPermission: String? = nil) {
            comparableValidator()(targetAssetIndex)
            self.targetAssetIndex = targetAssetIndex
            stringValidator()(originalFolderName)
            self.originalFolderName = originalFolderName
            nullableValidator(stringValidator())(sharingPermission)
            self.sharingPermission = sharingPermission
            stringValidator()(teamName)
            self.teamName = teamName
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SfAddGroupDetailsSerializer().serialize(self)))"
        }
    }
    open class SfAddGroupDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SfAddGroupDetails) -> JSON {
            let output = [ 
            "target_asset_index": Serialization._UInt64Serializer.serialize(value.targetAssetIndex),
            "original_folder_name": Serialization._StringSerializer.serialize(value.originalFolderName),
            "team_name": Serialization._StringSerializer.serialize(value.teamName),
            "sharing_permission": NullableSerializer(Serialization._StringSerializer).serialize(value.sharingPermission),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SfAddGroupDetails {
            switch json {
                case .dictionary(let dict):
                    let targetAssetIndex = Serialization._UInt64Serializer.deserialize(dict["target_asset_index"] ?? .null)
                    let originalFolderName = Serialization._StringSerializer.deserialize(dict["original_folder_name"] ?? .null)
                    let teamName = Serialization._StringSerializer.deserialize(dict["team_name"] ?? .null)
                    let sharingPermission = NullableSerializer(Serialization._StringSerializer).deserialize(dict["sharing_permission"] ?? .null)
                    return SfAddGroupDetails(targetAssetIndex: targetAssetIndex, originalFolderName: originalFolderName, teamName: teamName, sharingPermission: sharingPermission)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SfAddGroupType struct
    open class SfAddGroupType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SfAddGroupTypeSerializer().serialize(self)))"
        }
    }
    open class SfAddGroupTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SfAddGroupType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SfAddGroupType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SfAddGroupType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Allowed non-collaborators to view links to files in shared folder.
    open class SfAllowNonMembersToViewSharedLinksDetails: CustomStringConvertible {
        /// Target asset position in the Assets list.
        public let targetAssetIndex: UInt64
        /// Original shared folder name.
        public let originalFolderName: String
        /// Shared folder type. Might be missing due to historical data gap.
        public let sharedFolderType: String?
        public init(targetAssetIndex: UInt64, originalFolderName: String, sharedFolderType: String? = nil) {
            comparableValidator()(targetAssetIndex)
            self.targetAssetIndex = targetAssetIndex
            stringValidator()(originalFolderName)
            self.originalFolderName = originalFolderName
            nullableValidator(stringValidator())(sharedFolderType)
            self.sharedFolderType = sharedFolderType
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SfAllowNonMembersToViewSharedLinksDetailsSerializer().serialize(self)))"
        }
    }
    open class SfAllowNonMembersToViewSharedLinksDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SfAllowNonMembersToViewSharedLinksDetails) -> JSON {
            let output = [ 
            "target_asset_index": Serialization._UInt64Serializer.serialize(value.targetAssetIndex),
            "original_folder_name": Serialization._StringSerializer.serialize(value.originalFolderName),
            "shared_folder_type": NullableSerializer(Serialization._StringSerializer).serialize(value.sharedFolderType),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SfAllowNonMembersToViewSharedLinksDetails {
            switch json {
                case .dictionary(let dict):
                    let targetAssetIndex = Serialization._UInt64Serializer.deserialize(dict["target_asset_index"] ?? .null)
                    let originalFolderName = Serialization._StringSerializer.deserialize(dict["original_folder_name"] ?? .null)
                    let sharedFolderType = NullableSerializer(Serialization._StringSerializer).deserialize(dict["shared_folder_type"] ?? .null)
                    return SfAllowNonMembersToViewSharedLinksDetails(targetAssetIndex: targetAssetIndex, originalFolderName: originalFolderName, sharedFolderType: sharedFolderType)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SfAllowNonMembersToViewSharedLinksType struct
    open class SfAllowNonMembersToViewSharedLinksType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SfAllowNonMembersToViewSharedLinksTypeSerializer().serialize(self)))"
        }
    }
    open class SfAllowNonMembersToViewSharedLinksTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SfAllowNonMembersToViewSharedLinksType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SfAllowNonMembersToViewSharedLinksType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SfAllowNonMembersToViewSharedLinksType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Set team members to see warning before sharing folders outside team.
    open class SfExternalInviteWarnDetails: CustomStringConvertible {
        /// Target asset position in the Assets list.
        public let targetAssetIndex: UInt64
        /// Original shared folder name.
        public let originalFolderName: String
        /// New sharing permission. Might be missing due to historical data gap.
        public let newSharingPermission: String?
        /// Previous sharing permission. Might be missing due to historical data gap.
        public let previousSharingPermission: String?
        public init(targetAssetIndex: UInt64, originalFolderName: String, newSharingPermission: String? = nil, previousSharingPermission: String? = nil) {
            comparableValidator()(targetAssetIndex)
            self.targetAssetIndex = targetAssetIndex
            stringValidator()(originalFolderName)
            self.originalFolderName = originalFolderName
            nullableValidator(stringValidator())(newSharingPermission)
            self.newSharingPermission = newSharingPermission
            nullableValidator(stringValidator())(previousSharingPermission)
            self.previousSharingPermission = previousSharingPermission
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SfExternalInviteWarnDetailsSerializer().serialize(self)))"
        }
    }
    open class SfExternalInviteWarnDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SfExternalInviteWarnDetails) -> JSON {
            let output = [ 
            "target_asset_index": Serialization._UInt64Serializer.serialize(value.targetAssetIndex),
            "original_folder_name": Serialization._StringSerializer.serialize(value.originalFolderName),
            "new_sharing_permission": NullableSerializer(Serialization._StringSerializer).serialize(value.newSharingPermission),
            "previous_sharing_permission": NullableSerializer(Serialization._StringSerializer).serialize(value.previousSharingPermission),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SfExternalInviteWarnDetails {
            switch json {
                case .dictionary(let dict):
                    let targetAssetIndex = Serialization._UInt64Serializer.deserialize(dict["target_asset_index"] ?? .null)
                    let originalFolderName = Serialization._StringSerializer.deserialize(dict["original_folder_name"] ?? .null)
                    let newSharingPermission = NullableSerializer(Serialization._StringSerializer).deserialize(dict["new_sharing_permission"] ?? .null)
                    let previousSharingPermission = NullableSerializer(Serialization._StringSerializer).deserialize(dict["previous_sharing_permission"] ?? .null)
                    return SfExternalInviteWarnDetails(targetAssetIndex: targetAssetIndex, originalFolderName: originalFolderName, newSharingPermission: newSharingPermission, previousSharingPermission: previousSharingPermission)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SfExternalInviteWarnType struct
    open class SfExternalInviteWarnType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SfExternalInviteWarnTypeSerializer().serialize(self)))"
        }
    }
    open class SfExternalInviteWarnTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SfExternalInviteWarnType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SfExternalInviteWarnType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SfExternalInviteWarnType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed Facebook user's role in shared folder.
    open class SfFbInviteChangeRoleDetails: CustomStringConvertible {
        /// Target asset position in the Assets list.
        public let targetAssetIndex: UInt64
        /// Original shared folder name.
        public let originalFolderName: String
        /// Previous sharing permission. Might be missing due to historical data gap.
        public let previousSharingPermission: String?
        /// New sharing permission. Might be missing due to historical data gap.
        public let newSharingPermission: String?
        public init(targetAssetIndex: UInt64, originalFolderName: String, previousSharingPermission: String? = nil, newSharingPermission: String? = nil) {
            comparableValidator()(targetAssetIndex)
            self.targetAssetIndex = targetAssetIndex
            stringValidator()(originalFolderName)
            self.originalFolderName = originalFolderName
            nullableValidator(stringValidator())(previousSharingPermission)
            self.previousSharingPermission = previousSharingPermission
            nullableValidator(stringValidator())(newSharingPermission)
            self.newSharingPermission = newSharingPermission
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SfFbInviteChangeRoleDetailsSerializer().serialize(self)))"
        }
    }
    open class SfFbInviteChangeRoleDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SfFbInviteChangeRoleDetails) -> JSON {
            let output = [ 
            "target_asset_index": Serialization._UInt64Serializer.serialize(value.targetAssetIndex),
            "original_folder_name": Serialization._StringSerializer.serialize(value.originalFolderName),
            "previous_sharing_permission": NullableSerializer(Serialization._StringSerializer).serialize(value.previousSharingPermission),
            "new_sharing_permission": NullableSerializer(Serialization._StringSerializer).serialize(value.newSharingPermission),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SfFbInviteChangeRoleDetails {
            switch json {
                case .dictionary(let dict):
                    let targetAssetIndex = Serialization._UInt64Serializer.deserialize(dict["target_asset_index"] ?? .null)
                    let originalFolderName = Serialization._StringSerializer.deserialize(dict["original_folder_name"] ?? .null)
                    let previousSharingPermission = NullableSerializer(Serialization._StringSerializer).deserialize(dict["previous_sharing_permission"] ?? .null)
                    let newSharingPermission = NullableSerializer(Serialization._StringSerializer).deserialize(dict["new_sharing_permission"] ?? .null)
                    return SfFbInviteChangeRoleDetails(targetAssetIndex: targetAssetIndex, originalFolderName: originalFolderName, previousSharingPermission: previousSharingPermission, newSharingPermission: newSharingPermission)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SfFbInviteChangeRoleType struct
    open class SfFbInviteChangeRoleType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SfFbInviteChangeRoleTypeSerializer().serialize(self)))"
        }
    }
    open class SfFbInviteChangeRoleTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SfFbInviteChangeRoleType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SfFbInviteChangeRoleType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SfFbInviteChangeRoleType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Invited Facebook users to shared folder.
    open class SfFbInviteDetails: CustomStringConvertible {
        /// Target asset position in the Assets list.
        public let targetAssetIndex: UInt64
        /// Original shared folder name.
        public let originalFolderName: String
        /// Sharing permission. Might be missing due to historical data gap.
        public let sharingPermission: String?
        public init(targetAssetIndex: UInt64, originalFolderName: String, sharingPermission: String? = nil) {
            comparableValidator()(targetAssetIndex)
            self.targetAssetIndex = targetAssetIndex
            stringValidator()(originalFolderName)
            self.originalFolderName = originalFolderName
            nullableValidator(stringValidator())(sharingPermission)
            self.sharingPermission = sharingPermission
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SfFbInviteDetailsSerializer().serialize(self)))"
        }
    }
    open class SfFbInviteDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SfFbInviteDetails) -> JSON {
            let output = [ 
            "target_asset_index": Serialization._UInt64Serializer.serialize(value.targetAssetIndex),
            "original_folder_name": Serialization._StringSerializer.serialize(value.originalFolderName),
            "sharing_permission": NullableSerializer(Serialization._StringSerializer).serialize(value.sharingPermission),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SfFbInviteDetails {
            switch json {
                case .dictionary(let dict):
                    let targetAssetIndex = Serialization._UInt64Serializer.deserialize(dict["target_asset_index"] ?? .null)
                    let originalFolderName = Serialization._StringSerializer.deserialize(dict["original_folder_name"] ?? .null)
                    let sharingPermission = NullableSerializer(Serialization._StringSerializer).deserialize(dict["sharing_permission"] ?? .null)
                    return SfFbInviteDetails(targetAssetIndex: targetAssetIndex, originalFolderName: originalFolderName, sharingPermission: sharingPermission)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SfFbInviteType struct
    open class SfFbInviteType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SfFbInviteTypeSerializer().serialize(self)))"
        }
    }
    open class SfFbInviteTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SfFbInviteType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SfFbInviteType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SfFbInviteType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Uninvited Facebook user from shared folder.
    open class SfFbUninviteDetails: CustomStringConvertible {
        /// Target asset position in the Assets list.
        public let targetAssetIndex: UInt64
        /// Original shared folder name.
        public let originalFolderName: String
        public init(targetAssetIndex: UInt64, originalFolderName: String) {
            comparableValidator()(targetAssetIndex)
            self.targetAssetIndex = targetAssetIndex
            stringValidator()(originalFolderName)
            self.originalFolderName = originalFolderName
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SfFbUninviteDetailsSerializer().serialize(self)))"
        }
    }
    open class SfFbUninviteDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SfFbUninviteDetails) -> JSON {
            let output = [ 
            "target_asset_index": Serialization._UInt64Serializer.serialize(value.targetAssetIndex),
            "original_folder_name": Serialization._StringSerializer.serialize(value.originalFolderName),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SfFbUninviteDetails {
            switch json {
                case .dictionary(let dict):
                    let targetAssetIndex = Serialization._UInt64Serializer.deserialize(dict["target_asset_index"] ?? .null)
                    let originalFolderName = Serialization._StringSerializer.deserialize(dict["original_folder_name"] ?? .null)
                    return SfFbUninviteDetails(targetAssetIndex: targetAssetIndex, originalFolderName: originalFolderName)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SfFbUninviteType struct
    open class SfFbUninviteType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SfFbUninviteTypeSerializer().serialize(self)))"
        }
    }
    open class SfFbUninviteTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SfFbUninviteType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SfFbUninviteType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SfFbUninviteType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Invited group to shared folder.
    open class SfInviteGroupDetails: CustomStringConvertible {
        /// Target asset position in the Assets list.
        public let targetAssetIndex: UInt64
        public init(targetAssetIndex: UInt64) {
            comparableValidator()(targetAssetIndex)
            self.targetAssetIndex = targetAssetIndex
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SfInviteGroupDetailsSerializer().serialize(self)))"
        }
    }
    open class SfInviteGroupDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SfInviteGroupDetails) -> JSON {
            let output = [ 
            "target_asset_index": Serialization._UInt64Serializer.serialize(value.targetAssetIndex),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SfInviteGroupDetails {
            switch json {
                case .dictionary(let dict):
                    let targetAssetIndex = Serialization._UInt64Serializer.deserialize(dict["target_asset_index"] ?? .null)
                    return SfInviteGroupDetails(targetAssetIndex: targetAssetIndex)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SfInviteGroupType struct
    open class SfInviteGroupType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SfInviteGroupTypeSerializer().serialize(self)))"
        }
    }
    open class SfInviteGroupTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SfInviteGroupType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SfInviteGroupType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SfInviteGroupType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Granted access to shared folder.
    open class SfTeamGrantAccessDetails: CustomStringConvertible {
        /// Target asset position in the Assets list.
        public let targetAssetIndex: UInt64
        /// Original shared folder name.
        public let originalFolderName: String
        public init(targetAssetIndex: UInt64, originalFolderName: String) {
            comparableValidator()(targetAssetIndex)
            self.targetAssetIndex = targetAssetIndex
            stringValidator()(originalFolderName)
            self.originalFolderName = originalFolderName
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SfTeamGrantAccessDetailsSerializer().serialize(self)))"
        }
    }
    open class SfTeamGrantAccessDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SfTeamGrantAccessDetails) -> JSON {
            let output = [ 
            "target_asset_index": Serialization._UInt64Serializer.serialize(value.targetAssetIndex),
            "original_folder_name": Serialization._StringSerializer.serialize(value.originalFolderName),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SfTeamGrantAccessDetails {
            switch json {
                case .dictionary(let dict):
                    let targetAssetIndex = Serialization._UInt64Serializer.deserialize(dict["target_asset_index"] ?? .null)
                    let originalFolderName = Serialization._StringSerializer.deserialize(dict["original_folder_name"] ?? .null)
                    return SfTeamGrantAccessDetails(targetAssetIndex: targetAssetIndex, originalFolderName: originalFolderName)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SfTeamGrantAccessType struct
    open class SfTeamGrantAccessType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SfTeamGrantAccessTypeSerializer().serialize(self)))"
        }
    }
    open class SfTeamGrantAccessTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SfTeamGrantAccessType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SfTeamGrantAccessType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SfTeamGrantAccessType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed team member's role in shared folder.
    open class SfTeamInviteChangeRoleDetails: CustomStringConvertible {
        /// Target asset position in the Assets list.
        public let targetAssetIndex: UInt64
        /// Original shared folder name.
        public let originalFolderName: String
        /// New sharing permission. Might be missing due to historical data gap.
        public let newSharingPermission: String?
        /// Previous sharing permission. Might be missing due to historical data gap.
        public let previousSharingPermission: String?
        public init(targetAssetIndex: UInt64, originalFolderName: String, newSharingPermission: String? = nil, previousSharingPermission: String? = nil) {
            comparableValidator()(targetAssetIndex)
            self.targetAssetIndex = targetAssetIndex
            stringValidator()(originalFolderName)
            self.originalFolderName = originalFolderName
            nullableValidator(stringValidator())(newSharingPermission)
            self.newSharingPermission = newSharingPermission
            nullableValidator(stringValidator())(previousSharingPermission)
            self.previousSharingPermission = previousSharingPermission
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SfTeamInviteChangeRoleDetailsSerializer().serialize(self)))"
        }
    }
    open class SfTeamInviteChangeRoleDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SfTeamInviteChangeRoleDetails) -> JSON {
            let output = [ 
            "target_asset_index": Serialization._UInt64Serializer.serialize(value.targetAssetIndex),
            "original_folder_name": Serialization._StringSerializer.serialize(value.originalFolderName),
            "new_sharing_permission": NullableSerializer(Serialization._StringSerializer).serialize(value.newSharingPermission),
            "previous_sharing_permission": NullableSerializer(Serialization._StringSerializer).serialize(value.previousSharingPermission),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SfTeamInviteChangeRoleDetails {
            switch json {
                case .dictionary(let dict):
                    let targetAssetIndex = Serialization._UInt64Serializer.deserialize(dict["target_asset_index"] ?? .null)
                    let originalFolderName = Serialization._StringSerializer.deserialize(dict["original_folder_name"] ?? .null)
                    let newSharingPermission = NullableSerializer(Serialization._StringSerializer).deserialize(dict["new_sharing_permission"] ?? .null)
                    let previousSharingPermission = NullableSerializer(Serialization._StringSerializer).deserialize(dict["previous_sharing_permission"] ?? .null)
                    return SfTeamInviteChangeRoleDetails(targetAssetIndex: targetAssetIndex, originalFolderName: originalFolderName, newSharingPermission: newSharingPermission, previousSharingPermission: previousSharingPermission)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SfTeamInviteChangeRoleType struct
    open class SfTeamInviteChangeRoleType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SfTeamInviteChangeRoleTypeSerializer().serialize(self)))"
        }
    }
    open class SfTeamInviteChangeRoleTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SfTeamInviteChangeRoleType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SfTeamInviteChangeRoleType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SfTeamInviteChangeRoleType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Invited team members to shared folder.
    open class SfTeamInviteDetails: CustomStringConvertible {
        /// Target asset position in the Assets list.
        public let targetAssetIndex: UInt64
        /// Original shared folder name.
        public let originalFolderName: String
        /// Sharing permission. Might be missing due to historical data gap.
        public let sharingPermission: String?
        public init(targetAssetIndex: UInt64, originalFolderName: String, sharingPermission: String? = nil) {
            comparableValidator()(targetAssetIndex)
            self.targetAssetIndex = targetAssetIndex
            stringValidator()(originalFolderName)
            self.originalFolderName = originalFolderName
            nullableValidator(stringValidator())(sharingPermission)
            self.sharingPermission = sharingPermission
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SfTeamInviteDetailsSerializer().serialize(self)))"
        }
    }
    open class SfTeamInviteDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SfTeamInviteDetails) -> JSON {
            let output = [ 
            "target_asset_index": Serialization._UInt64Serializer.serialize(value.targetAssetIndex),
            "original_folder_name": Serialization._StringSerializer.serialize(value.originalFolderName),
            "sharing_permission": NullableSerializer(Serialization._StringSerializer).serialize(value.sharingPermission),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SfTeamInviteDetails {
            switch json {
                case .dictionary(let dict):
                    let targetAssetIndex = Serialization._UInt64Serializer.deserialize(dict["target_asset_index"] ?? .null)
                    let originalFolderName = Serialization._StringSerializer.deserialize(dict["original_folder_name"] ?? .null)
                    let sharingPermission = NullableSerializer(Serialization._StringSerializer).deserialize(dict["sharing_permission"] ?? .null)
                    return SfTeamInviteDetails(targetAssetIndex: targetAssetIndex, originalFolderName: originalFolderName, sharingPermission: sharingPermission)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SfTeamInviteType struct
    open class SfTeamInviteType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SfTeamInviteTypeSerializer().serialize(self)))"
        }
    }
    open class SfTeamInviteTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SfTeamInviteType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SfTeamInviteType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SfTeamInviteType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Joined team member's shared folder.
    open class SfTeamJoinDetails: CustomStringConvertible {
        /// Target asset position in the Assets list.
        public let targetAssetIndex: UInt64
        /// Original shared folder name.
        public let originalFolderName: String
        public init(targetAssetIndex: UInt64, originalFolderName: String) {
            comparableValidator()(targetAssetIndex)
            self.targetAssetIndex = targetAssetIndex
            stringValidator()(originalFolderName)
            self.originalFolderName = originalFolderName
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SfTeamJoinDetailsSerializer().serialize(self)))"
        }
    }
    open class SfTeamJoinDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SfTeamJoinDetails) -> JSON {
            let output = [ 
            "target_asset_index": Serialization._UInt64Serializer.serialize(value.targetAssetIndex),
            "original_folder_name": Serialization._StringSerializer.serialize(value.originalFolderName),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SfTeamJoinDetails {
            switch json {
                case .dictionary(let dict):
                    let targetAssetIndex = Serialization._UInt64Serializer.deserialize(dict["target_asset_index"] ?? .null)
                    let originalFolderName = Serialization._StringSerializer.deserialize(dict["original_folder_name"] ?? .null)
                    return SfTeamJoinDetails(targetAssetIndex: targetAssetIndex, originalFolderName: originalFolderName)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Joined team member's shared folder from link.
    open class SfTeamJoinFromOobLinkDetails: CustomStringConvertible {
        /// Target asset position in the Assets list.
        public let targetAssetIndex: UInt64
        /// Original shared folder name.
        public let originalFolderName: String
        /// Shared link token key.
        public let tokenKey: String?
        /// Sharing permission. Might be missing due to historical data gap.
        public let sharingPermission: String?
        public init(targetAssetIndex: UInt64, originalFolderName: String, tokenKey: String? = nil, sharingPermission: String? = nil) {
            comparableValidator()(targetAssetIndex)
            self.targetAssetIndex = targetAssetIndex
            stringValidator()(originalFolderName)
            self.originalFolderName = originalFolderName
            nullableValidator(stringValidator())(tokenKey)
            self.tokenKey = tokenKey
            nullableValidator(stringValidator())(sharingPermission)
            self.sharingPermission = sharingPermission
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SfTeamJoinFromOobLinkDetailsSerializer().serialize(self)))"
        }
    }
    open class SfTeamJoinFromOobLinkDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SfTeamJoinFromOobLinkDetails) -> JSON {
            let output = [ 
            "target_asset_index": Serialization._UInt64Serializer.serialize(value.targetAssetIndex),
            "original_folder_name": Serialization._StringSerializer.serialize(value.originalFolderName),
            "token_key": NullableSerializer(Serialization._StringSerializer).serialize(value.tokenKey),
            "sharing_permission": NullableSerializer(Serialization._StringSerializer).serialize(value.sharingPermission),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SfTeamJoinFromOobLinkDetails {
            switch json {
                case .dictionary(let dict):
                    let targetAssetIndex = Serialization._UInt64Serializer.deserialize(dict["target_asset_index"] ?? .null)
                    let originalFolderName = Serialization._StringSerializer.deserialize(dict["original_folder_name"] ?? .null)
                    let tokenKey = NullableSerializer(Serialization._StringSerializer).deserialize(dict["token_key"] ?? .null)
                    let sharingPermission = NullableSerializer(Serialization._StringSerializer).deserialize(dict["sharing_permission"] ?? .null)
                    return SfTeamJoinFromOobLinkDetails(targetAssetIndex: targetAssetIndex, originalFolderName: originalFolderName, tokenKey: tokenKey, sharingPermission: sharingPermission)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SfTeamJoinFromOobLinkType struct
    open class SfTeamJoinFromOobLinkType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SfTeamJoinFromOobLinkTypeSerializer().serialize(self)))"
        }
    }
    open class SfTeamJoinFromOobLinkTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SfTeamJoinFromOobLinkType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SfTeamJoinFromOobLinkType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SfTeamJoinFromOobLinkType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SfTeamJoinType struct
    open class SfTeamJoinType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SfTeamJoinTypeSerializer().serialize(self)))"
        }
    }
    open class SfTeamJoinTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SfTeamJoinType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SfTeamJoinType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SfTeamJoinType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Unshared folder with team member.
    open class SfTeamUninviteDetails: CustomStringConvertible {
        /// Target asset position in the Assets list.
        public let targetAssetIndex: UInt64
        /// Original shared folder name.
        public let originalFolderName: String
        public init(targetAssetIndex: UInt64, originalFolderName: String) {
            comparableValidator()(targetAssetIndex)
            self.targetAssetIndex = targetAssetIndex
            stringValidator()(originalFolderName)
            self.originalFolderName = originalFolderName
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SfTeamUninviteDetailsSerializer().serialize(self)))"
        }
    }
    open class SfTeamUninviteDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SfTeamUninviteDetails) -> JSON {
            let output = [ 
            "target_asset_index": Serialization._UInt64Serializer.serialize(value.targetAssetIndex),
            "original_folder_name": Serialization._StringSerializer.serialize(value.originalFolderName),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SfTeamUninviteDetails {
            switch json {
                case .dictionary(let dict):
                    let targetAssetIndex = Serialization._UInt64Serializer.deserialize(dict["target_asset_index"] ?? .null)
                    let originalFolderName = Serialization._StringSerializer.deserialize(dict["original_folder_name"] ?? .null)
                    return SfTeamUninviteDetails(targetAssetIndex: targetAssetIndex, originalFolderName: originalFolderName)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SfTeamUninviteType struct
    open class SfTeamUninviteType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SfTeamUninviteTypeSerializer().serialize(self)))"
        }
    }
    open class SfTeamUninviteTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SfTeamUninviteType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SfTeamUninviteType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SfTeamUninviteType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Invited user to Dropbox and added them to shared file/folder.
    open class SharedContentAddInviteesDetails: CustomStringConvertible {
        /// Shared content access level.
        public let sharedContentAccessLevel: Sharing.AccessLevel
        /// A list of invitees.
        public let invitees: Array<String>
        public init(sharedContentAccessLevel: Sharing.AccessLevel, invitees: Array<String>) {
            self.sharedContentAccessLevel = sharedContentAccessLevel
            arrayValidator(itemValidator: stringValidator(maxLength: 255))(invitees)
            self.invitees = invitees
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentAddInviteesDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedContentAddInviteesDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentAddInviteesDetails) -> JSON {
            let output = [ 
            "shared_content_access_level": Sharing.AccessLevelSerializer().serialize(value.sharedContentAccessLevel),
            "invitees": ArraySerializer(Serialization._StringSerializer).serialize(value.invitees),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentAddInviteesDetails {
            switch json {
                case .dictionary(let dict):
                    let sharedContentAccessLevel = Sharing.AccessLevelSerializer().deserialize(dict["shared_content_access_level"] ?? .null)
                    let invitees = ArraySerializer(Serialization._StringSerializer).deserialize(dict["invitees"] ?? .null)
                    return SharedContentAddInviteesDetails(sharedContentAccessLevel: sharedContentAccessLevel, invitees: invitees)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedContentAddInviteesType struct
    open class SharedContentAddInviteesType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentAddInviteesTypeSerializer().serialize(self)))"
        }
    }
    open class SharedContentAddInviteesTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentAddInviteesType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentAddInviteesType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedContentAddInviteesType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Added expiration date to link for shared file/folder.
    open class SharedContentAddLinkExpiryDetails: CustomStringConvertible {
        /// New shared content link expiration date. Might be missing due to historical data gap.
        public let newValue: Date?
        public init(newValue: Date? = nil) {
            self.newValue = newValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentAddLinkExpiryDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedContentAddLinkExpiryDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentAddLinkExpiryDetails) -> JSON {
            let output = [ 
            "new_value": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.newValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentAddLinkExpiryDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["new_value"] ?? .null)
                    return SharedContentAddLinkExpiryDetails(newValue: newValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedContentAddLinkExpiryType struct
    open class SharedContentAddLinkExpiryType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentAddLinkExpiryTypeSerializer().serialize(self)))"
        }
    }
    open class SharedContentAddLinkExpiryTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentAddLinkExpiryType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentAddLinkExpiryType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedContentAddLinkExpiryType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Added password to link for shared file/folder.
    open class SharedContentAddLinkPasswordDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentAddLinkPasswordDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedContentAddLinkPasswordDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentAddLinkPasswordDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentAddLinkPasswordDetails {
            switch json {
                case .dictionary(_):
                    return SharedContentAddLinkPasswordDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedContentAddLinkPasswordType struct
    open class SharedContentAddLinkPasswordType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentAddLinkPasswordTypeSerializer().serialize(self)))"
        }
    }
    open class SharedContentAddLinkPasswordTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentAddLinkPasswordType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentAddLinkPasswordType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedContentAddLinkPasswordType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Added users and/or groups to shared file/folder.
    open class SharedContentAddMemberDetails: CustomStringConvertible {
        /// Shared content access level.
        public let sharedContentAccessLevel: Sharing.AccessLevel
        public init(sharedContentAccessLevel: Sharing.AccessLevel) {
            self.sharedContentAccessLevel = sharedContentAccessLevel
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentAddMemberDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedContentAddMemberDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentAddMemberDetails) -> JSON {
            let output = [ 
            "shared_content_access_level": Sharing.AccessLevelSerializer().serialize(value.sharedContentAccessLevel),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentAddMemberDetails {
            switch json {
                case .dictionary(let dict):
                    let sharedContentAccessLevel = Sharing.AccessLevelSerializer().deserialize(dict["shared_content_access_level"] ?? .null)
                    return SharedContentAddMemberDetails(sharedContentAccessLevel: sharedContentAccessLevel)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedContentAddMemberType struct
    open class SharedContentAddMemberType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentAddMemberTypeSerializer().serialize(self)))"
        }
    }
    open class SharedContentAddMemberTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentAddMemberType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentAddMemberType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedContentAddMemberType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed whether members can download shared file/folder.
    open class SharedContentChangeDownloadsPolicyDetails: CustomStringConvertible {
        /// New downloads policy.
        public let newValue: TeamLog.DownloadPolicyType
        /// Previous downloads policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.DownloadPolicyType?
        public init(newValue: TeamLog.DownloadPolicyType, previousValue: TeamLog.DownloadPolicyType? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentChangeDownloadsPolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedContentChangeDownloadsPolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentChangeDownloadsPolicyDetails) -> JSON {
            let output = [ 
            "new_value": TeamLog.DownloadPolicyTypeSerializer().serialize(value.newValue),
            "previous_value": NullableSerializer(TeamLog.DownloadPolicyTypeSerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentChangeDownloadsPolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = TeamLog.DownloadPolicyTypeSerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(TeamLog.DownloadPolicyTypeSerializer()).deserialize(dict["previous_value"] ?? .null)
                    return SharedContentChangeDownloadsPolicyDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedContentChangeDownloadsPolicyType struct
    open class SharedContentChangeDownloadsPolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentChangeDownloadsPolicyTypeSerializer().serialize(self)))"
        }
    }
    open class SharedContentChangeDownloadsPolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentChangeDownloadsPolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentChangeDownloadsPolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedContentChangeDownloadsPolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed access type of invitee to shared file/folder before invite was accepted.
    open class SharedContentChangeInviteeRoleDetails: CustomStringConvertible {
        /// Previous access level. Might be missing due to historical data gap.
        public let previousAccessLevel: Sharing.AccessLevel?
        /// New access level.
        public let newAccessLevel: Sharing.AccessLevel
        /// The invitee whose role was changed.
        public let invitee: String
        public init(newAccessLevel: Sharing.AccessLevel, invitee: String, previousAccessLevel: Sharing.AccessLevel? = nil) {
            self.previousAccessLevel = previousAccessLevel
            self.newAccessLevel = newAccessLevel
            stringValidator(maxLength: 255)(invitee)
            self.invitee = invitee
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentChangeInviteeRoleDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedContentChangeInviteeRoleDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentChangeInviteeRoleDetails) -> JSON {
            let output = [ 
            "new_access_level": Sharing.AccessLevelSerializer().serialize(value.newAccessLevel),
            "invitee": Serialization._StringSerializer.serialize(value.invitee),
            "previous_access_level": NullableSerializer(Sharing.AccessLevelSerializer()).serialize(value.previousAccessLevel),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentChangeInviteeRoleDetails {
            switch json {
                case .dictionary(let dict):
                    let newAccessLevel = Sharing.AccessLevelSerializer().deserialize(dict["new_access_level"] ?? .null)
                    let invitee = Serialization._StringSerializer.deserialize(dict["invitee"] ?? .null)
                    let previousAccessLevel = NullableSerializer(Sharing.AccessLevelSerializer()).deserialize(dict["previous_access_level"] ?? .null)
                    return SharedContentChangeInviteeRoleDetails(newAccessLevel: newAccessLevel, invitee: invitee, previousAccessLevel: previousAccessLevel)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedContentChangeInviteeRoleType struct
    open class SharedContentChangeInviteeRoleType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentChangeInviteeRoleTypeSerializer().serialize(self)))"
        }
    }
    open class SharedContentChangeInviteeRoleTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentChangeInviteeRoleType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentChangeInviteeRoleType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedContentChangeInviteeRoleType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed link audience of shared file/folder.
    open class SharedContentChangeLinkAudienceDetails: CustomStringConvertible {
        /// New link audience value.
        public let newValue: Sharing.LinkAudience
        /// Previous link audience value.
        public let previousValue: Sharing.LinkAudience?
        public init(newValue: Sharing.LinkAudience, previousValue: Sharing.LinkAudience? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentChangeLinkAudienceDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedContentChangeLinkAudienceDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentChangeLinkAudienceDetails) -> JSON {
            let output = [ 
            "new_value": Sharing.LinkAudienceSerializer().serialize(value.newValue),
            "previous_value": NullableSerializer(Sharing.LinkAudienceSerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentChangeLinkAudienceDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = Sharing.LinkAudienceSerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(Sharing.LinkAudienceSerializer()).deserialize(dict["previous_value"] ?? .null)
                    return SharedContentChangeLinkAudienceDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedContentChangeLinkAudienceType struct
    open class SharedContentChangeLinkAudienceType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentChangeLinkAudienceTypeSerializer().serialize(self)))"
        }
    }
    open class SharedContentChangeLinkAudienceTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentChangeLinkAudienceType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentChangeLinkAudienceType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedContentChangeLinkAudienceType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed link expiration of shared file/folder.
    open class SharedContentChangeLinkExpiryDetails: CustomStringConvertible {
        /// New shared content link expiration date. Might be missing due to historical data gap.
        public let newValue: Date?
        /// Previous shared content link expiration date. Might be missing due to historical data gap.
        public let previousValue: Date?
        public init(newValue: Date? = nil, previousValue: Date? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentChangeLinkExpiryDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedContentChangeLinkExpiryDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentChangeLinkExpiryDetails) -> JSON {
            let output = [ 
            "new_value": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.newValue),
            "previous_value": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentChangeLinkExpiryDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["previous_value"] ?? .null)
                    return SharedContentChangeLinkExpiryDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedContentChangeLinkExpiryType struct
    open class SharedContentChangeLinkExpiryType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentChangeLinkExpiryTypeSerializer().serialize(self)))"
        }
    }
    open class SharedContentChangeLinkExpiryTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentChangeLinkExpiryType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentChangeLinkExpiryType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedContentChangeLinkExpiryType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed link password of shared file/folder.
    open class SharedContentChangeLinkPasswordDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentChangeLinkPasswordDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedContentChangeLinkPasswordDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentChangeLinkPasswordDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentChangeLinkPasswordDetails {
            switch json {
                case .dictionary(_):
                    return SharedContentChangeLinkPasswordDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedContentChangeLinkPasswordType struct
    open class SharedContentChangeLinkPasswordType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentChangeLinkPasswordTypeSerializer().serialize(self)))"
        }
    }
    open class SharedContentChangeLinkPasswordTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentChangeLinkPasswordType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentChangeLinkPasswordType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedContentChangeLinkPasswordType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed access type of shared file/folder member.
    open class SharedContentChangeMemberRoleDetails: CustomStringConvertible {
        /// Previous access level. Might be missing due to historical data gap.
        public let previousAccessLevel: Sharing.AccessLevel?
        /// New access level.
        public let newAccessLevel: Sharing.AccessLevel
        public init(newAccessLevel: Sharing.AccessLevel, previousAccessLevel: Sharing.AccessLevel? = nil) {
            self.previousAccessLevel = previousAccessLevel
            self.newAccessLevel = newAccessLevel
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentChangeMemberRoleDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedContentChangeMemberRoleDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentChangeMemberRoleDetails) -> JSON {
            let output = [ 
            "new_access_level": Sharing.AccessLevelSerializer().serialize(value.newAccessLevel),
            "previous_access_level": NullableSerializer(Sharing.AccessLevelSerializer()).serialize(value.previousAccessLevel),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentChangeMemberRoleDetails {
            switch json {
                case .dictionary(let dict):
                    let newAccessLevel = Sharing.AccessLevelSerializer().deserialize(dict["new_access_level"] ?? .null)
                    let previousAccessLevel = NullableSerializer(Sharing.AccessLevelSerializer()).deserialize(dict["previous_access_level"] ?? .null)
                    return SharedContentChangeMemberRoleDetails(newAccessLevel: newAccessLevel, previousAccessLevel: previousAccessLevel)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedContentChangeMemberRoleType struct
    open class SharedContentChangeMemberRoleType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentChangeMemberRoleTypeSerializer().serialize(self)))"
        }
    }
    open class SharedContentChangeMemberRoleTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentChangeMemberRoleType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentChangeMemberRoleType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedContentChangeMemberRoleType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed whether members can see who viewed shared file/folder.
    open class SharedContentChangeViewerInfoPolicyDetails: CustomStringConvertible {
        /// New viewer info policy.
        public let newValue: Sharing.ViewerInfoPolicy
        /// Previous view info policy. Might be missing due to historical data gap.
        public let previousValue: Sharing.ViewerInfoPolicy?
        public init(newValue: Sharing.ViewerInfoPolicy, previousValue: Sharing.ViewerInfoPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentChangeViewerInfoPolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedContentChangeViewerInfoPolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentChangeViewerInfoPolicyDetails) -> JSON {
            let output = [ 
            "new_value": Sharing.ViewerInfoPolicySerializer().serialize(value.newValue),
            "previous_value": NullableSerializer(Sharing.ViewerInfoPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentChangeViewerInfoPolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = Sharing.ViewerInfoPolicySerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(Sharing.ViewerInfoPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                    return SharedContentChangeViewerInfoPolicyDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedContentChangeViewerInfoPolicyType struct
    open class SharedContentChangeViewerInfoPolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentChangeViewerInfoPolicyTypeSerializer().serialize(self)))"
        }
    }
    open class SharedContentChangeViewerInfoPolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentChangeViewerInfoPolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentChangeViewerInfoPolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedContentChangeViewerInfoPolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Acquired membership of shared file/folder by accepting invite.
    open class SharedContentClaimInvitationDetails: CustomStringConvertible {
        /// Shared content link.
        public let sharedContentLink: String?
        public init(sharedContentLink: String? = nil) {
            nullableValidator(stringValidator())(sharedContentLink)
            self.sharedContentLink = sharedContentLink
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentClaimInvitationDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedContentClaimInvitationDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentClaimInvitationDetails) -> JSON {
            let output = [ 
            "shared_content_link": NullableSerializer(Serialization._StringSerializer).serialize(value.sharedContentLink),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentClaimInvitationDetails {
            switch json {
                case .dictionary(let dict):
                    let sharedContentLink = NullableSerializer(Serialization._StringSerializer).deserialize(dict["shared_content_link"] ?? .null)
                    return SharedContentClaimInvitationDetails(sharedContentLink: sharedContentLink)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedContentClaimInvitationType struct
    open class SharedContentClaimInvitationType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentClaimInvitationTypeSerializer().serialize(self)))"
        }
    }
    open class SharedContentClaimInvitationTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentClaimInvitationType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentClaimInvitationType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedContentClaimInvitationType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Copied shared file/folder to own Dropbox.
    open class SharedContentCopyDetails: CustomStringConvertible {
        /// Shared content link.
        public let sharedContentLink: String
        /// The shared content owner.
        public let sharedContentOwner: TeamLog.UserLogInfo?
        /// Shared content access level.
        public let sharedContentAccessLevel: Sharing.AccessLevel
        /// The path where the member saved the content.
        public let destinationPath: String
        public init(sharedContentLink: String, sharedContentAccessLevel: Sharing.AccessLevel, destinationPath: String, sharedContentOwner: TeamLog.UserLogInfo? = nil) {
            stringValidator()(sharedContentLink)
            self.sharedContentLink = sharedContentLink
            self.sharedContentOwner = sharedContentOwner
            self.sharedContentAccessLevel = sharedContentAccessLevel
            stringValidator()(destinationPath)
            self.destinationPath = destinationPath
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentCopyDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedContentCopyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentCopyDetails) -> JSON {
            let output = [ 
            "shared_content_link": Serialization._StringSerializer.serialize(value.sharedContentLink),
            "shared_content_access_level": Sharing.AccessLevelSerializer().serialize(value.sharedContentAccessLevel),
            "destination_path": Serialization._StringSerializer.serialize(value.destinationPath),
            "shared_content_owner": NullableSerializer(TeamLog.UserLogInfoSerializer()).serialize(value.sharedContentOwner),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentCopyDetails {
            switch json {
                case .dictionary(let dict):
                    let sharedContentLink = Serialization._StringSerializer.deserialize(dict["shared_content_link"] ?? .null)
                    let sharedContentAccessLevel = Sharing.AccessLevelSerializer().deserialize(dict["shared_content_access_level"] ?? .null)
                    let destinationPath = Serialization._StringSerializer.deserialize(dict["destination_path"] ?? .null)
                    let sharedContentOwner = NullableSerializer(TeamLog.UserLogInfoSerializer()).deserialize(dict["shared_content_owner"] ?? .null)
                    return SharedContentCopyDetails(sharedContentLink: sharedContentLink, sharedContentAccessLevel: sharedContentAccessLevel, destinationPath: destinationPath, sharedContentOwner: sharedContentOwner)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedContentCopyType struct
    open class SharedContentCopyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentCopyTypeSerializer().serialize(self)))"
        }
    }
    open class SharedContentCopyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentCopyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentCopyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedContentCopyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Downloaded shared file/folder.
    open class SharedContentDownloadDetails: CustomStringConvertible {
        /// Shared content link.
        public let sharedContentLink: String
        /// The shared content owner.
        public let sharedContentOwner: TeamLog.UserLogInfo?
        /// Shared content access level.
        public let sharedContentAccessLevel: Sharing.AccessLevel
        public init(sharedContentLink: String, sharedContentAccessLevel: Sharing.AccessLevel, sharedContentOwner: TeamLog.UserLogInfo? = nil) {
            stringValidator()(sharedContentLink)
            self.sharedContentLink = sharedContentLink
            self.sharedContentOwner = sharedContentOwner
            self.sharedContentAccessLevel = sharedContentAccessLevel
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentDownloadDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedContentDownloadDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentDownloadDetails) -> JSON {
            let output = [ 
            "shared_content_link": Serialization._StringSerializer.serialize(value.sharedContentLink),
            "shared_content_access_level": Sharing.AccessLevelSerializer().serialize(value.sharedContentAccessLevel),
            "shared_content_owner": NullableSerializer(TeamLog.UserLogInfoSerializer()).serialize(value.sharedContentOwner),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentDownloadDetails {
            switch json {
                case .dictionary(let dict):
                    let sharedContentLink = Serialization._StringSerializer.deserialize(dict["shared_content_link"] ?? .null)
                    let sharedContentAccessLevel = Sharing.AccessLevelSerializer().deserialize(dict["shared_content_access_level"] ?? .null)
                    let sharedContentOwner = NullableSerializer(TeamLog.UserLogInfoSerializer()).deserialize(dict["shared_content_owner"] ?? .null)
                    return SharedContentDownloadDetails(sharedContentLink: sharedContentLink, sharedContentAccessLevel: sharedContentAccessLevel, sharedContentOwner: sharedContentOwner)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedContentDownloadType struct
    open class SharedContentDownloadType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentDownloadTypeSerializer().serialize(self)))"
        }
    }
    open class SharedContentDownloadTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentDownloadType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentDownloadType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedContentDownloadType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Left shared file/folder.
    open class SharedContentRelinquishMembershipDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentRelinquishMembershipDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedContentRelinquishMembershipDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentRelinquishMembershipDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentRelinquishMembershipDetails {
            switch json {
                case .dictionary(_):
                    return SharedContentRelinquishMembershipDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedContentRelinquishMembershipType struct
    open class SharedContentRelinquishMembershipType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentRelinquishMembershipTypeSerializer().serialize(self)))"
        }
    }
    open class SharedContentRelinquishMembershipTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentRelinquishMembershipType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentRelinquishMembershipType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedContentRelinquishMembershipType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Removed invitee from shared file/folder before invite was accepted.
    open class SharedContentRemoveInviteesDetails: CustomStringConvertible {
        /// A list of invitees.
        public let invitees: Array<String>
        public init(invitees: Array<String>) {
            arrayValidator(itemValidator: stringValidator(maxLength: 255))(invitees)
            self.invitees = invitees
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentRemoveInviteesDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedContentRemoveInviteesDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentRemoveInviteesDetails) -> JSON {
            let output = [ 
            "invitees": ArraySerializer(Serialization._StringSerializer).serialize(value.invitees),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentRemoveInviteesDetails {
            switch json {
                case .dictionary(let dict):
                    let invitees = ArraySerializer(Serialization._StringSerializer).deserialize(dict["invitees"] ?? .null)
                    return SharedContentRemoveInviteesDetails(invitees: invitees)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedContentRemoveInviteesType struct
    open class SharedContentRemoveInviteesType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentRemoveInviteesTypeSerializer().serialize(self)))"
        }
    }
    open class SharedContentRemoveInviteesTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentRemoveInviteesType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentRemoveInviteesType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedContentRemoveInviteesType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Removed link expiration date of shared file/folder.
    open class SharedContentRemoveLinkExpiryDetails: CustomStringConvertible {
        /// Previous shared content link expiration date. Might be missing due to historical data gap.
        public let previousValue: Date?
        public init(previousValue: Date? = nil) {
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentRemoveLinkExpiryDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedContentRemoveLinkExpiryDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentRemoveLinkExpiryDetails) -> JSON {
            let output = [ 
            "previous_value": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentRemoveLinkExpiryDetails {
            switch json {
                case .dictionary(let dict):
                    let previousValue = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["previous_value"] ?? .null)
                    return SharedContentRemoveLinkExpiryDetails(previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedContentRemoveLinkExpiryType struct
    open class SharedContentRemoveLinkExpiryType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentRemoveLinkExpiryTypeSerializer().serialize(self)))"
        }
    }
    open class SharedContentRemoveLinkExpiryTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentRemoveLinkExpiryType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentRemoveLinkExpiryType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedContentRemoveLinkExpiryType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Removed link password of shared file/folder.
    open class SharedContentRemoveLinkPasswordDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentRemoveLinkPasswordDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedContentRemoveLinkPasswordDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentRemoveLinkPasswordDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentRemoveLinkPasswordDetails {
            switch json {
                case .dictionary(_):
                    return SharedContentRemoveLinkPasswordDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedContentRemoveLinkPasswordType struct
    open class SharedContentRemoveLinkPasswordType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentRemoveLinkPasswordTypeSerializer().serialize(self)))"
        }
    }
    open class SharedContentRemoveLinkPasswordTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentRemoveLinkPasswordType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentRemoveLinkPasswordType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedContentRemoveLinkPasswordType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Removed user/group from shared file/folder.
    open class SharedContentRemoveMemberDetails: CustomStringConvertible {
        /// Shared content access level.
        public let sharedContentAccessLevel: Sharing.AccessLevel?
        public init(sharedContentAccessLevel: Sharing.AccessLevel? = nil) {
            self.sharedContentAccessLevel = sharedContentAccessLevel
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentRemoveMemberDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedContentRemoveMemberDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentRemoveMemberDetails) -> JSON {
            let output = [ 
            "shared_content_access_level": NullableSerializer(Sharing.AccessLevelSerializer()).serialize(value.sharedContentAccessLevel),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentRemoveMemberDetails {
            switch json {
                case .dictionary(let dict):
                    let sharedContentAccessLevel = NullableSerializer(Sharing.AccessLevelSerializer()).deserialize(dict["shared_content_access_level"] ?? .null)
                    return SharedContentRemoveMemberDetails(sharedContentAccessLevel: sharedContentAccessLevel)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedContentRemoveMemberType struct
    open class SharedContentRemoveMemberType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentRemoveMemberTypeSerializer().serialize(self)))"
        }
    }
    open class SharedContentRemoveMemberTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentRemoveMemberType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentRemoveMemberType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedContentRemoveMemberType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Requested access to shared file/folder.
    open class SharedContentRequestAccessDetails: CustomStringConvertible {
        /// Shared content link.
        public let sharedContentLink: String?
        public init(sharedContentLink: String? = nil) {
            nullableValidator(stringValidator())(sharedContentLink)
            self.sharedContentLink = sharedContentLink
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentRequestAccessDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedContentRequestAccessDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentRequestAccessDetails) -> JSON {
            let output = [ 
            "shared_content_link": NullableSerializer(Serialization._StringSerializer).serialize(value.sharedContentLink),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentRequestAccessDetails {
            switch json {
                case .dictionary(let dict):
                    let sharedContentLink = NullableSerializer(Serialization._StringSerializer).deserialize(dict["shared_content_link"] ?? .null)
                    return SharedContentRequestAccessDetails(sharedContentLink: sharedContentLink)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedContentRequestAccessType struct
    open class SharedContentRequestAccessType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentRequestAccessTypeSerializer().serialize(self)))"
        }
    }
    open class SharedContentRequestAccessTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentRequestAccessType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentRequestAccessType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedContentRequestAccessType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Unshared file/folder by clearing membership and turning off link.
    open class SharedContentUnshareDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentUnshareDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedContentUnshareDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentUnshareDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentUnshareDetails {
            switch json {
                case .dictionary(_):
                    return SharedContentUnshareDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedContentUnshareType struct
    open class SharedContentUnshareType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentUnshareTypeSerializer().serialize(self)))"
        }
    }
    open class SharedContentUnshareTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentUnshareType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentUnshareType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedContentUnshareType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Previewed shared file/folder.
    open class SharedContentViewDetails: CustomStringConvertible {
        /// Shared content link.
        public let sharedContentLink: String
        /// The shared content owner.
        public let sharedContentOwner: TeamLog.UserLogInfo?
        /// Shared content access level.
        public let sharedContentAccessLevel: Sharing.AccessLevel
        public init(sharedContentLink: String, sharedContentAccessLevel: Sharing.AccessLevel, sharedContentOwner: TeamLog.UserLogInfo? = nil) {
            stringValidator()(sharedContentLink)
            self.sharedContentLink = sharedContentLink
            self.sharedContentOwner = sharedContentOwner
            self.sharedContentAccessLevel = sharedContentAccessLevel
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentViewDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedContentViewDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentViewDetails) -> JSON {
            let output = [ 
            "shared_content_link": Serialization._StringSerializer.serialize(value.sharedContentLink),
            "shared_content_access_level": Sharing.AccessLevelSerializer().serialize(value.sharedContentAccessLevel),
            "shared_content_owner": NullableSerializer(TeamLog.UserLogInfoSerializer()).serialize(value.sharedContentOwner),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentViewDetails {
            switch json {
                case .dictionary(let dict):
                    let sharedContentLink = Serialization._StringSerializer.deserialize(dict["shared_content_link"] ?? .null)
                    let sharedContentAccessLevel = Sharing.AccessLevelSerializer().deserialize(dict["shared_content_access_level"] ?? .null)
                    let sharedContentOwner = NullableSerializer(TeamLog.UserLogInfoSerializer()).deserialize(dict["shared_content_owner"] ?? .null)
                    return SharedContentViewDetails(sharedContentLink: sharedContentLink, sharedContentAccessLevel: sharedContentAccessLevel, sharedContentOwner: sharedContentOwner)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedContentViewType struct
    open class SharedContentViewType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentViewTypeSerializer().serialize(self)))"
        }
    }
    open class SharedContentViewTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentViewType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentViewType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedContentViewType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed who can access shared folder via link.
    open class SharedFolderChangeLinkPolicyDetails: CustomStringConvertible {
        /// New shared folder link policy.
        public let newValue: Sharing.SharedLinkPolicy
        /// Previous shared folder link policy. Might be missing due to historical data gap.
        public let previousValue: Sharing.SharedLinkPolicy?
        public init(newValue: Sharing.SharedLinkPolicy, previousValue: Sharing.SharedLinkPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedFolderChangeLinkPolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedFolderChangeLinkPolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedFolderChangeLinkPolicyDetails) -> JSON {
            let output = [ 
            "new_value": Sharing.SharedLinkPolicySerializer().serialize(value.newValue),
            "previous_value": NullableSerializer(Sharing.SharedLinkPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedFolderChangeLinkPolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = Sharing.SharedLinkPolicySerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(Sharing.SharedLinkPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                    return SharedFolderChangeLinkPolicyDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedFolderChangeLinkPolicyType struct
    open class SharedFolderChangeLinkPolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedFolderChangeLinkPolicyTypeSerializer().serialize(self)))"
        }
    }
    open class SharedFolderChangeLinkPolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedFolderChangeLinkPolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedFolderChangeLinkPolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedFolderChangeLinkPolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed whether shared folder inherits members from parent folder.
    open class SharedFolderChangeMembersInheritancePolicyDetails: CustomStringConvertible {
        /// New member inheritance policy.
        public let newValue: TeamLog.SharedFolderMembersInheritancePolicy
        /// Previous member inheritance policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.SharedFolderMembersInheritancePolicy?
        public init(newValue: TeamLog.SharedFolderMembersInheritancePolicy, previousValue: TeamLog.SharedFolderMembersInheritancePolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedFolderChangeMembersInheritancePolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedFolderChangeMembersInheritancePolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedFolderChangeMembersInheritancePolicyDetails) -> JSON {
            let output = [ 
            "new_value": TeamLog.SharedFolderMembersInheritancePolicySerializer().serialize(value.newValue),
            "previous_value": NullableSerializer(TeamLog.SharedFolderMembersInheritancePolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedFolderChangeMembersInheritancePolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = TeamLog.SharedFolderMembersInheritancePolicySerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(TeamLog.SharedFolderMembersInheritancePolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                    return SharedFolderChangeMembersInheritancePolicyDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedFolderChangeMembersInheritancePolicyType struct
    open class SharedFolderChangeMembersInheritancePolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedFolderChangeMembersInheritancePolicyTypeSerializer().serialize(self)))"
        }
    }
    open class SharedFolderChangeMembersInheritancePolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedFolderChangeMembersInheritancePolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedFolderChangeMembersInheritancePolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedFolderChangeMembersInheritancePolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed who can add/remove members of shared folder.
    open class SharedFolderChangeMembersManagementPolicyDetails: CustomStringConvertible {
        /// New members management policy.
        public let newValue: Sharing.AclUpdatePolicy
        /// Previous members management policy. Might be missing due to historical data gap.
        public let previousValue: Sharing.AclUpdatePolicy?
        public init(newValue: Sharing.AclUpdatePolicy, previousValue: Sharing.AclUpdatePolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedFolderChangeMembersManagementPolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedFolderChangeMembersManagementPolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedFolderChangeMembersManagementPolicyDetails) -> JSON {
            let output = [ 
            "new_value": Sharing.AclUpdatePolicySerializer().serialize(value.newValue),
            "previous_value": NullableSerializer(Sharing.AclUpdatePolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedFolderChangeMembersManagementPolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = Sharing.AclUpdatePolicySerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(Sharing.AclUpdatePolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                    return SharedFolderChangeMembersManagementPolicyDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedFolderChangeMembersManagementPolicyType struct
    open class SharedFolderChangeMembersManagementPolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedFolderChangeMembersManagementPolicyTypeSerializer().serialize(self)))"
        }
    }
    open class SharedFolderChangeMembersManagementPolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedFolderChangeMembersManagementPolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedFolderChangeMembersManagementPolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedFolderChangeMembersManagementPolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed who can become member of shared folder.
    open class SharedFolderChangeMembersPolicyDetails: CustomStringConvertible {
        /// New external invite policy.
        public let newValue: Sharing.MemberPolicy
        /// Previous external invite policy. Might be missing due to historical data gap.
        public let previousValue: Sharing.MemberPolicy?
        public init(newValue: Sharing.MemberPolicy, previousValue: Sharing.MemberPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedFolderChangeMembersPolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedFolderChangeMembersPolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedFolderChangeMembersPolicyDetails) -> JSON {
            let output = [ 
            "new_value": Sharing.MemberPolicySerializer().serialize(value.newValue),
            "previous_value": NullableSerializer(Sharing.MemberPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedFolderChangeMembersPolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = Sharing.MemberPolicySerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(Sharing.MemberPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                    return SharedFolderChangeMembersPolicyDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedFolderChangeMembersPolicyType struct
    open class SharedFolderChangeMembersPolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedFolderChangeMembersPolicyTypeSerializer().serialize(self)))"
        }
    }
    open class SharedFolderChangeMembersPolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedFolderChangeMembersPolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedFolderChangeMembersPolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedFolderChangeMembersPolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Created shared folder.
    open class SharedFolderCreateDetails: CustomStringConvertible {
        /// Target namespace ID. Might be missing due to historical data gap.
        public let targetNsId: String?
        public init(targetNsId: String? = nil) {
            nullableValidator(stringValidator())(targetNsId)
            self.targetNsId = targetNsId
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedFolderCreateDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedFolderCreateDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedFolderCreateDetails) -> JSON {
            let output = [ 
            "target_ns_id": NullableSerializer(Serialization._StringSerializer).serialize(value.targetNsId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedFolderCreateDetails {
            switch json {
                case .dictionary(let dict):
                    let targetNsId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["target_ns_id"] ?? .null)
                    return SharedFolderCreateDetails(targetNsId: targetNsId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedFolderCreateType struct
    open class SharedFolderCreateType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedFolderCreateTypeSerializer().serialize(self)))"
        }
    }
    open class SharedFolderCreateTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedFolderCreateType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedFolderCreateType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedFolderCreateType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Declined team member's invite to shared folder.
    open class SharedFolderDeclineInvitationDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedFolderDeclineInvitationDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedFolderDeclineInvitationDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedFolderDeclineInvitationDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedFolderDeclineInvitationDetails {
            switch json {
                case .dictionary(_):
                    return SharedFolderDeclineInvitationDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedFolderDeclineInvitationType struct
    open class SharedFolderDeclineInvitationType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedFolderDeclineInvitationTypeSerializer().serialize(self)))"
        }
    }
    open class SharedFolderDeclineInvitationTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedFolderDeclineInvitationType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedFolderDeclineInvitationType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedFolderDeclineInvitationType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Specifies if a shared folder inherits its members from the parent folder.
    public enum SharedFolderMembersInheritancePolicy: CustomStringConvertible {
        /// An unspecified error.
        case inheritMembers
        /// An unspecified error.
        case dontInheritMembers
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedFolderMembersInheritancePolicySerializer().serialize(self)))"
        }
    }
    open class SharedFolderMembersInheritancePolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedFolderMembersInheritancePolicy) -> JSON {
            switch value {
                case .inheritMembers:
                    var d = [String: JSON]()
                    d[".tag"] = .str("inherit_members")
                    return .dictionary(d)
                case .dontInheritMembers:
                    var d = [String: JSON]()
                    d[".tag"] = .str("dont_inherit_members")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SharedFolderMembersInheritancePolicy {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "inherit_members":
                            return SharedFolderMembersInheritancePolicy.inheritMembers
                        case "dont_inherit_members":
                            return SharedFolderMembersInheritancePolicy.dontInheritMembers
                        case "other":
                            return SharedFolderMembersInheritancePolicy.other
                        default:
                            return SharedFolderMembersInheritancePolicy.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Added shared folder to own Dropbox.
    open class SharedFolderMountDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedFolderMountDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedFolderMountDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedFolderMountDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedFolderMountDetails {
            switch json {
                case .dictionary(_):
                    return SharedFolderMountDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedFolderMountType struct
    open class SharedFolderMountType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedFolderMountTypeSerializer().serialize(self)))"
        }
    }
    open class SharedFolderMountTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedFolderMountType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedFolderMountType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedFolderMountType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed parent of shared folder.
    open class SharedFolderNestDetails: CustomStringConvertible {
        /// Previous parent namespace ID. Might be missing due to historical data gap.
        public let previousParentNsId: String?
        /// New parent namespace ID. Might be missing due to historical data gap.
        public let newParentNsId: String?
        /// Previous namespace path. Might be missing due to historical data gap.
        public let previousNsPath: String?
        /// New namespace path. Might be missing due to historical data gap.
        public let newNsPath: String?
        public init(previousParentNsId: String? = nil, newParentNsId: String? = nil, previousNsPath: String? = nil, newNsPath: String? = nil) {
            nullableValidator(stringValidator())(previousParentNsId)
            self.previousParentNsId = previousParentNsId
            nullableValidator(stringValidator())(newParentNsId)
            self.newParentNsId = newParentNsId
            nullableValidator(stringValidator())(previousNsPath)
            self.previousNsPath = previousNsPath
            nullableValidator(stringValidator())(newNsPath)
            self.newNsPath = newNsPath
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedFolderNestDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedFolderNestDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedFolderNestDetails) -> JSON {
            let output = [ 
            "previous_parent_ns_id": NullableSerializer(Serialization._StringSerializer).serialize(value.previousParentNsId),
            "new_parent_ns_id": NullableSerializer(Serialization._StringSerializer).serialize(value.newParentNsId),
            "previous_ns_path": NullableSerializer(Serialization._StringSerializer).serialize(value.previousNsPath),
            "new_ns_path": NullableSerializer(Serialization._StringSerializer).serialize(value.newNsPath),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedFolderNestDetails {
            switch json {
                case .dictionary(let dict):
                    let previousParentNsId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["previous_parent_ns_id"] ?? .null)
                    let newParentNsId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["new_parent_ns_id"] ?? .null)
                    let previousNsPath = NullableSerializer(Serialization._StringSerializer).deserialize(dict["previous_ns_path"] ?? .null)
                    let newNsPath = NullableSerializer(Serialization._StringSerializer).deserialize(dict["new_ns_path"] ?? .null)
                    return SharedFolderNestDetails(previousParentNsId: previousParentNsId, newParentNsId: newParentNsId, previousNsPath: previousNsPath, newNsPath: newNsPath)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedFolderNestType struct
    open class SharedFolderNestType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedFolderNestTypeSerializer().serialize(self)))"
        }
    }
    open class SharedFolderNestTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedFolderNestType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedFolderNestType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedFolderNestType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Transferred ownership of shared folder to another member.
    open class SharedFolderTransferOwnershipDetails: CustomStringConvertible {
        /// The email address of the previous shared folder owner.
        public let previousOwnerEmail: String?
        /// The email address of the new shared folder owner.
        public let newOwnerEmail: String
        public init(newOwnerEmail: String, previousOwnerEmail: String? = nil) {
            nullableValidator(stringValidator(maxLength: 255))(previousOwnerEmail)
            self.previousOwnerEmail = previousOwnerEmail
            stringValidator(maxLength: 255)(newOwnerEmail)
            self.newOwnerEmail = newOwnerEmail
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedFolderTransferOwnershipDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedFolderTransferOwnershipDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedFolderTransferOwnershipDetails) -> JSON {
            let output = [ 
            "new_owner_email": Serialization._StringSerializer.serialize(value.newOwnerEmail),
            "previous_owner_email": NullableSerializer(Serialization._StringSerializer).serialize(value.previousOwnerEmail),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedFolderTransferOwnershipDetails {
            switch json {
                case .dictionary(let dict):
                    let newOwnerEmail = Serialization._StringSerializer.deserialize(dict["new_owner_email"] ?? .null)
                    let previousOwnerEmail = NullableSerializer(Serialization._StringSerializer).deserialize(dict["previous_owner_email"] ?? .null)
                    return SharedFolderTransferOwnershipDetails(newOwnerEmail: newOwnerEmail, previousOwnerEmail: previousOwnerEmail)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedFolderTransferOwnershipType struct
    open class SharedFolderTransferOwnershipType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedFolderTransferOwnershipTypeSerializer().serialize(self)))"
        }
    }
    open class SharedFolderTransferOwnershipTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedFolderTransferOwnershipType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedFolderTransferOwnershipType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedFolderTransferOwnershipType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Deleted shared folder from Dropbox.
    open class SharedFolderUnmountDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedFolderUnmountDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedFolderUnmountDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedFolderUnmountDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedFolderUnmountDetails {
            switch json {
                case .dictionary(_):
                    return SharedFolderUnmountDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedFolderUnmountType struct
    open class SharedFolderUnmountType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedFolderUnmountTypeSerializer().serialize(self)))"
        }
    }
    open class SharedFolderUnmountTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedFolderUnmountType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedFolderUnmountType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedFolderUnmountType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Shared link access level.
    public enum SharedLinkAccessLevel: CustomStringConvertible {
        /// An unspecified error.
        case none
        /// An unspecified error.
        case reader
        /// An unspecified error.
        case writer
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedLinkAccessLevelSerializer().serialize(self)))"
        }
    }
    open class SharedLinkAccessLevelSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedLinkAccessLevel) -> JSON {
            switch value {
                case .none:
                    var d = [String: JSON]()
                    d[".tag"] = .str("none")
                    return .dictionary(d)
                case .reader:
                    var d = [String: JSON]()
                    d[".tag"] = .str("reader")
                    return .dictionary(d)
                case .writer:
                    var d = [String: JSON]()
                    d[".tag"] = .str("writer")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SharedLinkAccessLevel {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "none":
                            return SharedLinkAccessLevel.none
                        case "reader":
                            return SharedLinkAccessLevel.reader
                        case "writer":
                            return SharedLinkAccessLevel.writer
                        case "other":
                            return SharedLinkAccessLevel.other
                        default:
                            return SharedLinkAccessLevel.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Added shared link expiration date.
    open class SharedLinkAddExpiryDetails: CustomStringConvertible {
        /// New shared link expiration date.
        public let newValue: Date
        public init(newValue: Date) {
            self.newValue = newValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedLinkAddExpiryDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedLinkAddExpiryDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedLinkAddExpiryDetails) -> JSON {
            let output = [ 
            "new_value": NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.newValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedLinkAddExpiryDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["new_value"] ?? .null)
                    return SharedLinkAddExpiryDetails(newValue: newValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedLinkAddExpiryType struct
    open class SharedLinkAddExpiryType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedLinkAddExpiryTypeSerializer().serialize(self)))"
        }
    }
    open class SharedLinkAddExpiryTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedLinkAddExpiryType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedLinkAddExpiryType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedLinkAddExpiryType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed shared link expiration date.
    open class SharedLinkChangeExpiryDetails: CustomStringConvertible {
        /// New shared link expiration date. Might be missing due to historical data gap.
        public let newValue: Date?
        /// Previous shared link expiration date. Might be missing due to historical data gap.
        public let previousValue: Date?
        public init(newValue: Date? = nil, previousValue: Date? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedLinkChangeExpiryDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedLinkChangeExpiryDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedLinkChangeExpiryDetails) -> JSON {
            let output = [ 
            "new_value": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.newValue),
            "previous_value": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedLinkChangeExpiryDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["previous_value"] ?? .null)
                    return SharedLinkChangeExpiryDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedLinkChangeExpiryType struct
    open class SharedLinkChangeExpiryType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedLinkChangeExpiryTypeSerializer().serialize(self)))"
        }
    }
    open class SharedLinkChangeExpiryTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedLinkChangeExpiryType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedLinkChangeExpiryType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedLinkChangeExpiryType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed visibility of shared link.
    open class SharedLinkChangeVisibilityDetails: CustomStringConvertible {
        /// New shared link visibility.
        public let newValue: TeamLog.SharedLinkVisibility
        /// Previous shared link visibility. Might be missing due to historical data gap.
        public let previousValue: TeamLog.SharedLinkVisibility?
        public init(newValue: TeamLog.SharedLinkVisibility, previousValue: TeamLog.SharedLinkVisibility? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedLinkChangeVisibilityDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedLinkChangeVisibilityDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedLinkChangeVisibilityDetails) -> JSON {
            let output = [ 
            "new_value": TeamLog.SharedLinkVisibilitySerializer().serialize(value.newValue),
            "previous_value": NullableSerializer(TeamLog.SharedLinkVisibilitySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedLinkChangeVisibilityDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = TeamLog.SharedLinkVisibilitySerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(TeamLog.SharedLinkVisibilitySerializer()).deserialize(dict["previous_value"] ?? .null)
                    return SharedLinkChangeVisibilityDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedLinkChangeVisibilityType struct
    open class SharedLinkChangeVisibilityType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedLinkChangeVisibilityTypeSerializer().serialize(self)))"
        }
    }
    open class SharedLinkChangeVisibilityTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedLinkChangeVisibilityType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedLinkChangeVisibilityType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedLinkChangeVisibilityType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Added file/folder to Dropbox from shared link.
    open class SharedLinkCopyDetails: CustomStringConvertible {
        /// Shared link owner details. Might be missing due to historical data gap.
        public let sharedLinkOwner: TeamLog.UserLogInfo?
        public init(sharedLinkOwner: TeamLog.UserLogInfo? = nil) {
            self.sharedLinkOwner = sharedLinkOwner
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedLinkCopyDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedLinkCopyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedLinkCopyDetails) -> JSON {
            let output = [ 
            "shared_link_owner": NullableSerializer(TeamLog.UserLogInfoSerializer()).serialize(value.sharedLinkOwner),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedLinkCopyDetails {
            switch json {
                case .dictionary(let dict):
                    let sharedLinkOwner = NullableSerializer(TeamLog.UserLogInfoSerializer()).deserialize(dict["shared_link_owner"] ?? .null)
                    return SharedLinkCopyDetails(sharedLinkOwner: sharedLinkOwner)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedLinkCopyType struct
    open class SharedLinkCopyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedLinkCopyTypeSerializer().serialize(self)))"
        }
    }
    open class SharedLinkCopyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedLinkCopyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedLinkCopyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedLinkCopyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Created shared link.
    open class SharedLinkCreateDetails: CustomStringConvertible {
        /// Defines who can access the shared link. Might be missing due to historical data gap.
        public let sharedLinkAccessLevel: TeamLog.SharedLinkAccessLevel?
        public init(sharedLinkAccessLevel: TeamLog.SharedLinkAccessLevel? = nil) {
            self.sharedLinkAccessLevel = sharedLinkAccessLevel
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedLinkCreateDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedLinkCreateDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedLinkCreateDetails) -> JSON {
            let output = [ 
            "shared_link_access_level": NullableSerializer(TeamLog.SharedLinkAccessLevelSerializer()).serialize(value.sharedLinkAccessLevel),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedLinkCreateDetails {
            switch json {
                case .dictionary(let dict):
                    let sharedLinkAccessLevel = NullableSerializer(TeamLog.SharedLinkAccessLevelSerializer()).deserialize(dict["shared_link_access_level"] ?? .null)
                    return SharedLinkCreateDetails(sharedLinkAccessLevel: sharedLinkAccessLevel)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedLinkCreateType struct
    open class SharedLinkCreateType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedLinkCreateTypeSerializer().serialize(self)))"
        }
    }
    open class SharedLinkCreateTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedLinkCreateType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedLinkCreateType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedLinkCreateType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Removed shared link.
    open class SharedLinkDisableDetails: CustomStringConvertible {
        /// Shared link owner details. Might be missing due to historical data gap.
        public let sharedLinkOwner: TeamLog.UserLogInfo?
        public init(sharedLinkOwner: TeamLog.UserLogInfo? = nil) {
            self.sharedLinkOwner = sharedLinkOwner
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedLinkDisableDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedLinkDisableDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedLinkDisableDetails) -> JSON {
            let output = [ 
            "shared_link_owner": NullableSerializer(TeamLog.UserLogInfoSerializer()).serialize(value.sharedLinkOwner),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedLinkDisableDetails {
            switch json {
                case .dictionary(let dict):
                    let sharedLinkOwner = NullableSerializer(TeamLog.UserLogInfoSerializer()).deserialize(dict["shared_link_owner"] ?? .null)
                    return SharedLinkDisableDetails(sharedLinkOwner: sharedLinkOwner)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedLinkDisableType struct
    open class SharedLinkDisableType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedLinkDisableTypeSerializer().serialize(self)))"
        }
    }
    open class SharedLinkDisableTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedLinkDisableType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedLinkDisableType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedLinkDisableType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Downloaded file/folder from shared link.
    open class SharedLinkDownloadDetails: CustomStringConvertible {
        /// Shared link owner details. Might be missing due to historical data gap.
        public let sharedLinkOwner: TeamLog.UserLogInfo?
        public init(sharedLinkOwner: TeamLog.UserLogInfo? = nil) {
            self.sharedLinkOwner = sharedLinkOwner
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedLinkDownloadDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedLinkDownloadDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedLinkDownloadDetails) -> JSON {
            let output = [ 
            "shared_link_owner": NullableSerializer(TeamLog.UserLogInfoSerializer()).serialize(value.sharedLinkOwner),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedLinkDownloadDetails {
            switch json {
                case .dictionary(let dict):
                    let sharedLinkOwner = NullableSerializer(TeamLog.UserLogInfoSerializer()).deserialize(dict["shared_link_owner"] ?? .null)
                    return SharedLinkDownloadDetails(sharedLinkOwner: sharedLinkOwner)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedLinkDownloadType struct
    open class SharedLinkDownloadType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedLinkDownloadTypeSerializer().serialize(self)))"
        }
    }
    open class SharedLinkDownloadTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedLinkDownloadType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedLinkDownloadType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedLinkDownloadType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Removed shared link expiration date.
    open class SharedLinkRemoveExpiryDetails: CustomStringConvertible {
        /// Previous shared link expiration date. Might be missing due to historical data gap.
        public let previousValue: Date?
        public init(previousValue: Date? = nil) {
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedLinkRemoveExpiryDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedLinkRemoveExpiryDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedLinkRemoveExpiryDetails) -> JSON {
            let output = [ 
            "previous_value": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedLinkRemoveExpiryDetails {
            switch json {
                case .dictionary(let dict):
                    let previousValue = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["previous_value"] ?? .null)
                    return SharedLinkRemoveExpiryDetails(previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedLinkRemoveExpiryType struct
    open class SharedLinkRemoveExpiryType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedLinkRemoveExpiryTypeSerializer().serialize(self)))"
        }
    }
    open class SharedLinkRemoveExpiryTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedLinkRemoveExpiryType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedLinkRemoveExpiryType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedLinkRemoveExpiryType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Added members as audience of shared link.
    open class SharedLinkShareDetails: CustomStringConvertible {
        /// Shared link owner details. Might be missing due to historical data gap.
        public let sharedLinkOwner: TeamLog.UserLogInfo?
        /// Users without a Dropbox account that were added as shared link audience.
        public let externalUsers: Array<TeamLog.ExternalUserLogInfo>?
        public init(sharedLinkOwner: TeamLog.UserLogInfo? = nil, externalUsers: Array<TeamLog.ExternalUserLogInfo>? = nil) {
            self.sharedLinkOwner = sharedLinkOwner
            self.externalUsers = externalUsers
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedLinkShareDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedLinkShareDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedLinkShareDetails) -> JSON {
            let output = [ 
            "shared_link_owner": NullableSerializer(TeamLog.UserLogInfoSerializer()).serialize(value.sharedLinkOwner),
            "external_users": NullableSerializer(ArraySerializer(TeamLog.ExternalUserLogInfoSerializer())).serialize(value.externalUsers),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedLinkShareDetails {
            switch json {
                case .dictionary(let dict):
                    let sharedLinkOwner = NullableSerializer(TeamLog.UserLogInfoSerializer()).deserialize(dict["shared_link_owner"] ?? .null)
                    let externalUsers = NullableSerializer(ArraySerializer(TeamLog.ExternalUserLogInfoSerializer())).deserialize(dict["external_users"] ?? .null)
                    return SharedLinkShareDetails(sharedLinkOwner: sharedLinkOwner, externalUsers: externalUsers)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedLinkShareType struct
    open class SharedLinkShareType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedLinkShareTypeSerializer().serialize(self)))"
        }
    }
    open class SharedLinkShareTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedLinkShareType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedLinkShareType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedLinkShareType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Opened shared link.
    open class SharedLinkViewDetails: CustomStringConvertible {
        /// Shared link owner details. Might be missing due to historical data gap.
        public let sharedLinkOwner: TeamLog.UserLogInfo?
        public init(sharedLinkOwner: TeamLog.UserLogInfo? = nil) {
            self.sharedLinkOwner = sharedLinkOwner
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedLinkViewDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedLinkViewDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedLinkViewDetails) -> JSON {
            let output = [ 
            "shared_link_owner": NullableSerializer(TeamLog.UserLogInfoSerializer()).serialize(value.sharedLinkOwner),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedLinkViewDetails {
            switch json {
                case .dictionary(let dict):
                    let sharedLinkOwner = NullableSerializer(TeamLog.UserLogInfoSerializer()).deserialize(dict["shared_link_owner"] ?? .null)
                    return SharedLinkViewDetails(sharedLinkOwner: sharedLinkOwner)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedLinkViewType struct
    open class SharedLinkViewType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedLinkViewTypeSerializer().serialize(self)))"
        }
    }
    open class SharedLinkViewTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedLinkViewType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedLinkViewType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedLinkViewType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Defines who has access to a shared link.
    public enum SharedLinkVisibility: CustomStringConvertible {
        /// An unspecified error.
        case password
        /// An unspecified error.
        case public_
        /// An unspecified error.
        case teamOnly
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedLinkVisibilitySerializer().serialize(self)))"
        }
    }
    open class SharedLinkVisibilitySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedLinkVisibility) -> JSON {
            switch value {
                case .password:
                    var d = [String: JSON]()
                    d[".tag"] = .str("password")
                    return .dictionary(d)
                case .public_:
                    var d = [String: JSON]()
                    d[".tag"] = .str("public")
                    return .dictionary(d)
                case .teamOnly:
                    var d = [String: JSON]()
                    d[".tag"] = .str("team_only")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SharedLinkVisibility {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "password":
                            return SharedLinkVisibility.password
                        case "public":
                            return SharedLinkVisibility.public_
                        case "team_only":
                            return SharedLinkVisibility.teamOnly
                        case "other":
                            return SharedLinkVisibility.other
                        default:
                            return SharedLinkVisibility.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Opened shared Paper doc.
    open class SharedNoteOpenedDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedNoteOpenedDetailsSerializer().serialize(self)))"
        }
    }
    open class SharedNoteOpenedDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedNoteOpenedDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedNoteOpenedDetails {
            switch json {
                case .dictionary(_):
                    return SharedNoteOpenedDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedNoteOpenedType struct
    open class SharedNoteOpenedType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedNoteOpenedTypeSerializer().serialize(self)))"
        }
    }
    open class SharedNoteOpenedTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedNoteOpenedType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedNoteOpenedType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharedNoteOpenedType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed whether team members can join shared folders owned outside team.
    open class SharingChangeFolderJoinPolicyDetails: CustomStringConvertible {
        /// New external join policy.
        public let newValue: TeamLog.SharingFolderJoinPolicy
        /// Previous external join policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.SharingFolderJoinPolicy?
        public init(newValue: TeamLog.SharingFolderJoinPolicy, previousValue: TeamLog.SharingFolderJoinPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharingChangeFolderJoinPolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class SharingChangeFolderJoinPolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharingChangeFolderJoinPolicyDetails) -> JSON {
            let output = [ 
            "new_value": TeamLog.SharingFolderJoinPolicySerializer().serialize(value.newValue),
            "previous_value": NullableSerializer(TeamLog.SharingFolderJoinPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharingChangeFolderJoinPolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = TeamLog.SharingFolderJoinPolicySerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(TeamLog.SharingFolderJoinPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                    return SharingChangeFolderJoinPolicyDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharingChangeFolderJoinPolicyType struct
    open class SharingChangeFolderJoinPolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharingChangeFolderJoinPolicyTypeSerializer().serialize(self)))"
        }
    }
    open class SharingChangeFolderJoinPolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharingChangeFolderJoinPolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharingChangeFolderJoinPolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharingChangeFolderJoinPolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed whether members can share links outside team, and if links are accessible only by team members or anyone
    /// by default.
    open class SharingChangeLinkPolicyDetails: CustomStringConvertible {
        /// New external link accessibility policy.
        public let newValue: TeamLog.SharingLinkPolicy
        /// Previous external link accessibility policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.SharingLinkPolicy?
        public init(newValue: TeamLog.SharingLinkPolicy, previousValue: TeamLog.SharingLinkPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharingChangeLinkPolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class SharingChangeLinkPolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharingChangeLinkPolicyDetails) -> JSON {
            let output = [ 
            "new_value": TeamLog.SharingLinkPolicySerializer().serialize(value.newValue),
            "previous_value": NullableSerializer(TeamLog.SharingLinkPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharingChangeLinkPolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = TeamLog.SharingLinkPolicySerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(TeamLog.SharingLinkPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                    return SharingChangeLinkPolicyDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharingChangeLinkPolicyType struct
    open class SharingChangeLinkPolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharingChangeLinkPolicyTypeSerializer().serialize(self)))"
        }
    }
    open class SharingChangeLinkPolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharingChangeLinkPolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharingChangeLinkPolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharingChangeLinkPolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed whether members can share files/folders outside team.
    open class SharingChangeMemberPolicyDetails: CustomStringConvertible {
        /// New external invite policy.
        public let newValue: TeamLog.SharingMemberPolicy
        /// Previous external invite policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.SharingMemberPolicy?
        public init(newValue: TeamLog.SharingMemberPolicy, previousValue: TeamLog.SharingMemberPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharingChangeMemberPolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class SharingChangeMemberPolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharingChangeMemberPolicyDetails) -> JSON {
            let output = [ 
            "new_value": TeamLog.SharingMemberPolicySerializer().serialize(value.newValue),
            "previous_value": NullableSerializer(TeamLog.SharingMemberPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharingChangeMemberPolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = TeamLog.SharingMemberPolicySerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(TeamLog.SharingMemberPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                    return SharingChangeMemberPolicyDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharingChangeMemberPolicyType struct
    open class SharingChangeMemberPolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharingChangeMemberPolicyTypeSerializer().serialize(self)))"
        }
    }
    open class SharingChangeMemberPolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharingChangeMemberPolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharingChangeMemberPolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SharingChangeMemberPolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Policy for controlling if team members can join shared folders owned by non team members.
    public enum SharingFolderJoinPolicy: CustomStringConvertible {
        /// An unspecified error.
        case fromAnyone
        /// An unspecified error.
        case fromTeamOnly
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharingFolderJoinPolicySerializer().serialize(self)))"
        }
    }
    open class SharingFolderJoinPolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharingFolderJoinPolicy) -> JSON {
            switch value {
                case .fromAnyone:
                    var d = [String: JSON]()
                    d[".tag"] = .str("from_anyone")
                    return .dictionary(d)
                case .fromTeamOnly:
                    var d = [String: JSON]()
                    d[".tag"] = .str("from_team_only")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SharingFolderJoinPolicy {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "from_anyone":
                            return SharingFolderJoinPolicy.fromAnyone
                        case "from_team_only":
                            return SharingFolderJoinPolicy.fromTeamOnly
                        case "other":
                            return SharingFolderJoinPolicy.other
                        default:
                            return SharingFolderJoinPolicy.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Policy for controlling if team members can share links externally
    public enum SharingLinkPolicy: CustomStringConvertible {
        /// An unspecified error.
        case defaultPrivate
        /// An unspecified error.
        case defaultPublic
        /// An unspecified error.
        case onlyPrivate
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharingLinkPolicySerializer().serialize(self)))"
        }
    }
    open class SharingLinkPolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharingLinkPolicy) -> JSON {
            switch value {
                case .defaultPrivate:
                    var d = [String: JSON]()
                    d[".tag"] = .str("default_private")
                    return .dictionary(d)
                case .defaultPublic:
                    var d = [String: JSON]()
                    d[".tag"] = .str("default_public")
                    return .dictionary(d)
                case .onlyPrivate:
                    var d = [String: JSON]()
                    d[".tag"] = .str("only_private")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SharingLinkPolicy {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "default_private":
                            return SharingLinkPolicy.defaultPrivate
                        case "default_public":
                            return SharingLinkPolicy.defaultPublic
                        case "only_private":
                            return SharingLinkPolicy.onlyPrivate
                        case "other":
                            return SharingLinkPolicy.other
                        default:
                            return SharingLinkPolicy.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// External sharing policy
    public enum SharingMemberPolicy: CustomStringConvertible {
        /// An unspecified error.
        case allow
        /// An unspecified error.
        case forbid
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharingMemberPolicySerializer().serialize(self)))"
        }
    }
    open class SharingMemberPolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharingMemberPolicy) -> JSON {
            switch value {
                case .allow:
                    var d = [String: JSON]()
                    d[".tag"] = .str("allow")
                    return .dictionary(d)
                case .forbid:
                    var d = [String: JSON]()
                    d[".tag"] = .str("forbid")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SharingMemberPolicy {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "allow":
                            return SharingMemberPolicy.allow
                        case "forbid":
                            return SharingMemberPolicy.forbid
                        case "other":
                            return SharingMemberPolicy.other
                        default:
                            return SharingMemberPolicy.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Shared link with group.
    open class ShmodelGroupShareDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShmodelGroupShareDetailsSerializer().serialize(self)))"
        }
    }
    open class ShmodelGroupShareDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShmodelGroupShareDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShmodelGroupShareDetails {
            switch json {
                case .dictionary(_):
                    return ShmodelGroupShareDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ShmodelGroupShareType struct
    open class ShmodelGroupShareType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShmodelGroupShareTypeSerializer().serialize(self)))"
        }
    }
    open class ShmodelGroupShareTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShmodelGroupShareType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShmodelGroupShareType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return ShmodelGroupShareType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Granted access to showcase.
    open class ShowcaseAccessGrantedDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseAccessGrantedDetailsSerializer().serialize(self)))"
        }
    }
    open class ShowcaseAccessGrantedDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseAccessGrantedDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseAccessGrantedDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return ShowcaseAccessGrantedDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ShowcaseAccessGrantedType struct
    open class ShowcaseAccessGrantedType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseAccessGrantedTypeSerializer().serialize(self)))"
        }
    }
    open class ShowcaseAccessGrantedTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseAccessGrantedType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseAccessGrantedType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return ShowcaseAccessGrantedType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Added member to showcase.
    open class ShowcaseAddMemberDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseAddMemberDetailsSerializer().serialize(self)))"
        }
    }
    open class ShowcaseAddMemberDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseAddMemberDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseAddMemberDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return ShowcaseAddMemberDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ShowcaseAddMemberType struct
    open class ShowcaseAddMemberType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseAddMemberTypeSerializer().serialize(self)))"
        }
    }
    open class ShowcaseAddMemberTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseAddMemberType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseAddMemberType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return ShowcaseAddMemberType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Archived showcase.
    open class ShowcaseArchivedDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseArchivedDetailsSerializer().serialize(self)))"
        }
    }
    open class ShowcaseArchivedDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseArchivedDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseArchivedDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return ShowcaseArchivedDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ShowcaseArchivedType struct
    open class ShowcaseArchivedType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseArchivedTypeSerializer().serialize(self)))"
        }
    }
    open class ShowcaseArchivedTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseArchivedType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseArchivedType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return ShowcaseArchivedType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Enabled/disabled downloading files from Dropbox Showcase for team.
    open class ShowcaseChangeDownloadPolicyDetails: CustomStringConvertible {
        /// New Dropbox Showcase download policy.
        public let newValue: TeamLog.ShowcaseDownloadPolicy
        /// Previous Dropbox Showcase download policy.
        public let previousValue: TeamLog.ShowcaseDownloadPolicy
        public init(newValue: TeamLog.ShowcaseDownloadPolicy, previousValue: TeamLog.ShowcaseDownloadPolicy) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseChangeDownloadPolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class ShowcaseChangeDownloadPolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseChangeDownloadPolicyDetails) -> JSON {
            let output = [ 
            "new_value": TeamLog.ShowcaseDownloadPolicySerializer().serialize(value.newValue),
            "previous_value": TeamLog.ShowcaseDownloadPolicySerializer().serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseChangeDownloadPolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = TeamLog.ShowcaseDownloadPolicySerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = TeamLog.ShowcaseDownloadPolicySerializer().deserialize(dict["previous_value"] ?? .null)
                    return ShowcaseChangeDownloadPolicyDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ShowcaseChangeDownloadPolicyType struct
    open class ShowcaseChangeDownloadPolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseChangeDownloadPolicyTypeSerializer().serialize(self)))"
        }
    }
    open class ShowcaseChangeDownloadPolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseChangeDownloadPolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseChangeDownloadPolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return ShowcaseChangeDownloadPolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Enabled/disabled Dropbox Showcase for team.
    open class ShowcaseChangeEnabledPolicyDetails: CustomStringConvertible {
        /// New Dropbox Showcase policy.
        public let newValue: TeamLog.ShowcaseEnabledPolicy
        /// Previous Dropbox Showcase policy.
        public let previousValue: TeamLog.ShowcaseEnabledPolicy
        public init(newValue: TeamLog.ShowcaseEnabledPolicy, previousValue: TeamLog.ShowcaseEnabledPolicy) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseChangeEnabledPolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class ShowcaseChangeEnabledPolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseChangeEnabledPolicyDetails) -> JSON {
            let output = [ 
            "new_value": TeamLog.ShowcaseEnabledPolicySerializer().serialize(value.newValue),
            "previous_value": TeamLog.ShowcaseEnabledPolicySerializer().serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseChangeEnabledPolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = TeamLog.ShowcaseEnabledPolicySerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = TeamLog.ShowcaseEnabledPolicySerializer().deserialize(dict["previous_value"] ?? .null)
                    return ShowcaseChangeEnabledPolicyDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ShowcaseChangeEnabledPolicyType struct
    open class ShowcaseChangeEnabledPolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseChangeEnabledPolicyTypeSerializer().serialize(self)))"
        }
    }
    open class ShowcaseChangeEnabledPolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseChangeEnabledPolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseChangeEnabledPolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return ShowcaseChangeEnabledPolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Enabled/disabled sharing Dropbox Showcase externally for team.
    open class ShowcaseChangeExternalSharingPolicyDetails: CustomStringConvertible {
        /// New Dropbox Showcase external sharing policy.
        public let newValue: TeamLog.ShowcaseExternalSharingPolicy
        /// Previous Dropbox Showcase external sharing policy.
        public let previousValue: TeamLog.ShowcaseExternalSharingPolicy
        public init(newValue: TeamLog.ShowcaseExternalSharingPolicy, previousValue: TeamLog.ShowcaseExternalSharingPolicy) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseChangeExternalSharingPolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class ShowcaseChangeExternalSharingPolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseChangeExternalSharingPolicyDetails) -> JSON {
            let output = [ 
            "new_value": TeamLog.ShowcaseExternalSharingPolicySerializer().serialize(value.newValue),
            "previous_value": TeamLog.ShowcaseExternalSharingPolicySerializer().serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseChangeExternalSharingPolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = TeamLog.ShowcaseExternalSharingPolicySerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = TeamLog.ShowcaseExternalSharingPolicySerializer().deserialize(dict["previous_value"] ?? .null)
                    return ShowcaseChangeExternalSharingPolicyDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ShowcaseChangeExternalSharingPolicyType struct
    open class ShowcaseChangeExternalSharingPolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseChangeExternalSharingPolicyTypeSerializer().serialize(self)))"
        }
    }
    open class ShowcaseChangeExternalSharingPolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseChangeExternalSharingPolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseChangeExternalSharingPolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return ShowcaseChangeExternalSharingPolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Created showcase.
    open class ShowcaseCreatedDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseCreatedDetailsSerializer().serialize(self)))"
        }
    }
    open class ShowcaseCreatedDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseCreatedDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseCreatedDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return ShowcaseCreatedDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ShowcaseCreatedType struct
    open class ShowcaseCreatedType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseCreatedTypeSerializer().serialize(self)))"
        }
    }
    open class ShowcaseCreatedTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseCreatedType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseCreatedType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return ShowcaseCreatedType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Deleted showcase comment.
    open class ShowcaseDeleteCommentDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        /// Comment text.
        public let commentText: String?
        public init(eventUuid: String, commentText: String? = nil) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            nullableValidator(stringValidator())(commentText)
            self.commentText = commentText
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseDeleteCommentDetailsSerializer().serialize(self)))"
        }
    }
    open class ShowcaseDeleteCommentDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseDeleteCommentDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            "comment_text": NullableSerializer(Serialization._StringSerializer).serialize(value.commentText),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseDeleteCommentDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    let commentText = NullableSerializer(Serialization._StringSerializer).deserialize(dict["comment_text"] ?? .null)
                    return ShowcaseDeleteCommentDetails(eventUuid: eventUuid, commentText: commentText)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ShowcaseDeleteCommentType struct
    open class ShowcaseDeleteCommentType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseDeleteCommentTypeSerializer().serialize(self)))"
        }
    }
    open class ShowcaseDeleteCommentTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseDeleteCommentType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseDeleteCommentType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return ShowcaseDeleteCommentType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Showcase document's logged information.
    open class ShowcaseDocumentLogInfo: CustomStringConvertible {
        /// Showcase document Id.
        public let showcaseId: String
        /// Showcase document title.
        public let showcaseTitle: String
        public init(showcaseId: String, showcaseTitle: String) {
            stringValidator()(showcaseId)
            self.showcaseId = showcaseId
            stringValidator()(showcaseTitle)
            self.showcaseTitle = showcaseTitle
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseDocumentLogInfoSerializer().serialize(self)))"
        }
    }
    open class ShowcaseDocumentLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseDocumentLogInfo) -> JSON {
            let output = [ 
            "showcase_id": Serialization._StringSerializer.serialize(value.showcaseId),
            "showcase_title": Serialization._StringSerializer.serialize(value.showcaseTitle),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseDocumentLogInfo {
            switch json {
                case .dictionary(let dict):
                    let showcaseId = Serialization._StringSerializer.deserialize(dict["showcase_id"] ?? .null)
                    let showcaseTitle = Serialization._StringSerializer.deserialize(dict["showcase_title"] ?? .null)
                    return ShowcaseDocumentLogInfo(showcaseId: showcaseId, showcaseTitle: showcaseTitle)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Policy for controlling if files can be downloaded from Showcases by team members
    public enum ShowcaseDownloadPolicy: CustomStringConvertible {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseDownloadPolicySerializer().serialize(self)))"
        }
    }
    open class ShowcaseDownloadPolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseDownloadPolicy) -> JSON {
            switch value {
                case .disabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disabled")
                    return .dictionary(d)
                case .enabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("enabled")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ShowcaseDownloadPolicy {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "disabled":
                            return ShowcaseDownloadPolicy.disabled
                        case "enabled":
                            return ShowcaseDownloadPolicy.enabled
                        case "other":
                            return ShowcaseDownloadPolicy.other
                        default:
                            return ShowcaseDownloadPolicy.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Edited showcase comment.
    open class ShowcaseEditCommentDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        /// Comment text.
        public let commentText: String?
        public init(eventUuid: String, commentText: String? = nil) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            nullableValidator(stringValidator())(commentText)
            self.commentText = commentText
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseEditCommentDetailsSerializer().serialize(self)))"
        }
    }
    open class ShowcaseEditCommentDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseEditCommentDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            "comment_text": NullableSerializer(Serialization._StringSerializer).serialize(value.commentText),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseEditCommentDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    let commentText = NullableSerializer(Serialization._StringSerializer).deserialize(dict["comment_text"] ?? .null)
                    return ShowcaseEditCommentDetails(eventUuid: eventUuid, commentText: commentText)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ShowcaseEditCommentType struct
    open class ShowcaseEditCommentType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseEditCommentTypeSerializer().serialize(self)))"
        }
    }
    open class ShowcaseEditCommentTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseEditCommentType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseEditCommentType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return ShowcaseEditCommentType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Edited showcase.
    open class ShowcaseEditedDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseEditedDetailsSerializer().serialize(self)))"
        }
    }
    open class ShowcaseEditedDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseEditedDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseEditedDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return ShowcaseEditedDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ShowcaseEditedType struct
    open class ShowcaseEditedType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseEditedTypeSerializer().serialize(self)))"
        }
    }
    open class ShowcaseEditedTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseEditedType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseEditedType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return ShowcaseEditedType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Policy for controlling whether Showcase is enabled.
    public enum ShowcaseEnabledPolicy: CustomStringConvertible {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseEnabledPolicySerializer().serialize(self)))"
        }
    }
    open class ShowcaseEnabledPolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseEnabledPolicy) -> JSON {
            switch value {
                case .disabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disabled")
                    return .dictionary(d)
                case .enabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("enabled")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ShowcaseEnabledPolicy {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "disabled":
                            return ShowcaseEnabledPolicy.disabled
                        case "enabled":
                            return ShowcaseEnabledPolicy.enabled
                        case "other":
                            return ShowcaseEnabledPolicy.other
                        default:
                            return ShowcaseEnabledPolicy.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Policy for controlling if team members can share Showcases externally.
    public enum ShowcaseExternalSharingPolicy: CustomStringConvertible {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseExternalSharingPolicySerializer().serialize(self)))"
        }
    }
    open class ShowcaseExternalSharingPolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseExternalSharingPolicy) -> JSON {
            switch value {
                case .disabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disabled")
                    return .dictionary(d)
                case .enabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("enabled")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ShowcaseExternalSharingPolicy {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "disabled":
                            return ShowcaseExternalSharingPolicy.disabled
                        case "enabled":
                            return ShowcaseExternalSharingPolicy.enabled
                        case "other":
                            return ShowcaseExternalSharingPolicy.other
                        default:
                            return ShowcaseExternalSharingPolicy.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Added file to showcase.
    open class ShowcaseFileAddedDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseFileAddedDetailsSerializer().serialize(self)))"
        }
    }
    open class ShowcaseFileAddedDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseFileAddedDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseFileAddedDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return ShowcaseFileAddedDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ShowcaseFileAddedType struct
    open class ShowcaseFileAddedType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseFileAddedTypeSerializer().serialize(self)))"
        }
    }
    open class ShowcaseFileAddedTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseFileAddedType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseFileAddedType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return ShowcaseFileAddedType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Downloaded file from showcase.
    open class ShowcaseFileDownloadDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        /// Showcase download type.
        public let downloadType: String
        public init(eventUuid: String, downloadType: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            stringValidator()(downloadType)
            self.downloadType = downloadType
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseFileDownloadDetailsSerializer().serialize(self)))"
        }
    }
    open class ShowcaseFileDownloadDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseFileDownloadDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            "download_type": Serialization._StringSerializer.serialize(value.downloadType),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseFileDownloadDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    let downloadType = Serialization._StringSerializer.deserialize(dict["download_type"] ?? .null)
                    return ShowcaseFileDownloadDetails(eventUuid: eventUuid, downloadType: downloadType)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ShowcaseFileDownloadType struct
    open class ShowcaseFileDownloadType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseFileDownloadTypeSerializer().serialize(self)))"
        }
    }
    open class ShowcaseFileDownloadTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseFileDownloadType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseFileDownloadType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return ShowcaseFileDownloadType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Removed file from showcase.
    open class ShowcaseFileRemovedDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseFileRemovedDetailsSerializer().serialize(self)))"
        }
    }
    open class ShowcaseFileRemovedDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseFileRemovedDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseFileRemovedDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return ShowcaseFileRemovedDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ShowcaseFileRemovedType struct
    open class ShowcaseFileRemovedType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseFileRemovedTypeSerializer().serialize(self)))"
        }
    }
    open class ShowcaseFileRemovedTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseFileRemovedType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseFileRemovedType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return ShowcaseFileRemovedType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Viewed file in showcase.
    open class ShowcaseFileViewDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseFileViewDetailsSerializer().serialize(self)))"
        }
    }
    open class ShowcaseFileViewDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseFileViewDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseFileViewDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return ShowcaseFileViewDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ShowcaseFileViewType struct
    open class ShowcaseFileViewType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseFileViewTypeSerializer().serialize(self)))"
        }
    }
    open class ShowcaseFileViewTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseFileViewType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseFileViewType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return ShowcaseFileViewType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Permanently deleted showcase.
    open class ShowcasePermanentlyDeletedDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcasePermanentlyDeletedDetailsSerializer().serialize(self)))"
        }
    }
    open class ShowcasePermanentlyDeletedDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcasePermanentlyDeletedDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcasePermanentlyDeletedDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return ShowcasePermanentlyDeletedDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ShowcasePermanentlyDeletedType struct
    open class ShowcasePermanentlyDeletedType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcasePermanentlyDeletedTypeSerializer().serialize(self)))"
        }
    }
    open class ShowcasePermanentlyDeletedTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcasePermanentlyDeletedType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcasePermanentlyDeletedType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return ShowcasePermanentlyDeletedType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Added showcase comment.
    open class ShowcasePostCommentDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        /// Comment text.
        public let commentText: String?
        public init(eventUuid: String, commentText: String? = nil) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            nullableValidator(stringValidator())(commentText)
            self.commentText = commentText
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcasePostCommentDetailsSerializer().serialize(self)))"
        }
    }
    open class ShowcasePostCommentDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcasePostCommentDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            "comment_text": NullableSerializer(Serialization._StringSerializer).serialize(value.commentText),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcasePostCommentDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    let commentText = NullableSerializer(Serialization._StringSerializer).deserialize(dict["comment_text"] ?? .null)
                    return ShowcasePostCommentDetails(eventUuid: eventUuid, commentText: commentText)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ShowcasePostCommentType struct
    open class ShowcasePostCommentType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcasePostCommentTypeSerializer().serialize(self)))"
        }
    }
    open class ShowcasePostCommentTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcasePostCommentType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcasePostCommentType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return ShowcasePostCommentType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Removed member from showcase.
    open class ShowcaseRemoveMemberDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseRemoveMemberDetailsSerializer().serialize(self)))"
        }
    }
    open class ShowcaseRemoveMemberDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseRemoveMemberDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseRemoveMemberDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return ShowcaseRemoveMemberDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ShowcaseRemoveMemberType struct
    open class ShowcaseRemoveMemberType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseRemoveMemberTypeSerializer().serialize(self)))"
        }
    }
    open class ShowcaseRemoveMemberTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseRemoveMemberType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseRemoveMemberType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return ShowcaseRemoveMemberType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Renamed showcase.
    open class ShowcaseRenamedDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseRenamedDetailsSerializer().serialize(self)))"
        }
    }
    open class ShowcaseRenamedDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseRenamedDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseRenamedDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return ShowcaseRenamedDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ShowcaseRenamedType struct
    open class ShowcaseRenamedType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseRenamedTypeSerializer().serialize(self)))"
        }
    }
    open class ShowcaseRenamedTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseRenamedType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseRenamedType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return ShowcaseRenamedType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Requested access to showcase.
    open class ShowcaseRequestAccessDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseRequestAccessDetailsSerializer().serialize(self)))"
        }
    }
    open class ShowcaseRequestAccessDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseRequestAccessDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseRequestAccessDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return ShowcaseRequestAccessDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ShowcaseRequestAccessType struct
    open class ShowcaseRequestAccessType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseRequestAccessTypeSerializer().serialize(self)))"
        }
    }
    open class ShowcaseRequestAccessTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseRequestAccessType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseRequestAccessType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return ShowcaseRequestAccessType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Resolved showcase comment.
    open class ShowcaseResolveCommentDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        /// Comment text.
        public let commentText: String?
        public init(eventUuid: String, commentText: String? = nil) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            nullableValidator(stringValidator())(commentText)
            self.commentText = commentText
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseResolveCommentDetailsSerializer().serialize(self)))"
        }
    }
    open class ShowcaseResolveCommentDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseResolveCommentDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            "comment_text": NullableSerializer(Serialization._StringSerializer).serialize(value.commentText),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseResolveCommentDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    let commentText = NullableSerializer(Serialization._StringSerializer).deserialize(dict["comment_text"] ?? .null)
                    return ShowcaseResolveCommentDetails(eventUuid: eventUuid, commentText: commentText)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ShowcaseResolveCommentType struct
    open class ShowcaseResolveCommentType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseResolveCommentTypeSerializer().serialize(self)))"
        }
    }
    open class ShowcaseResolveCommentTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseResolveCommentType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseResolveCommentType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return ShowcaseResolveCommentType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Unarchived showcase.
    open class ShowcaseRestoredDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseRestoredDetailsSerializer().serialize(self)))"
        }
    }
    open class ShowcaseRestoredDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseRestoredDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseRestoredDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return ShowcaseRestoredDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ShowcaseRestoredType struct
    open class ShowcaseRestoredType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseRestoredTypeSerializer().serialize(self)))"
        }
    }
    open class ShowcaseRestoredTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseRestoredType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseRestoredType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return ShowcaseRestoredType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Deleted showcase (old version).
    open class ShowcaseTrashedDeprecatedDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseTrashedDeprecatedDetailsSerializer().serialize(self)))"
        }
    }
    open class ShowcaseTrashedDeprecatedDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseTrashedDeprecatedDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseTrashedDeprecatedDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return ShowcaseTrashedDeprecatedDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ShowcaseTrashedDeprecatedType struct
    open class ShowcaseTrashedDeprecatedType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseTrashedDeprecatedTypeSerializer().serialize(self)))"
        }
    }
    open class ShowcaseTrashedDeprecatedTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseTrashedDeprecatedType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseTrashedDeprecatedType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return ShowcaseTrashedDeprecatedType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Deleted showcase.
    open class ShowcaseTrashedDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseTrashedDetailsSerializer().serialize(self)))"
        }
    }
    open class ShowcaseTrashedDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseTrashedDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseTrashedDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return ShowcaseTrashedDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ShowcaseTrashedType struct
    open class ShowcaseTrashedType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseTrashedTypeSerializer().serialize(self)))"
        }
    }
    open class ShowcaseTrashedTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseTrashedType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseTrashedType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return ShowcaseTrashedType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Unresolved showcase comment.
    open class ShowcaseUnresolveCommentDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        /// Comment text.
        public let commentText: String?
        public init(eventUuid: String, commentText: String? = nil) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            nullableValidator(stringValidator())(commentText)
            self.commentText = commentText
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseUnresolveCommentDetailsSerializer().serialize(self)))"
        }
    }
    open class ShowcaseUnresolveCommentDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseUnresolveCommentDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            "comment_text": NullableSerializer(Serialization._StringSerializer).serialize(value.commentText),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseUnresolveCommentDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    let commentText = NullableSerializer(Serialization._StringSerializer).deserialize(dict["comment_text"] ?? .null)
                    return ShowcaseUnresolveCommentDetails(eventUuid: eventUuid, commentText: commentText)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ShowcaseUnresolveCommentType struct
    open class ShowcaseUnresolveCommentType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseUnresolveCommentTypeSerializer().serialize(self)))"
        }
    }
    open class ShowcaseUnresolveCommentTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseUnresolveCommentType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseUnresolveCommentType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return ShowcaseUnresolveCommentType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Restored showcase (old version).
    open class ShowcaseUntrashedDeprecatedDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseUntrashedDeprecatedDetailsSerializer().serialize(self)))"
        }
    }
    open class ShowcaseUntrashedDeprecatedDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseUntrashedDeprecatedDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseUntrashedDeprecatedDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return ShowcaseUntrashedDeprecatedDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ShowcaseUntrashedDeprecatedType struct
    open class ShowcaseUntrashedDeprecatedType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseUntrashedDeprecatedTypeSerializer().serialize(self)))"
        }
    }
    open class ShowcaseUntrashedDeprecatedTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseUntrashedDeprecatedType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseUntrashedDeprecatedType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return ShowcaseUntrashedDeprecatedType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Restored showcase.
    open class ShowcaseUntrashedDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseUntrashedDetailsSerializer().serialize(self)))"
        }
    }
    open class ShowcaseUntrashedDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseUntrashedDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseUntrashedDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return ShowcaseUntrashedDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ShowcaseUntrashedType struct
    open class ShowcaseUntrashedType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseUntrashedTypeSerializer().serialize(self)))"
        }
    }
    open class ShowcaseUntrashedTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseUntrashedType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseUntrashedType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return ShowcaseUntrashedType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Viewed showcase.
    open class ShowcaseViewDetails: CustomStringConvertible {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseViewDetailsSerializer().serialize(self)))"
        }
    }
    open class ShowcaseViewDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseViewDetails) -> JSON {
            let output = [ 
            "event_uuid": Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseViewDetails {
            switch json {
                case .dictionary(let dict):
                    let eventUuid = Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                    return ShowcaseViewDetails(eventUuid: eventUuid)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ShowcaseViewType struct
    open class ShowcaseViewType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShowcaseViewTypeSerializer().serialize(self)))"
        }
    }
    open class ShowcaseViewTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShowcaseViewType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShowcaseViewType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return ShowcaseViewType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Ended admin sign-in-as session.
    open class SignInAsSessionEndDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SignInAsSessionEndDetailsSerializer().serialize(self)))"
        }
    }
    open class SignInAsSessionEndDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SignInAsSessionEndDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SignInAsSessionEndDetails {
            switch json {
                case .dictionary(_):
                    return SignInAsSessionEndDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SignInAsSessionEndType struct
    open class SignInAsSessionEndType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SignInAsSessionEndTypeSerializer().serialize(self)))"
        }
    }
    open class SignInAsSessionEndTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SignInAsSessionEndType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SignInAsSessionEndType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SignInAsSessionEndType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Started admin sign-in-as session.
    open class SignInAsSessionStartDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SignInAsSessionStartDetailsSerializer().serialize(self)))"
        }
    }
    open class SignInAsSessionStartDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SignInAsSessionStartDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SignInAsSessionStartDetails {
            switch json {
                case .dictionary(_):
                    return SignInAsSessionStartDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SignInAsSessionStartType struct
    open class SignInAsSessionStartType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SignInAsSessionStartTypeSerializer().serialize(self)))"
        }
    }
    open class SignInAsSessionStartTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SignInAsSessionStartType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SignInAsSessionStartType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SignInAsSessionStartType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed default Smart Sync setting for team members.
    open class SmartSyncChangePolicyDetails: CustomStringConvertible {
        /// New smart sync policy.
        public let newValue: TeamPolicies.SmartSyncPolicy?
        /// Previous smart sync policy.
        public let previousValue: TeamPolicies.SmartSyncPolicy?
        public init(newValue: TeamPolicies.SmartSyncPolicy? = nil, previousValue: TeamPolicies.SmartSyncPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SmartSyncChangePolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class SmartSyncChangePolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SmartSyncChangePolicyDetails) -> JSON {
            let output = [ 
            "new_value": NullableSerializer(TeamPolicies.SmartSyncPolicySerializer()).serialize(value.newValue),
            "previous_value": NullableSerializer(TeamPolicies.SmartSyncPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SmartSyncChangePolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = NullableSerializer(TeamPolicies.SmartSyncPolicySerializer()).deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(TeamPolicies.SmartSyncPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                    return SmartSyncChangePolicyDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SmartSyncChangePolicyType struct
    open class SmartSyncChangePolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SmartSyncChangePolicyTypeSerializer().serialize(self)))"
        }
    }
    open class SmartSyncChangePolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SmartSyncChangePolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SmartSyncChangePolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SmartSyncChangePolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Created Smart Sync non-admin devices report.
    open class SmartSyncCreateAdminPrivilegeReportDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SmartSyncCreateAdminPrivilegeReportDetailsSerializer().serialize(self)))"
        }
    }
    open class SmartSyncCreateAdminPrivilegeReportDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SmartSyncCreateAdminPrivilegeReportDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SmartSyncCreateAdminPrivilegeReportDetails {
            switch json {
                case .dictionary(_):
                    return SmartSyncCreateAdminPrivilegeReportDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SmartSyncCreateAdminPrivilegeReportType struct
    open class SmartSyncCreateAdminPrivilegeReportType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SmartSyncCreateAdminPrivilegeReportTypeSerializer().serialize(self)))"
        }
    }
    open class SmartSyncCreateAdminPrivilegeReportTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SmartSyncCreateAdminPrivilegeReportType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SmartSyncCreateAdminPrivilegeReportType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SmartSyncCreateAdminPrivilegeReportType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Opted team into Smart Sync.
    open class SmartSyncNotOptOutDetails: CustomStringConvertible {
        /// Previous Smart Sync opt out policy.
        public let previousValue: TeamLog.SmartSyncOptOutPolicy
        /// New Smart Sync opt out policy.
        public let newValue: TeamLog.SmartSyncOptOutPolicy
        public init(previousValue: TeamLog.SmartSyncOptOutPolicy, newValue: TeamLog.SmartSyncOptOutPolicy) {
            self.previousValue = previousValue
            self.newValue = newValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SmartSyncNotOptOutDetailsSerializer().serialize(self)))"
        }
    }
    open class SmartSyncNotOptOutDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SmartSyncNotOptOutDetails) -> JSON {
            let output = [ 
            "previous_value": TeamLog.SmartSyncOptOutPolicySerializer().serialize(value.previousValue),
            "new_value": TeamLog.SmartSyncOptOutPolicySerializer().serialize(value.newValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SmartSyncNotOptOutDetails {
            switch json {
                case .dictionary(let dict):
                    let previousValue = TeamLog.SmartSyncOptOutPolicySerializer().deserialize(dict["previous_value"] ?? .null)
                    let newValue = TeamLog.SmartSyncOptOutPolicySerializer().deserialize(dict["new_value"] ?? .null)
                    return SmartSyncNotOptOutDetails(previousValue: previousValue, newValue: newValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SmartSyncNotOptOutType struct
    open class SmartSyncNotOptOutType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SmartSyncNotOptOutTypeSerializer().serialize(self)))"
        }
    }
    open class SmartSyncNotOptOutTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SmartSyncNotOptOutType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SmartSyncNotOptOutType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SmartSyncNotOptOutType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Opted team out of Smart Sync.
    open class SmartSyncOptOutDetails: CustomStringConvertible {
        /// Previous Smart Sync opt out policy.
        public let previousValue: TeamLog.SmartSyncOptOutPolicy
        /// New Smart Sync opt out policy.
        public let newValue: TeamLog.SmartSyncOptOutPolicy
        public init(previousValue: TeamLog.SmartSyncOptOutPolicy, newValue: TeamLog.SmartSyncOptOutPolicy) {
            self.previousValue = previousValue
            self.newValue = newValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SmartSyncOptOutDetailsSerializer().serialize(self)))"
        }
    }
    open class SmartSyncOptOutDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SmartSyncOptOutDetails) -> JSON {
            let output = [ 
            "previous_value": TeamLog.SmartSyncOptOutPolicySerializer().serialize(value.previousValue),
            "new_value": TeamLog.SmartSyncOptOutPolicySerializer().serialize(value.newValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SmartSyncOptOutDetails {
            switch json {
                case .dictionary(let dict):
                    let previousValue = TeamLog.SmartSyncOptOutPolicySerializer().deserialize(dict["previous_value"] ?? .null)
                    let newValue = TeamLog.SmartSyncOptOutPolicySerializer().deserialize(dict["new_value"] ?? .null)
                    return SmartSyncOptOutDetails(previousValue: previousValue, newValue: newValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SmartSyncOptOutPolicy union
    public enum SmartSyncOptOutPolicy: CustomStringConvertible {
        /// An unspecified error.
        case default_
        /// An unspecified error.
        case optedOut
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SmartSyncOptOutPolicySerializer().serialize(self)))"
        }
    }
    open class SmartSyncOptOutPolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SmartSyncOptOutPolicy) -> JSON {
            switch value {
                case .default_:
                    var d = [String: JSON]()
                    d[".tag"] = .str("default")
                    return .dictionary(d)
                case .optedOut:
                    var d = [String: JSON]()
                    d[".tag"] = .str("opted_out")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SmartSyncOptOutPolicy {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "default":
                            return SmartSyncOptOutPolicy.default_
                        case "opted_out":
                            return SmartSyncOptOutPolicy.optedOut
                        case "other":
                            return SmartSyncOptOutPolicy.other
                        default:
                            return SmartSyncOptOutPolicy.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The SmartSyncOptOutType struct
    open class SmartSyncOptOutType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SmartSyncOptOutTypeSerializer().serialize(self)))"
        }
    }
    open class SmartSyncOptOutTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SmartSyncOptOutType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SmartSyncOptOutType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SmartSyncOptOutType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Space limit alert policy
    public enum SpaceCapsType: CustomStringConvertible {
        /// An unspecified error.
        case hard
        /// An unspecified error.
        case off
        /// An unspecified error.
        case soft
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SpaceCapsTypeSerializer().serialize(self)))"
        }
    }
    open class SpaceCapsTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SpaceCapsType) -> JSON {
            switch value {
                case .hard:
                    var d = [String: JSON]()
                    d[".tag"] = .str("hard")
                    return .dictionary(d)
                case .off:
                    var d = [String: JSON]()
                    d[".tag"] = .str("off")
                    return .dictionary(d)
                case .soft:
                    var d = [String: JSON]()
                    d[".tag"] = .str("soft")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SpaceCapsType {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "hard":
                            return SpaceCapsType.hard
                        case "off":
                            return SpaceCapsType.off
                        case "soft":
                            return SpaceCapsType.soft
                        case "other":
                            return SpaceCapsType.other
                        default:
                            return SpaceCapsType.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The SpaceLimitsStatus union
    public enum SpaceLimitsStatus: CustomStringConvertible {
        /// An unspecified error.
        case withinQuota
        /// An unspecified error.
        case nearQuota
        /// An unspecified error.
        case overQuota
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SpaceLimitsStatusSerializer().serialize(self)))"
        }
    }
    open class SpaceLimitsStatusSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SpaceLimitsStatus) -> JSON {
            switch value {
                case .withinQuota:
                    var d = [String: JSON]()
                    d[".tag"] = .str("within_quota")
                    return .dictionary(d)
                case .nearQuota:
                    var d = [String: JSON]()
                    d[".tag"] = .str("near_quota")
                    return .dictionary(d)
                case .overQuota:
                    var d = [String: JSON]()
                    d[".tag"] = .str("over_quota")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SpaceLimitsStatus {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "within_quota":
                            return SpaceLimitsStatus.withinQuota
                        case "near_quota":
                            return SpaceLimitsStatus.nearQuota
                        case "over_quota":
                            return SpaceLimitsStatus.overQuota
                        case "other":
                            return SpaceLimitsStatus.other
                        default:
                            return SpaceLimitsStatus.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Added X.509 certificate for SSO.
    open class SsoAddCertDetails: CustomStringConvertible {
        /// SSO certificate details.
        public let certificateDetails: TeamLog.Certificate
        public init(certificateDetails: TeamLog.Certificate) {
            self.certificateDetails = certificateDetails
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SsoAddCertDetailsSerializer().serialize(self)))"
        }
    }
    open class SsoAddCertDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SsoAddCertDetails) -> JSON {
            let output = [ 
            "certificate_details": TeamLog.CertificateSerializer().serialize(value.certificateDetails),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SsoAddCertDetails {
            switch json {
                case .dictionary(let dict):
                    let certificateDetails = TeamLog.CertificateSerializer().deserialize(dict["certificate_details"] ?? .null)
                    return SsoAddCertDetails(certificateDetails: certificateDetails)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SsoAddCertType struct
    open class SsoAddCertType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SsoAddCertTypeSerializer().serialize(self)))"
        }
    }
    open class SsoAddCertTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SsoAddCertType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SsoAddCertType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SsoAddCertType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Added sign-in URL for SSO.
    open class SsoAddLoginUrlDetails: CustomStringConvertible {
        /// New single sign-on login URL.
        public let newValue: String
        public init(newValue: String) {
            stringValidator()(newValue)
            self.newValue = newValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SsoAddLoginUrlDetailsSerializer().serialize(self)))"
        }
    }
    open class SsoAddLoginUrlDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SsoAddLoginUrlDetails) -> JSON {
            let output = [ 
            "new_value": Serialization._StringSerializer.serialize(value.newValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SsoAddLoginUrlDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = Serialization._StringSerializer.deserialize(dict["new_value"] ?? .null)
                    return SsoAddLoginUrlDetails(newValue: newValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SsoAddLoginUrlType struct
    open class SsoAddLoginUrlType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SsoAddLoginUrlTypeSerializer().serialize(self)))"
        }
    }
    open class SsoAddLoginUrlTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SsoAddLoginUrlType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SsoAddLoginUrlType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SsoAddLoginUrlType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Added sign-out URL for SSO.
    open class SsoAddLogoutUrlDetails: CustomStringConvertible {
        /// New single sign-on logout URL. Might be missing due to historical data gap.
        public let newValue: String?
        public init(newValue: String? = nil) {
            nullableValidator(stringValidator())(newValue)
            self.newValue = newValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SsoAddLogoutUrlDetailsSerializer().serialize(self)))"
        }
    }
    open class SsoAddLogoutUrlDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SsoAddLogoutUrlDetails) -> JSON {
            let output = [ 
            "new_value": NullableSerializer(Serialization._StringSerializer).serialize(value.newValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SsoAddLogoutUrlDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = NullableSerializer(Serialization._StringSerializer).deserialize(dict["new_value"] ?? .null)
                    return SsoAddLogoutUrlDetails(newValue: newValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SsoAddLogoutUrlType struct
    open class SsoAddLogoutUrlType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SsoAddLogoutUrlTypeSerializer().serialize(self)))"
        }
    }
    open class SsoAddLogoutUrlTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SsoAddLogoutUrlType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SsoAddLogoutUrlType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SsoAddLogoutUrlType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed X.509 certificate for SSO.
    open class SsoChangeCertDetails: CustomStringConvertible {
        /// Previous SSO certificate details. Might be missing due to historical data gap.
        public let previousCertificateDetails: TeamLog.Certificate?
        /// New SSO certificate details.
        public let newCertificateDetails: TeamLog.Certificate
        public init(newCertificateDetails: TeamLog.Certificate, previousCertificateDetails: TeamLog.Certificate? = nil) {
            self.previousCertificateDetails = previousCertificateDetails
            self.newCertificateDetails = newCertificateDetails
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SsoChangeCertDetailsSerializer().serialize(self)))"
        }
    }
    open class SsoChangeCertDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SsoChangeCertDetails) -> JSON {
            let output = [ 
            "new_certificate_details": TeamLog.CertificateSerializer().serialize(value.newCertificateDetails),
            "previous_certificate_details": NullableSerializer(TeamLog.CertificateSerializer()).serialize(value.previousCertificateDetails),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SsoChangeCertDetails {
            switch json {
                case .dictionary(let dict):
                    let newCertificateDetails = TeamLog.CertificateSerializer().deserialize(dict["new_certificate_details"] ?? .null)
                    let previousCertificateDetails = NullableSerializer(TeamLog.CertificateSerializer()).deserialize(dict["previous_certificate_details"] ?? .null)
                    return SsoChangeCertDetails(newCertificateDetails: newCertificateDetails, previousCertificateDetails: previousCertificateDetails)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SsoChangeCertType struct
    open class SsoChangeCertType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SsoChangeCertTypeSerializer().serialize(self)))"
        }
    }
    open class SsoChangeCertTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SsoChangeCertType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SsoChangeCertType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SsoChangeCertType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed sign-in URL for SSO.
    open class SsoChangeLoginUrlDetails: CustomStringConvertible {
        /// Previous single sign-on login URL.
        public let previousValue: String
        /// New single sign-on login URL.
        public let newValue: String
        public init(previousValue: String, newValue: String) {
            stringValidator()(previousValue)
            self.previousValue = previousValue
            stringValidator()(newValue)
            self.newValue = newValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SsoChangeLoginUrlDetailsSerializer().serialize(self)))"
        }
    }
    open class SsoChangeLoginUrlDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SsoChangeLoginUrlDetails) -> JSON {
            let output = [ 
            "previous_value": Serialization._StringSerializer.serialize(value.previousValue),
            "new_value": Serialization._StringSerializer.serialize(value.newValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SsoChangeLoginUrlDetails {
            switch json {
                case .dictionary(let dict):
                    let previousValue = Serialization._StringSerializer.deserialize(dict["previous_value"] ?? .null)
                    let newValue = Serialization._StringSerializer.deserialize(dict["new_value"] ?? .null)
                    return SsoChangeLoginUrlDetails(previousValue: previousValue, newValue: newValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SsoChangeLoginUrlType struct
    open class SsoChangeLoginUrlType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SsoChangeLoginUrlTypeSerializer().serialize(self)))"
        }
    }
    open class SsoChangeLoginUrlTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SsoChangeLoginUrlType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SsoChangeLoginUrlType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SsoChangeLoginUrlType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed sign-out URL for SSO.
    open class SsoChangeLogoutUrlDetails: CustomStringConvertible {
        /// Previous single sign-on logout URL. Might be missing due to historical data gap.
        public let previousValue: String?
        /// New single sign-on logout URL. Might be missing due to historical data gap.
        public let newValue: String?
        public init(previousValue: String? = nil, newValue: String? = nil) {
            nullableValidator(stringValidator())(previousValue)
            self.previousValue = previousValue
            nullableValidator(stringValidator())(newValue)
            self.newValue = newValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SsoChangeLogoutUrlDetailsSerializer().serialize(self)))"
        }
    }
    open class SsoChangeLogoutUrlDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SsoChangeLogoutUrlDetails) -> JSON {
            let output = [ 
            "previous_value": NullableSerializer(Serialization._StringSerializer).serialize(value.previousValue),
            "new_value": NullableSerializer(Serialization._StringSerializer).serialize(value.newValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SsoChangeLogoutUrlDetails {
            switch json {
                case .dictionary(let dict):
                    let previousValue = NullableSerializer(Serialization._StringSerializer).deserialize(dict["previous_value"] ?? .null)
                    let newValue = NullableSerializer(Serialization._StringSerializer).deserialize(dict["new_value"] ?? .null)
                    return SsoChangeLogoutUrlDetails(previousValue: previousValue, newValue: newValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SsoChangeLogoutUrlType struct
    open class SsoChangeLogoutUrlType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SsoChangeLogoutUrlTypeSerializer().serialize(self)))"
        }
    }
    open class SsoChangeLogoutUrlTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SsoChangeLogoutUrlType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SsoChangeLogoutUrlType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SsoChangeLogoutUrlType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed single sign-on setting for team.
    open class SsoChangePolicyDetails: CustomStringConvertible {
        /// New single sign-on policy.
        public let newValue: TeamPolicies.SsoPolicy
        /// Previous single sign-on policy. Might be missing due to historical data gap.
        public let previousValue: TeamPolicies.SsoPolicy?
        public init(newValue: TeamPolicies.SsoPolicy, previousValue: TeamPolicies.SsoPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SsoChangePolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class SsoChangePolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SsoChangePolicyDetails) -> JSON {
            let output = [ 
            "new_value": TeamPolicies.SsoPolicySerializer().serialize(value.newValue),
            "previous_value": NullableSerializer(TeamPolicies.SsoPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SsoChangePolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = TeamPolicies.SsoPolicySerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(TeamPolicies.SsoPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                    return SsoChangePolicyDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SsoChangePolicyType struct
    open class SsoChangePolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SsoChangePolicyTypeSerializer().serialize(self)))"
        }
    }
    open class SsoChangePolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SsoChangePolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SsoChangePolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SsoChangePolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed SAML identity mode for SSO.
    open class SsoChangeSamlIdentityModeDetails: CustomStringConvertible {
        /// Previous single sign-on identity mode.
        public let previousValue: Int64
        /// New single sign-on identity mode.
        public let newValue: Int64
        public init(previousValue: Int64, newValue: Int64) {
            comparableValidator()(previousValue)
            self.previousValue = previousValue
            comparableValidator()(newValue)
            self.newValue = newValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SsoChangeSamlIdentityModeDetailsSerializer().serialize(self)))"
        }
    }
    open class SsoChangeSamlIdentityModeDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SsoChangeSamlIdentityModeDetails) -> JSON {
            let output = [ 
            "previous_value": Serialization._Int64Serializer.serialize(value.previousValue),
            "new_value": Serialization._Int64Serializer.serialize(value.newValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SsoChangeSamlIdentityModeDetails {
            switch json {
                case .dictionary(let dict):
                    let previousValue = Serialization._Int64Serializer.deserialize(dict["previous_value"] ?? .null)
                    let newValue = Serialization._Int64Serializer.deserialize(dict["new_value"] ?? .null)
                    return SsoChangeSamlIdentityModeDetails(previousValue: previousValue, newValue: newValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SsoChangeSamlIdentityModeType struct
    open class SsoChangeSamlIdentityModeType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SsoChangeSamlIdentityModeTypeSerializer().serialize(self)))"
        }
    }
    open class SsoChangeSamlIdentityModeTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SsoChangeSamlIdentityModeType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SsoChangeSamlIdentityModeType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SsoChangeSamlIdentityModeType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Failed to sign in via SSO.
    open class SsoErrorDetails: CustomStringConvertible {
        /// Error details.
        public let errorDetails: TeamLog.FailureDetailsLogInfo
        public init(errorDetails: TeamLog.FailureDetailsLogInfo) {
            self.errorDetails = errorDetails
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SsoErrorDetailsSerializer().serialize(self)))"
        }
    }
    open class SsoErrorDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SsoErrorDetails) -> JSON {
            let output = [ 
            "error_details": TeamLog.FailureDetailsLogInfoSerializer().serialize(value.errorDetails),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SsoErrorDetails {
            switch json {
                case .dictionary(let dict):
                    let errorDetails = TeamLog.FailureDetailsLogInfoSerializer().deserialize(dict["error_details"] ?? .null)
                    return SsoErrorDetails(errorDetails: errorDetails)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SsoErrorType struct
    open class SsoErrorType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SsoErrorTypeSerializer().serialize(self)))"
        }
    }
    open class SsoErrorTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SsoErrorType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SsoErrorType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SsoErrorType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Removed X.509 certificate for SSO.
    open class SsoRemoveCertDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SsoRemoveCertDetailsSerializer().serialize(self)))"
        }
    }
    open class SsoRemoveCertDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SsoRemoveCertDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SsoRemoveCertDetails {
            switch json {
                case .dictionary(_):
                    return SsoRemoveCertDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SsoRemoveCertType struct
    open class SsoRemoveCertType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SsoRemoveCertTypeSerializer().serialize(self)))"
        }
    }
    open class SsoRemoveCertTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SsoRemoveCertType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SsoRemoveCertType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SsoRemoveCertType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Removed sign-in URL for SSO.
    open class SsoRemoveLoginUrlDetails: CustomStringConvertible {
        /// Previous single sign-on login URL.
        public let previousValue: String
        public init(previousValue: String) {
            stringValidator()(previousValue)
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SsoRemoveLoginUrlDetailsSerializer().serialize(self)))"
        }
    }
    open class SsoRemoveLoginUrlDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SsoRemoveLoginUrlDetails) -> JSON {
            let output = [ 
            "previous_value": Serialization._StringSerializer.serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SsoRemoveLoginUrlDetails {
            switch json {
                case .dictionary(let dict):
                    let previousValue = Serialization._StringSerializer.deserialize(dict["previous_value"] ?? .null)
                    return SsoRemoveLoginUrlDetails(previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SsoRemoveLoginUrlType struct
    open class SsoRemoveLoginUrlType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SsoRemoveLoginUrlTypeSerializer().serialize(self)))"
        }
    }
    open class SsoRemoveLoginUrlTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SsoRemoveLoginUrlType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SsoRemoveLoginUrlType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SsoRemoveLoginUrlType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Removed sign-out URL for SSO.
    open class SsoRemoveLogoutUrlDetails: CustomStringConvertible {
        /// Previous single sign-on logout URL.
        public let previousValue: String
        public init(previousValue: String) {
            stringValidator()(previousValue)
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SsoRemoveLogoutUrlDetailsSerializer().serialize(self)))"
        }
    }
    open class SsoRemoveLogoutUrlDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SsoRemoveLogoutUrlDetails) -> JSON {
            let output = [ 
            "previous_value": Serialization._StringSerializer.serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SsoRemoveLogoutUrlDetails {
            switch json {
                case .dictionary(let dict):
                    let previousValue = Serialization._StringSerializer.deserialize(dict["previous_value"] ?? .null)
                    return SsoRemoveLogoutUrlDetails(previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SsoRemoveLogoutUrlType struct
    open class SsoRemoveLogoutUrlType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SsoRemoveLogoutUrlTypeSerializer().serialize(self)))"
        }
    }
    open class SsoRemoveLogoutUrlTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SsoRemoveLogoutUrlType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SsoRemoveLogoutUrlType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return SsoRemoveLogoutUrlType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Created team activity report.
    open class TeamActivityCreateReportDetails: CustomStringConvertible {
        /// Report start date.
        public let startDate: Date
        /// Report end date.
        public let endDate: Date
        public init(startDate: Date, endDate: Date) {
            self.startDate = startDate
            self.endDate = endDate
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamActivityCreateReportDetailsSerializer().serialize(self)))"
        }
    }
    open class TeamActivityCreateReportDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamActivityCreateReportDetails) -> JSON {
            let output = [ 
            "start_date": NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.startDate),
            "end_date": NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.endDate),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TeamActivityCreateReportDetails {
            switch json {
                case .dictionary(let dict):
                    let startDate = NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["start_date"] ?? .null)
                    let endDate = NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["end_date"] ?? .null)
                    return TeamActivityCreateReportDetails(startDate: startDate, endDate: endDate)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The TeamActivityCreateReportType struct
    open class TeamActivityCreateReportType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamActivityCreateReportTypeSerializer().serialize(self)))"
        }
    }
    open class TeamActivityCreateReportTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamActivityCreateReportType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TeamActivityCreateReportType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return TeamActivityCreateReportType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// An audit log event.
    open class TeamEvent: CustomStringConvertible {
        /// The Dropbox timestamp representing when the action was taken.
        public let timestamp_: Date
        /// The category that this type of action belongs to.
        public let eventCategory: TeamLog.EventCategory
        /// The entity who actually performed the action. Might be missing due to historical data gap.
        public let actor: TeamLog.ActorLogInfo?
        /// The origin from which the actor performed the action including information about host, ip address, location,
        /// session, etc. If the action was performed programmatically via the API the origin represents the API client.
        public let origin: TeamLog.OriginLogInfo?
        /// True if the action involved a non team member either as the actor or as one of the affected users. Might be
        /// missing due to historical data gap.
        public let involveNonTeamMember: Bool?
        /// The user or team on whose behalf the actor performed the action. Might be missing due to historical data
        /// gap.
        public let context: TeamLog.ContextLogInfo?
        /// Zero or more users and/or groups that are affected by the action. Note that this list doesn't include any
        /// actors or users in context.
        public let participants: Array<TeamLog.ParticipantLogInfo>?
        /// Zero or more content assets involved in the action. Currently these include Dropbox files and folders but in
        /// the future we might add other asset types such as Paper documents, folders, projects, etc.
        public let assets: Array<TeamLog.AssetLogInfo>?
        /// The particular type of action taken.
        public let eventType: TeamLog.EventType
        /// The variable event schema applicable to this type of action, instantiated with respect to this particular
        /// action.
        public let details: TeamLog.EventDetails
        public init(timestamp_: Date, eventCategory: TeamLog.EventCategory, eventType: TeamLog.EventType, details: TeamLog.EventDetails, actor: TeamLog.ActorLogInfo? = nil, origin: TeamLog.OriginLogInfo? = nil, involveNonTeamMember: Bool? = nil, context: TeamLog.ContextLogInfo? = nil, participants: Array<TeamLog.ParticipantLogInfo>? = nil, assets: Array<TeamLog.AssetLogInfo>? = nil) {
            self.timestamp_ = timestamp_
            self.eventCategory = eventCategory
            self.actor = actor
            self.origin = origin
            self.involveNonTeamMember = involveNonTeamMember
            self.context = context
            self.participants = participants
            self.assets = assets
            self.eventType = eventType
            self.details = details
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamEventSerializer().serialize(self)))"
        }
    }
    open class TeamEventSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamEvent) -> JSON {
            let output = [ 
            "timestamp": NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.timestamp_),
            "event_category": TeamLog.EventCategorySerializer().serialize(value.eventCategory),
            "event_type": TeamLog.EventTypeSerializer().serialize(value.eventType),
            "details": TeamLog.EventDetailsSerializer().serialize(value.details),
            "actor": NullableSerializer(TeamLog.ActorLogInfoSerializer()).serialize(value.actor),
            "origin": NullableSerializer(TeamLog.OriginLogInfoSerializer()).serialize(value.origin),
            "involve_non_team_member": NullableSerializer(Serialization._BoolSerializer).serialize(value.involveNonTeamMember),
            "context": NullableSerializer(TeamLog.ContextLogInfoSerializer()).serialize(value.context),
            "participants": NullableSerializer(ArraySerializer(TeamLog.ParticipantLogInfoSerializer())).serialize(value.participants),
            "assets": NullableSerializer(ArraySerializer(TeamLog.AssetLogInfoSerializer())).serialize(value.assets),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TeamEvent {
            switch json {
                case .dictionary(let dict):
                    let timestamp_ = NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["timestamp"] ?? .null)
                    let eventCategory = TeamLog.EventCategorySerializer().deserialize(dict["event_category"] ?? .null)
                    let eventType = TeamLog.EventTypeSerializer().deserialize(dict["event_type"] ?? .null)
                    let details = TeamLog.EventDetailsSerializer().deserialize(dict["details"] ?? .null)
                    let actor = NullableSerializer(TeamLog.ActorLogInfoSerializer()).deserialize(dict["actor"] ?? .null)
                    let origin = NullableSerializer(TeamLog.OriginLogInfoSerializer()).deserialize(dict["origin"] ?? .null)
                    let involveNonTeamMember = NullableSerializer(Serialization._BoolSerializer).deserialize(dict["involve_non_team_member"] ?? .null)
                    let context = NullableSerializer(TeamLog.ContextLogInfoSerializer()).deserialize(dict["context"] ?? .null)
                    let participants = NullableSerializer(ArraySerializer(TeamLog.ParticipantLogInfoSerializer())).deserialize(dict["participants"] ?? .null)
                    let assets = NullableSerializer(ArraySerializer(TeamLog.AssetLogInfoSerializer())).deserialize(dict["assets"] ?? .null)
                    return TeamEvent(timestamp_: timestamp_, eventCategory: eventCategory, eventType: eventType, details: details, actor: actor, origin: origin, involveNonTeamMember: involveNonTeamMember, context: context, participants: participants, assets: assets)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed archival status of team folder.
    open class TeamFolderChangeStatusDetails: CustomStringConvertible {
        /// New team folder status.
        public let newValue: Team.TeamFolderStatus
        /// Previous team folder status. Might be missing due to historical data gap.
        public let previousValue: Team.TeamFolderStatus?
        public init(newValue: Team.TeamFolderStatus, previousValue: Team.TeamFolderStatus? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamFolderChangeStatusDetailsSerializer().serialize(self)))"
        }
    }
    open class TeamFolderChangeStatusDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamFolderChangeStatusDetails) -> JSON {
            let output = [ 
            "new_value": Team.TeamFolderStatusSerializer().serialize(value.newValue),
            "previous_value": NullableSerializer(Team.TeamFolderStatusSerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TeamFolderChangeStatusDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = Team.TeamFolderStatusSerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(Team.TeamFolderStatusSerializer()).deserialize(dict["previous_value"] ?? .null)
                    return TeamFolderChangeStatusDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The TeamFolderChangeStatusType struct
    open class TeamFolderChangeStatusType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamFolderChangeStatusTypeSerializer().serialize(self)))"
        }
    }
    open class TeamFolderChangeStatusTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamFolderChangeStatusType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TeamFolderChangeStatusType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return TeamFolderChangeStatusType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Created team folder in active status.
    open class TeamFolderCreateDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamFolderCreateDetailsSerializer().serialize(self)))"
        }
    }
    open class TeamFolderCreateDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamFolderCreateDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TeamFolderCreateDetails {
            switch json {
                case .dictionary(_):
                    return TeamFolderCreateDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The TeamFolderCreateType struct
    open class TeamFolderCreateType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamFolderCreateTypeSerializer().serialize(self)))"
        }
    }
    open class TeamFolderCreateTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamFolderCreateType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TeamFolderCreateType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return TeamFolderCreateType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Downgraded team folder to regular shared folder.
    open class TeamFolderDowngradeDetails: CustomStringConvertible {
        /// Target asset position in the Assets list.
        public let targetAssetIndex: UInt64
        public init(targetAssetIndex: UInt64) {
            comparableValidator()(targetAssetIndex)
            self.targetAssetIndex = targetAssetIndex
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamFolderDowngradeDetailsSerializer().serialize(self)))"
        }
    }
    open class TeamFolderDowngradeDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamFolderDowngradeDetails) -> JSON {
            let output = [ 
            "target_asset_index": Serialization._UInt64Serializer.serialize(value.targetAssetIndex),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TeamFolderDowngradeDetails {
            switch json {
                case .dictionary(let dict):
                    let targetAssetIndex = Serialization._UInt64Serializer.deserialize(dict["target_asset_index"] ?? .null)
                    return TeamFolderDowngradeDetails(targetAssetIndex: targetAssetIndex)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The TeamFolderDowngradeType struct
    open class TeamFolderDowngradeType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamFolderDowngradeTypeSerializer().serialize(self)))"
        }
    }
    open class TeamFolderDowngradeTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamFolderDowngradeType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TeamFolderDowngradeType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return TeamFolderDowngradeType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Permanently deleted archived team folder.
    open class TeamFolderPermanentlyDeleteDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamFolderPermanentlyDeleteDetailsSerializer().serialize(self)))"
        }
    }
    open class TeamFolderPermanentlyDeleteDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamFolderPermanentlyDeleteDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TeamFolderPermanentlyDeleteDetails {
            switch json {
                case .dictionary(_):
                    return TeamFolderPermanentlyDeleteDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The TeamFolderPermanentlyDeleteType struct
    open class TeamFolderPermanentlyDeleteType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamFolderPermanentlyDeleteTypeSerializer().serialize(self)))"
        }
    }
    open class TeamFolderPermanentlyDeleteTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamFolderPermanentlyDeleteType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TeamFolderPermanentlyDeleteType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return TeamFolderPermanentlyDeleteType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Renamed active/archived team folder.
    open class TeamFolderRenameDetails: CustomStringConvertible {
        /// Previous folder name.
        public let previousFolderName: String
        /// New folder name.
        public let newFolderName: String
        public init(previousFolderName: String, newFolderName: String) {
            stringValidator()(previousFolderName)
            self.previousFolderName = previousFolderName
            stringValidator()(newFolderName)
            self.newFolderName = newFolderName
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamFolderRenameDetailsSerializer().serialize(self)))"
        }
    }
    open class TeamFolderRenameDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamFolderRenameDetails) -> JSON {
            let output = [ 
            "previous_folder_name": Serialization._StringSerializer.serialize(value.previousFolderName),
            "new_folder_name": Serialization._StringSerializer.serialize(value.newFolderName),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TeamFolderRenameDetails {
            switch json {
                case .dictionary(let dict):
                    let previousFolderName = Serialization._StringSerializer.deserialize(dict["previous_folder_name"] ?? .null)
                    let newFolderName = Serialization._StringSerializer.deserialize(dict["new_folder_name"] ?? .null)
                    return TeamFolderRenameDetails(previousFolderName: previousFolderName, newFolderName: newFolderName)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The TeamFolderRenameType struct
    open class TeamFolderRenameType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamFolderRenameTypeSerializer().serialize(self)))"
        }
    }
    open class TeamFolderRenameTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamFolderRenameType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TeamFolderRenameType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return TeamFolderRenameType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Team linked app
    open class TeamLinkedAppLogInfo: TeamLog.AppLogInfo {
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamLinkedAppLogInfoSerializer().serialize(self)))"
        }
    }
    open class TeamLinkedAppLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamLinkedAppLogInfo) -> JSON {
            let output = [ 
            "app_id": NullableSerializer(Serialization._StringSerializer).serialize(value.appId),
            "display_name": NullableSerializer(Serialization._StringSerializer).serialize(value.displayName),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TeamLinkedAppLogInfo {
            switch json {
                case .dictionary(let dict):
                    let appId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["app_id"] ?? .null)
                    let displayName = NullableSerializer(Serialization._StringSerializer).deserialize(dict["display_name"] ?? .null)
                    return TeamLinkedAppLogInfo(appId: appId, displayName: displayName)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Team member's logged information.
    open class TeamMemberLogInfo: TeamLog.UserLogInfo {
        /// Team member ID. Might be missing due to historical data gap.
        public let teamMemberId: String?
        /// Team member external ID.
        public let memberExternalId: String?
        public init(accountId: String? = nil, displayName: String? = nil, email: String? = nil, teamMemberId: String? = nil, memberExternalId: String? = nil) {
            nullableValidator(stringValidator())(teamMemberId)
            self.teamMemberId = teamMemberId
            nullableValidator(stringValidator(maxLength: 64))(memberExternalId)
            self.memberExternalId = memberExternalId
            super.init(accountId: accountId, displayName: displayName, email: email)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamMemberLogInfoSerializer().serialize(self)))"
        }
    }
    open class TeamMemberLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamMemberLogInfo) -> JSON {
            let output = [ 
            "account_id": NullableSerializer(Serialization._StringSerializer).serialize(value.accountId),
            "display_name": NullableSerializer(Serialization._StringSerializer).serialize(value.displayName),
            "email": NullableSerializer(Serialization._StringSerializer).serialize(value.email),
            "team_member_id": NullableSerializer(Serialization._StringSerializer).serialize(value.teamMemberId),
            "member_external_id": NullableSerializer(Serialization._StringSerializer).serialize(value.memberExternalId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TeamMemberLogInfo {
            switch json {
                case .dictionary(let dict):
                    let accountId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["account_id"] ?? .null)
                    let displayName = NullableSerializer(Serialization._StringSerializer).deserialize(dict["display_name"] ?? .null)
                    let email = NullableSerializer(Serialization._StringSerializer).deserialize(dict["email"] ?? .null)
                    let teamMemberId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["team_member_id"] ?? .null)
                    let memberExternalId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["member_external_id"] ?? .null)
                    return TeamMemberLogInfo(accountId: accountId, displayName: displayName, email: email, teamMemberId: teamMemberId, memberExternalId: memberExternalId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The TeamMembershipType union
    public enum TeamMembershipType: CustomStringConvertible {
        /// An unspecified error.
        case free
        /// An unspecified error.
        case full
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamMembershipTypeSerializer().serialize(self)))"
        }
    }
    open class TeamMembershipTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamMembershipType) -> JSON {
            switch value {
                case .free:
                    var d = [String: JSON]()
                    d[".tag"] = .str("free")
                    return .dictionary(d)
                case .full:
                    var d = [String: JSON]()
                    d[".tag"] = .str("full")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> TeamMembershipType {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "free":
                            return TeamMembershipType.free
                        case "full":
                            return TeamMembershipType.full
                        case "other":
                            return TeamMembershipType.other
                        default:
                            return TeamMembershipType.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Merged another team into this team.
    open class TeamMergeFromDetails: CustomStringConvertible {
        /// The name of the team that was merged into this team.
        public let teamName: String
        public init(teamName: String) {
            stringValidator()(teamName)
            self.teamName = teamName
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamMergeFromDetailsSerializer().serialize(self)))"
        }
    }
    open class TeamMergeFromDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamMergeFromDetails) -> JSON {
            let output = [ 
            "team_name": Serialization._StringSerializer.serialize(value.teamName),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TeamMergeFromDetails {
            switch json {
                case .dictionary(let dict):
                    let teamName = Serialization._StringSerializer.deserialize(dict["team_name"] ?? .null)
                    return TeamMergeFromDetails(teamName: teamName)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The TeamMergeFromType struct
    open class TeamMergeFromType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamMergeFromTypeSerializer().serialize(self)))"
        }
    }
    open class TeamMergeFromTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamMergeFromType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TeamMergeFromType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return TeamMergeFromType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Merged this team into another team.
    open class TeamMergeToDetails: CustomStringConvertible {
        /// The name of the team that this team was merged into.
        public let teamName: String
        public init(teamName: String) {
            stringValidator()(teamName)
            self.teamName = teamName
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamMergeToDetailsSerializer().serialize(self)))"
        }
    }
    open class TeamMergeToDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamMergeToDetails) -> JSON {
            let output = [ 
            "team_name": Serialization._StringSerializer.serialize(value.teamName),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TeamMergeToDetails {
            switch json {
                case .dictionary(let dict):
                    let teamName = Serialization._StringSerializer.deserialize(dict["team_name"] ?? .null)
                    return TeamMergeToDetails(teamName: teamName)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The TeamMergeToType struct
    open class TeamMergeToType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamMergeToTypeSerializer().serialize(self)))"
        }
    }
    open class TeamMergeToTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamMergeToType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TeamMergeToType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return TeamMergeToType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Team name details
    open class TeamName: CustomStringConvertible {
        /// Team's display name.
        public let teamDisplayName: String
        /// Team's legal name.
        public let teamLegalName: String
        public init(teamDisplayName: String, teamLegalName: String) {
            stringValidator()(teamDisplayName)
            self.teamDisplayName = teamDisplayName
            stringValidator()(teamLegalName)
            self.teamLegalName = teamLegalName
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamNameSerializer().serialize(self)))"
        }
    }
    open class TeamNameSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamName) -> JSON {
            let output = [ 
            "team_display_name": Serialization._StringSerializer.serialize(value.teamDisplayName),
            "team_legal_name": Serialization._StringSerializer.serialize(value.teamLegalName),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TeamName {
            switch json {
                case .dictionary(let dict):
                    let teamDisplayName = Serialization._StringSerializer.deserialize(dict["team_display_name"] ?? .null)
                    let teamLegalName = Serialization._StringSerializer.deserialize(dict["team_legal_name"] ?? .null)
                    return TeamName(teamDisplayName: teamDisplayName, teamLegalName: teamLegalName)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Added team logo to display on shared link headers.
    open class TeamProfileAddLogoDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamProfileAddLogoDetailsSerializer().serialize(self)))"
        }
    }
    open class TeamProfileAddLogoDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamProfileAddLogoDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TeamProfileAddLogoDetails {
            switch json {
                case .dictionary(_):
                    return TeamProfileAddLogoDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The TeamProfileAddLogoType struct
    open class TeamProfileAddLogoType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamProfileAddLogoTypeSerializer().serialize(self)))"
        }
    }
    open class TeamProfileAddLogoTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamProfileAddLogoType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TeamProfileAddLogoType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return TeamProfileAddLogoType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed default language for team.
    open class TeamProfileChangeDefaultLanguageDetails: CustomStringConvertible {
        /// New team's default language.
        public let newValue: String
        /// Previous team's default language.
        public let previousValue: String
        public init(newValue: String, previousValue: String) {
            stringValidator(minLength: 2)(newValue)
            self.newValue = newValue
            stringValidator(minLength: 2)(previousValue)
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamProfileChangeDefaultLanguageDetailsSerializer().serialize(self)))"
        }
    }
    open class TeamProfileChangeDefaultLanguageDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamProfileChangeDefaultLanguageDetails) -> JSON {
            let output = [ 
            "new_value": Serialization._StringSerializer.serialize(value.newValue),
            "previous_value": Serialization._StringSerializer.serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TeamProfileChangeDefaultLanguageDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = Serialization._StringSerializer.deserialize(dict["new_value"] ?? .null)
                    let previousValue = Serialization._StringSerializer.deserialize(dict["previous_value"] ?? .null)
                    return TeamProfileChangeDefaultLanguageDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The TeamProfileChangeDefaultLanguageType struct
    open class TeamProfileChangeDefaultLanguageType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamProfileChangeDefaultLanguageTypeSerializer().serialize(self)))"
        }
    }
    open class TeamProfileChangeDefaultLanguageTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamProfileChangeDefaultLanguageType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TeamProfileChangeDefaultLanguageType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return TeamProfileChangeDefaultLanguageType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed team logo displayed on shared link headers.
    open class TeamProfileChangeLogoDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamProfileChangeLogoDetailsSerializer().serialize(self)))"
        }
    }
    open class TeamProfileChangeLogoDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamProfileChangeLogoDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TeamProfileChangeLogoDetails {
            switch json {
                case .dictionary(_):
                    return TeamProfileChangeLogoDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The TeamProfileChangeLogoType struct
    open class TeamProfileChangeLogoType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamProfileChangeLogoTypeSerializer().serialize(self)))"
        }
    }
    open class TeamProfileChangeLogoTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamProfileChangeLogoType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TeamProfileChangeLogoType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return TeamProfileChangeLogoType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed team name.
    open class TeamProfileChangeNameDetails: CustomStringConvertible {
        /// Previous teams name. Might be missing due to historical data gap.
        public let previousValue: TeamLog.TeamName?
        /// New team name.
        public let newValue: TeamLog.TeamName
        public init(newValue: TeamLog.TeamName, previousValue: TeamLog.TeamName? = nil) {
            self.previousValue = previousValue
            self.newValue = newValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamProfileChangeNameDetailsSerializer().serialize(self)))"
        }
    }
    open class TeamProfileChangeNameDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamProfileChangeNameDetails) -> JSON {
            let output = [ 
            "new_value": TeamLog.TeamNameSerializer().serialize(value.newValue),
            "previous_value": NullableSerializer(TeamLog.TeamNameSerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TeamProfileChangeNameDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = TeamLog.TeamNameSerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(TeamLog.TeamNameSerializer()).deserialize(dict["previous_value"] ?? .null)
                    return TeamProfileChangeNameDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The TeamProfileChangeNameType struct
    open class TeamProfileChangeNameType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamProfileChangeNameTypeSerializer().serialize(self)))"
        }
    }
    open class TeamProfileChangeNameTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamProfileChangeNameType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TeamProfileChangeNameType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return TeamProfileChangeNameType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Removed team logo displayed on shared link headers.
    open class TeamProfileRemoveLogoDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamProfileRemoveLogoDetailsSerializer().serialize(self)))"
        }
    }
    open class TeamProfileRemoveLogoDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamProfileRemoveLogoDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TeamProfileRemoveLogoDetails {
            switch json {
                case .dictionary(_):
                    return TeamProfileRemoveLogoDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The TeamProfileRemoveLogoType struct
    open class TeamProfileRemoveLogoType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamProfileRemoveLogoTypeSerializer().serialize(self)))"
        }
    }
    open class TeamProfileRemoveLogoTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamProfileRemoveLogoType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TeamProfileRemoveLogoType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return TeamProfileRemoveLogoType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Policy for controlling whether team selective sync is enabled for team.
    public enum TeamSelectiveSyncPolicy: CustomStringConvertible {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamSelectiveSyncPolicySerializer().serialize(self)))"
        }
    }
    open class TeamSelectiveSyncPolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamSelectiveSyncPolicy) -> JSON {
            switch value {
                case .disabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disabled")
                    return .dictionary(d)
                case .enabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("enabled")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> TeamSelectiveSyncPolicy {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "disabled":
                            return TeamSelectiveSyncPolicy.disabled
                        case "enabled":
                            return TeamSelectiveSyncPolicy.enabled
                        case "other":
                            return TeamSelectiveSyncPolicy.other
                        default:
                            return TeamSelectiveSyncPolicy.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Enabled/disabled Team Selective Sync for team.
    open class TeamSelectiveSyncPolicyChangedDetails: CustomStringConvertible {
        /// New Team Selective Sync policy.
        public let newValue: TeamLog.TeamSelectiveSyncPolicy
        /// Previous Team Selective Sync policy.
        public let previousValue: TeamLog.TeamSelectiveSyncPolicy
        public init(newValue: TeamLog.TeamSelectiveSyncPolicy, previousValue: TeamLog.TeamSelectiveSyncPolicy) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamSelectiveSyncPolicyChangedDetailsSerializer().serialize(self)))"
        }
    }
    open class TeamSelectiveSyncPolicyChangedDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamSelectiveSyncPolicyChangedDetails) -> JSON {
            let output = [ 
            "new_value": TeamLog.TeamSelectiveSyncPolicySerializer().serialize(value.newValue),
            "previous_value": TeamLog.TeamSelectiveSyncPolicySerializer().serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TeamSelectiveSyncPolicyChangedDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = TeamLog.TeamSelectiveSyncPolicySerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = TeamLog.TeamSelectiveSyncPolicySerializer().deserialize(dict["previous_value"] ?? .null)
                    return TeamSelectiveSyncPolicyChangedDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The TeamSelectiveSyncPolicyChangedType struct
    open class TeamSelectiveSyncPolicyChangedType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamSelectiveSyncPolicyChangedTypeSerializer().serialize(self)))"
        }
    }
    open class TeamSelectiveSyncPolicyChangedTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamSelectiveSyncPolicyChangedType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TeamSelectiveSyncPolicyChangedType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return TeamSelectiveSyncPolicyChangedType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed sync default.
    open class TeamSelectiveSyncSettingsChangedDetails: CustomStringConvertible {
        /// Previous value.
        public let previousValue: Files.SyncSetting
        /// New value.
        public let newValue: Files.SyncSetting
        public init(previousValue: Files.SyncSetting, newValue: Files.SyncSetting) {
            self.previousValue = previousValue
            self.newValue = newValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamSelectiveSyncSettingsChangedDetailsSerializer().serialize(self)))"
        }
    }
    open class TeamSelectiveSyncSettingsChangedDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamSelectiveSyncSettingsChangedDetails) -> JSON {
            let output = [ 
            "previous_value": Files.SyncSettingSerializer().serialize(value.previousValue),
            "new_value": Files.SyncSettingSerializer().serialize(value.newValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TeamSelectiveSyncSettingsChangedDetails {
            switch json {
                case .dictionary(let dict):
                    let previousValue = Files.SyncSettingSerializer().deserialize(dict["previous_value"] ?? .null)
                    let newValue = Files.SyncSettingSerializer().deserialize(dict["new_value"] ?? .null)
                    return TeamSelectiveSyncSettingsChangedDetails(previousValue: previousValue, newValue: newValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The TeamSelectiveSyncSettingsChangedType struct
    open class TeamSelectiveSyncSettingsChangedType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamSelectiveSyncSettingsChangedTypeSerializer().serialize(self)))"
        }
    }
    open class TeamSelectiveSyncSettingsChangedTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamSelectiveSyncSettingsChangedType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TeamSelectiveSyncSettingsChangedType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return TeamSelectiveSyncSettingsChangedType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Added backup phone for two-step verification.
    open class TfaAddBackupPhoneDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TfaAddBackupPhoneDetailsSerializer().serialize(self)))"
        }
    }
    open class TfaAddBackupPhoneDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TfaAddBackupPhoneDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TfaAddBackupPhoneDetails {
            switch json {
                case .dictionary(_):
                    return TfaAddBackupPhoneDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The TfaAddBackupPhoneType struct
    open class TfaAddBackupPhoneType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TfaAddBackupPhoneTypeSerializer().serialize(self)))"
        }
    }
    open class TfaAddBackupPhoneTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TfaAddBackupPhoneType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TfaAddBackupPhoneType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return TfaAddBackupPhoneType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Added security key for two-step verification.
    open class TfaAddSecurityKeyDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TfaAddSecurityKeyDetailsSerializer().serialize(self)))"
        }
    }
    open class TfaAddSecurityKeyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TfaAddSecurityKeyDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TfaAddSecurityKeyDetails {
            switch json {
                case .dictionary(_):
                    return TfaAddSecurityKeyDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The TfaAddSecurityKeyType struct
    open class TfaAddSecurityKeyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TfaAddSecurityKeyTypeSerializer().serialize(self)))"
        }
    }
    open class TfaAddSecurityKeyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TfaAddSecurityKeyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TfaAddSecurityKeyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return TfaAddSecurityKeyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed backup phone for two-step verification.
    open class TfaChangeBackupPhoneDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TfaChangeBackupPhoneDetailsSerializer().serialize(self)))"
        }
    }
    open class TfaChangeBackupPhoneDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TfaChangeBackupPhoneDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TfaChangeBackupPhoneDetails {
            switch json {
                case .dictionary(_):
                    return TfaChangeBackupPhoneDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The TfaChangeBackupPhoneType struct
    open class TfaChangeBackupPhoneType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TfaChangeBackupPhoneTypeSerializer().serialize(self)))"
        }
    }
    open class TfaChangeBackupPhoneTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TfaChangeBackupPhoneType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TfaChangeBackupPhoneType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return TfaChangeBackupPhoneType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed two-step verification setting for team.
    open class TfaChangePolicyDetails: CustomStringConvertible {
        /// New change policy.
        public let newValue: TeamPolicies.TwoStepVerificationPolicy
        /// Previous change policy. Might be missing due to historical data gap.
        public let previousValue: TeamPolicies.TwoStepVerificationPolicy?
        public init(newValue: TeamPolicies.TwoStepVerificationPolicy, previousValue: TeamPolicies.TwoStepVerificationPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TfaChangePolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class TfaChangePolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TfaChangePolicyDetails) -> JSON {
            let output = [ 
            "new_value": TeamPolicies.TwoStepVerificationPolicySerializer().serialize(value.newValue),
            "previous_value": NullableSerializer(TeamPolicies.TwoStepVerificationPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TfaChangePolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = TeamPolicies.TwoStepVerificationPolicySerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(TeamPolicies.TwoStepVerificationPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                    return TfaChangePolicyDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The TfaChangePolicyType struct
    open class TfaChangePolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TfaChangePolicyTypeSerializer().serialize(self)))"
        }
    }
    open class TfaChangePolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TfaChangePolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TfaChangePolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return TfaChangePolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Enabled/disabled/changed two-step verification setting.
    open class TfaChangeStatusDetails: CustomStringConvertible {
        /// The new two factor authentication configuration.
        public let newValue: TeamLog.TfaConfiguration
        /// The previous two factor authentication configuration. Might be missing due to historical data gap.
        public let previousValue: TeamLog.TfaConfiguration?
        /// Used two factor authentication rescue code. This flag is relevant when the two factor authentication
        /// configuration is disabled.
        public let usedRescueCode: Bool?
        public init(newValue: TeamLog.TfaConfiguration, previousValue: TeamLog.TfaConfiguration? = nil, usedRescueCode: Bool? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
            self.usedRescueCode = usedRescueCode
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TfaChangeStatusDetailsSerializer().serialize(self)))"
        }
    }
    open class TfaChangeStatusDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TfaChangeStatusDetails) -> JSON {
            let output = [ 
            "new_value": TeamLog.TfaConfigurationSerializer().serialize(value.newValue),
            "previous_value": NullableSerializer(TeamLog.TfaConfigurationSerializer()).serialize(value.previousValue),
            "used_rescue_code": NullableSerializer(Serialization._BoolSerializer).serialize(value.usedRescueCode),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TfaChangeStatusDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = TeamLog.TfaConfigurationSerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(TeamLog.TfaConfigurationSerializer()).deserialize(dict["previous_value"] ?? .null)
                    let usedRescueCode = NullableSerializer(Serialization._BoolSerializer).deserialize(dict["used_rescue_code"] ?? .null)
                    return TfaChangeStatusDetails(newValue: newValue, previousValue: previousValue, usedRescueCode: usedRescueCode)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The TfaChangeStatusType struct
    open class TfaChangeStatusType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TfaChangeStatusTypeSerializer().serialize(self)))"
        }
    }
    open class TfaChangeStatusTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TfaChangeStatusType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TfaChangeStatusType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return TfaChangeStatusType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Two factor authentication configuration. Note: the enabled option is deprecated.
    public enum TfaConfiguration: CustomStringConvertible {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case sms
        /// An unspecified error.
        case authenticator
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TfaConfigurationSerializer().serialize(self)))"
        }
    }
    open class TfaConfigurationSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TfaConfiguration) -> JSON {
            switch value {
                case .disabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disabled")
                    return .dictionary(d)
                case .enabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("enabled")
                    return .dictionary(d)
                case .sms:
                    var d = [String: JSON]()
                    d[".tag"] = .str("sms")
                    return .dictionary(d)
                case .authenticator:
                    var d = [String: JSON]()
                    d[".tag"] = .str("authenticator")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> TfaConfiguration {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "disabled":
                            return TfaConfiguration.disabled
                        case "enabled":
                            return TfaConfiguration.enabled
                        case "sms":
                            return TfaConfiguration.sms
                        case "authenticator":
                            return TfaConfiguration.authenticator
                        case "other":
                            return TfaConfiguration.other
                        default:
                            return TfaConfiguration.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Removed backup phone for two-step verification.
    open class TfaRemoveBackupPhoneDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TfaRemoveBackupPhoneDetailsSerializer().serialize(self)))"
        }
    }
    open class TfaRemoveBackupPhoneDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TfaRemoveBackupPhoneDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TfaRemoveBackupPhoneDetails {
            switch json {
                case .dictionary(_):
                    return TfaRemoveBackupPhoneDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The TfaRemoveBackupPhoneType struct
    open class TfaRemoveBackupPhoneType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TfaRemoveBackupPhoneTypeSerializer().serialize(self)))"
        }
    }
    open class TfaRemoveBackupPhoneTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TfaRemoveBackupPhoneType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TfaRemoveBackupPhoneType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return TfaRemoveBackupPhoneType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Removed security key for two-step verification.
    open class TfaRemoveSecurityKeyDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TfaRemoveSecurityKeyDetailsSerializer().serialize(self)))"
        }
    }
    open class TfaRemoveSecurityKeyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TfaRemoveSecurityKeyDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TfaRemoveSecurityKeyDetails {
            switch json {
                case .dictionary(_):
                    return TfaRemoveSecurityKeyDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The TfaRemoveSecurityKeyType struct
    open class TfaRemoveSecurityKeyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TfaRemoveSecurityKeyTypeSerializer().serialize(self)))"
        }
    }
    open class TfaRemoveSecurityKeyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TfaRemoveSecurityKeyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TfaRemoveSecurityKeyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return TfaRemoveSecurityKeyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Reset two-step verification for team member.
    open class TfaResetDetails: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TfaResetDetailsSerializer().serialize(self)))"
        }
    }
    open class TfaResetDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TfaResetDetails) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TfaResetDetails {
            switch json {
                case .dictionary(_):
                    return TfaResetDetails()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The TfaResetType struct
    open class TfaResetType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TfaResetTypeSerializer().serialize(self)))"
        }
    }
    open class TfaResetTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TfaResetType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TfaResetType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return TfaResetType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The TimeUnit union
    public enum TimeUnit: CustomStringConvertible {
        /// An unspecified error.
        case milliseconds
        /// An unspecified error.
        case seconds
        /// An unspecified error.
        case minutes
        /// An unspecified error.
        case hours
        /// An unspecified error.
        case days
        /// An unspecified error.
        case weeks
        /// An unspecified error.
        case months
        /// An unspecified error.
        case years
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TimeUnitSerializer().serialize(self)))"
        }
    }
    open class TimeUnitSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TimeUnit) -> JSON {
            switch value {
                case .milliseconds:
                    var d = [String: JSON]()
                    d[".tag"] = .str("milliseconds")
                    return .dictionary(d)
                case .seconds:
                    var d = [String: JSON]()
                    d[".tag"] = .str("seconds")
                    return .dictionary(d)
                case .minutes:
                    var d = [String: JSON]()
                    d[".tag"] = .str("minutes")
                    return .dictionary(d)
                case .hours:
                    var d = [String: JSON]()
                    d[".tag"] = .str("hours")
                    return .dictionary(d)
                case .days:
                    var d = [String: JSON]()
                    d[".tag"] = .str("days")
                    return .dictionary(d)
                case .weeks:
                    var d = [String: JSON]()
                    d[".tag"] = .str("weeks")
                    return .dictionary(d)
                case .months:
                    var d = [String: JSON]()
                    d[".tag"] = .str("months")
                    return .dictionary(d)
                case .years:
                    var d = [String: JSON]()
                    d[".tag"] = .str("years")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> TimeUnit {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "milliseconds":
                            return TimeUnit.milliseconds
                        case "seconds":
                            return TimeUnit.seconds
                        case "minutes":
                            return TimeUnit.minutes
                        case "hours":
                            return TimeUnit.hours
                        case "days":
                            return TimeUnit.days
                        case "weeks":
                            return TimeUnit.weeks
                        case "months":
                            return TimeUnit.months
                        case "years":
                            return TimeUnit.years
                        case "other":
                            return TimeUnit.other
                        default:
                            return TimeUnit.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// User that is not a member of the team but considered trusted.
    open class TrustedNonTeamMemberLogInfo: TeamLog.UserLogInfo {
        /// Indicates the type of the trusted non team member user.
        public let trustedNonTeamMemberType: TeamLog.TrustedNonTeamMemberType
        public init(trustedNonTeamMemberType: TeamLog.TrustedNonTeamMemberType, accountId: String? = nil, displayName: String? = nil, email: String? = nil) {
            self.trustedNonTeamMemberType = trustedNonTeamMemberType
            super.init(accountId: accountId, displayName: displayName, email: email)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TrustedNonTeamMemberLogInfoSerializer().serialize(self)))"
        }
    }
    open class TrustedNonTeamMemberLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TrustedNonTeamMemberLogInfo) -> JSON {
            let output = [ 
            "trusted_non_team_member_type": TeamLog.TrustedNonTeamMemberTypeSerializer().serialize(value.trustedNonTeamMemberType),
            "account_id": NullableSerializer(Serialization._StringSerializer).serialize(value.accountId),
            "display_name": NullableSerializer(Serialization._StringSerializer).serialize(value.displayName),
            "email": NullableSerializer(Serialization._StringSerializer).serialize(value.email),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TrustedNonTeamMemberLogInfo {
            switch json {
                case .dictionary(let dict):
                    let trustedNonTeamMemberType = TeamLog.TrustedNonTeamMemberTypeSerializer().deserialize(dict["trusted_non_team_member_type"] ?? .null)
                    let accountId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["account_id"] ?? .null)
                    let displayName = NullableSerializer(Serialization._StringSerializer).deserialize(dict["display_name"] ?? .null)
                    let email = NullableSerializer(Serialization._StringSerializer).deserialize(dict["email"] ?? .null)
                    return TrustedNonTeamMemberLogInfo(trustedNonTeamMemberType: trustedNonTeamMemberType, accountId: accountId, displayName: displayName, email: email)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The TrustedNonTeamMemberType union
    public enum TrustedNonTeamMemberType: CustomStringConvertible {
        /// An unspecified error.
        case multiInstanceAdmin
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TrustedNonTeamMemberTypeSerializer().serialize(self)))"
        }
    }
    open class TrustedNonTeamMemberTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TrustedNonTeamMemberType) -> JSON {
            switch value {
                case .multiInstanceAdmin:
                    var d = [String: JSON]()
                    d[".tag"] = .str("multi_instance_admin")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> TrustedNonTeamMemberType {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "multi_instance_admin":
                            return TrustedNonTeamMemberType.multiInstanceAdmin
                        case "other":
                            return TrustedNonTeamMemberType.other
                        default:
                            return TrustedNonTeamMemberType.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Enabled/disabled option for members to link personal Dropbox account and team account to same computer.
    open class TwoAccountChangePolicyDetails: CustomStringConvertible {
        /// New two account policy.
        public let newValue: TeamLog.TwoAccountPolicy
        /// Previous two account policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.TwoAccountPolicy?
        public init(newValue: TeamLog.TwoAccountPolicy, previousValue: TeamLog.TwoAccountPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TwoAccountChangePolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class TwoAccountChangePolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TwoAccountChangePolicyDetails) -> JSON {
            let output = [ 
            "new_value": TeamLog.TwoAccountPolicySerializer().serialize(value.newValue),
            "previous_value": NullableSerializer(TeamLog.TwoAccountPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TwoAccountChangePolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = TeamLog.TwoAccountPolicySerializer().deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(TeamLog.TwoAccountPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                    return TwoAccountChangePolicyDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The TwoAccountChangePolicyType struct
    open class TwoAccountChangePolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TwoAccountChangePolicyTypeSerializer().serialize(self)))"
        }
    }
    open class TwoAccountChangePolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TwoAccountChangePolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TwoAccountChangePolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return TwoAccountChangePolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Policy for pairing personal account to work account
    public enum TwoAccountPolicy: CustomStringConvertible {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TwoAccountPolicySerializer().serialize(self)))"
        }
    }
    open class TwoAccountPolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TwoAccountPolicy) -> JSON {
            switch value {
                case .disabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disabled")
                    return .dictionary(d)
                case .enabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("enabled")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> TwoAccountPolicy {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "disabled":
                            return TwoAccountPolicy.disabled
                        case "enabled":
                            return TwoAccountPolicy.enabled
                        case "other":
                            return TwoAccountPolicy.other
                        default:
                            return TwoAccountPolicy.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// User linked app
    open class UserLinkedAppLogInfo: TeamLog.AppLogInfo {
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UserLinkedAppLogInfoSerializer().serialize(self)))"
        }
    }
    open class UserLinkedAppLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UserLinkedAppLogInfo) -> JSON {
            let output = [ 
            "app_id": NullableSerializer(Serialization._StringSerializer).serialize(value.appId),
            "display_name": NullableSerializer(Serialization._StringSerializer).serialize(value.displayName),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UserLinkedAppLogInfo {
            switch json {
                case .dictionary(let dict):
                    let appId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["app_id"] ?? .null)
                    let displayName = NullableSerializer(Serialization._StringSerializer).deserialize(dict["display_name"] ?? .null)
                    return UserLinkedAppLogInfo(appId: appId, displayName: displayName)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// User's name logged information
    open class UserNameLogInfo: CustomStringConvertible {
        /// Given name.
        public let givenName: String
        /// Surname.
        public let surname: String
        /// Locale. Might be missing due to historical data gap.
        public let locale: String?
        public init(givenName: String, surname: String, locale: String? = nil) {
            stringValidator()(givenName)
            self.givenName = givenName
            stringValidator()(surname)
            self.surname = surname
            nullableValidator(stringValidator())(locale)
            self.locale = locale
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UserNameLogInfoSerializer().serialize(self)))"
        }
    }
    open class UserNameLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UserNameLogInfo) -> JSON {
            let output = [ 
            "given_name": Serialization._StringSerializer.serialize(value.givenName),
            "surname": Serialization._StringSerializer.serialize(value.surname),
            "locale": NullableSerializer(Serialization._StringSerializer).serialize(value.locale),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UserNameLogInfo {
            switch json {
                case .dictionary(let dict):
                    let givenName = Serialization._StringSerializer.deserialize(dict["given_name"] ?? .null)
                    let surname = Serialization._StringSerializer.deserialize(dict["surname"] ?? .null)
                    let locale = NullableSerializer(Serialization._StringSerializer).deserialize(dict["locale"] ?? .null)
                    return UserNameLogInfo(givenName: givenName, surname: surname, locale: locale)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// User or team linked app. Used when linked type is missing due to historical data gap.
    open class UserOrTeamLinkedAppLogInfo: TeamLog.AppLogInfo {
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UserOrTeamLinkedAppLogInfoSerializer().serialize(self)))"
        }
    }
    open class UserOrTeamLinkedAppLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UserOrTeamLinkedAppLogInfo) -> JSON {
            let output = [ 
            "app_id": NullableSerializer(Serialization._StringSerializer).serialize(value.appId),
            "display_name": NullableSerializer(Serialization._StringSerializer).serialize(value.displayName),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UserOrTeamLinkedAppLogInfo {
            switch json {
                case .dictionary(let dict):
                    let appId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["app_id"] ?? .null)
                    let displayName = NullableSerializer(Serialization._StringSerializer).deserialize(dict["display_name"] ?? .null)
                    return UserOrTeamLinkedAppLogInfo(appId: appId, displayName: displayName)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed team policy for viewer info.
    open class ViewerInfoPolicyChangedDetails: CustomStringConvertible {
        /// Previous Viewer Info policy.
        public let previousValue: TeamLog.PassPolicy
        /// New Viewer Info policy.
        public let newValue: TeamLog.PassPolicy
        public init(previousValue: TeamLog.PassPolicy, newValue: TeamLog.PassPolicy) {
            self.previousValue = previousValue
            self.newValue = newValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ViewerInfoPolicyChangedDetailsSerializer().serialize(self)))"
        }
    }
    open class ViewerInfoPolicyChangedDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ViewerInfoPolicyChangedDetails) -> JSON {
            let output = [ 
            "previous_value": TeamLog.PassPolicySerializer().serialize(value.previousValue),
            "new_value": TeamLog.PassPolicySerializer().serialize(value.newValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ViewerInfoPolicyChangedDetails {
            switch json {
                case .dictionary(let dict):
                    let previousValue = TeamLog.PassPolicySerializer().deserialize(dict["previous_value"] ?? .null)
                    let newValue = TeamLog.PassPolicySerializer().deserialize(dict["new_value"] ?? .null)
                    return ViewerInfoPolicyChangedDetails(previousValue: previousValue, newValue: newValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ViewerInfoPolicyChangedType struct
    open class ViewerInfoPolicyChangedType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ViewerInfoPolicyChangedTypeSerializer().serialize(self)))"
        }
    }
    open class ViewerInfoPolicyChangedTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ViewerInfoPolicyChangedType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ViewerInfoPolicyChangedType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return ViewerInfoPolicyChangedType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Information on active web sessions
    open class WebDeviceSessionLogInfo: TeamLog.DeviceSessionLogInfo {
        /// Web session unique id. Might be missing due to historical data gap.
        public let sessionInfo: TeamLog.WebSessionLogInfo?
        /// Information on the hosting device.
        public let userAgent: String
        /// Information on the hosting operating system.
        public let os: String
        /// Information on the browser used for this web session.
        public let browser: String
        public init(userAgent: String, os: String, browser: String, ipAddress: String? = nil, created: Date? = nil, updated: Date? = nil, sessionInfo: TeamLog.WebSessionLogInfo? = nil) {
            self.sessionInfo = sessionInfo
            stringValidator()(userAgent)
            self.userAgent = userAgent
            stringValidator()(os)
            self.os = os
            stringValidator()(browser)
            self.browser = browser
            super.init(ipAddress: ipAddress, created: created, updated: updated)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(WebDeviceSessionLogInfoSerializer().serialize(self)))"
        }
    }
    open class WebDeviceSessionLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: WebDeviceSessionLogInfo) -> JSON {
            let output = [ 
            "user_agent": Serialization._StringSerializer.serialize(value.userAgent),
            "os": Serialization._StringSerializer.serialize(value.os),
            "browser": Serialization._StringSerializer.serialize(value.browser),
            "ip_address": NullableSerializer(Serialization._StringSerializer).serialize(value.ipAddress),
            "created": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.created),
            "updated": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.updated),
            "session_info": NullableSerializer(TeamLog.WebSessionLogInfoSerializer()).serialize(value.sessionInfo),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> WebDeviceSessionLogInfo {
            switch json {
                case .dictionary(let dict):
                    let userAgent = Serialization._StringSerializer.deserialize(dict["user_agent"] ?? .null)
                    let os = Serialization._StringSerializer.deserialize(dict["os"] ?? .null)
                    let browser = Serialization._StringSerializer.deserialize(dict["browser"] ?? .null)
                    let ipAddress = NullableSerializer(Serialization._StringSerializer).deserialize(dict["ip_address"] ?? .null)
                    let created = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["created"] ?? .null)
                    let updated = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["updated"] ?? .null)
                    let sessionInfo = NullableSerializer(TeamLog.WebSessionLogInfoSerializer()).deserialize(dict["session_info"] ?? .null)
                    return WebDeviceSessionLogInfo(userAgent: userAgent, os: os, browser: browser, ipAddress: ipAddress, created: created, updated: updated, sessionInfo: sessionInfo)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Web session.
    open class WebSessionLogInfo: TeamLog.SessionLogInfo {
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(WebSessionLogInfoSerializer().serialize(self)))"
        }
    }
    open class WebSessionLogInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: WebSessionLogInfo) -> JSON {
            let output = [ 
            "session_id": NullableSerializer(Serialization._StringSerializer).serialize(value.sessionId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> WebSessionLogInfo {
            switch json {
                case .dictionary(let dict):
                    let sessionId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["session_id"] ?? .null)
                    return WebSessionLogInfo(sessionId: sessionId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed how long members can stay signed in to Dropbox.com.
    open class WebSessionsChangeFixedLengthPolicyDetails: CustomStringConvertible {
        /// New session length policy. Might be missing due to historical data gap.
        public let newValue: TeamLog.WebSessionsFixedLengthPolicy?
        /// Previous session length policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.WebSessionsFixedLengthPolicy?
        public init(newValue: TeamLog.WebSessionsFixedLengthPolicy? = nil, previousValue: TeamLog.WebSessionsFixedLengthPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(WebSessionsChangeFixedLengthPolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class WebSessionsChangeFixedLengthPolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: WebSessionsChangeFixedLengthPolicyDetails) -> JSON {
            let output = [ 
            "new_value": NullableSerializer(TeamLog.WebSessionsFixedLengthPolicySerializer()).serialize(value.newValue),
            "previous_value": NullableSerializer(TeamLog.WebSessionsFixedLengthPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> WebSessionsChangeFixedLengthPolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = NullableSerializer(TeamLog.WebSessionsFixedLengthPolicySerializer()).deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(TeamLog.WebSessionsFixedLengthPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                    return WebSessionsChangeFixedLengthPolicyDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The WebSessionsChangeFixedLengthPolicyType struct
    open class WebSessionsChangeFixedLengthPolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(WebSessionsChangeFixedLengthPolicyTypeSerializer().serialize(self)))"
        }
    }
    open class WebSessionsChangeFixedLengthPolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: WebSessionsChangeFixedLengthPolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> WebSessionsChangeFixedLengthPolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return WebSessionsChangeFixedLengthPolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Changed how long team members can be idle while signed in to Dropbox.com.
    open class WebSessionsChangeIdleLengthPolicyDetails: CustomStringConvertible {
        /// New idle length policy. Might be missing due to historical data gap.
        public let newValue: TeamLog.WebSessionsIdleLengthPolicy?
        /// Previous idle length policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.WebSessionsIdleLengthPolicy?
        public init(newValue: TeamLog.WebSessionsIdleLengthPolicy? = nil, previousValue: TeamLog.WebSessionsIdleLengthPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(WebSessionsChangeIdleLengthPolicyDetailsSerializer().serialize(self)))"
        }
    }
    open class WebSessionsChangeIdleLengthPolicyDetailsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: WebSessionsChangeIdleLengthPolicyDetails) -> JSON {
            let output = [ 
            "new_value": NullableSerializer(TeamLog.WebSessionsIdleLengthPolicySerializer()).serialize(value.newValue),
            "previous_value": NullableSerializer(TeamLog.WebSessionsIdleLengthPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> WebSessionsChangeIdleLengthPolicyDetails {
            switch json {
                case .dictionary(let dict):
                    let newValue = NullableSerializer(TeamLog.WebSessionsIdleLengthPolicySerializer()).deserialize(dict["new_value"] ?? .null)
                    let previousValue = NullableSerializer(TeamLog.WebSessionsIdleLengthPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                    return WebSessionsChangeIdleLengthPolicyDetails(newValue: newValue, previousValue: previousValue)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The WebSessionsChangeIdleLengthPolicyType struct
    open class WebSessionsChangeIdleLengthPolicyType: CustomStringConvertible {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(WebSessionsChangeIdleLengthPolicyTypeSerializer().serialize(self)))"
        }
    }
    open class WebSessionsChangeIdleLengthPolicyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: WebSessionsChangeIdleLengthPolicyType) -> JSON {
            let output = [ 
            "description": Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> WebSessionsChangeIdleLengthPolicyType {
            switch json {
                case .dictionary(let dict):
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    return WebSessionsChangeIdleLengthPolicyType(description_: description_)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Web sessions fixed length policy.
    public enum WebSessionsFixedLengthPolicy: CustomStringConvertible {
        /// Defined fixed session length.
        case defined(TeamLog.DurationLogInfo)
        /// Undefined fixed session length.
        case undefined
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(WebSessionsFixedLengthPolicySerializer().serialize(self)))"
        }
    }
    open class WebSessionsFixedLengthPolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: WebSessionsFixedLengthPolicy) -> JSON {
            switch value {
                case .defined(let arg):
                    var d = Serialization.getFields(TeamLog.DurationLogInfoSerializer().serialize(arg))
                    d[".tag"] = .str("defined")
                    return .dictionary(d)
                case .undefined:
                    var d = [String: JSON]()
                    d[".tag"] = .str("undefined")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> WebSessionsFixedLengthPolicy {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "defined":
                            let v = TeamLog.DurationLogInfoSerializer().deserialize(json)
                            return WebSessionsFixedLengthPolicy.defined(v)
                        case "undefined":
                            return WebSessionsFixedLengthPolicy.undefined
                        case "other":
                            return WebSessionsFixedLengthPolicy.other
                        default:
                            return WebSessionsFixedLengthPolicy.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Web sessions idle length policy.
    public enum WebSessionsIdleLengthPolicy: CustomStringConvertible {
        /// Defined idle session length.
        case defined(TeamLog.DurationLogInfo)
        /// Undefined idle session length.
        case undefined
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(WebSessionsIdleLengthPolicySerializer().serialize(self)))"
        }
    }
    open class WebSessionsIdleLengthPolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: WebSessionsIdleLengthPolicy) -> JSON {
            switch value {
                case .defined(let arg):
                    var d = Serialization.getFields(TeamLog.DurationLogInfoSerializer().serialize(arg))
                    d[".tag"] = .str("defined")
                    return .dictionary(d)
                case .undefined:
                    var d = [String: JSON]()
                    d[".tag"] = .str("undefined")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> WebSessionsIdleLengthPolicy {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "defined":
                            let v = TeamLog.DurationLogInfoSerializer().deserialize(json)
                            return WebSessionsIdleLengthPolicy.defined(v)
                        case "undefined":
                            return WebSessionsIdleLengthPolicy.undefined
                        case "other":
                            return WebSessionsIdleLengthPolicy.other
                        default:
                            return WebSessionsIdleLengthPolicy.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }


    /// Stone Route Objects

    static let getEvents = Route(
        name: "get_events",
        version: 1,
        namespace: "team_log",
        deprecated: false,
        argSerializer: TeamLog.GetTeamEventsArgSerializer(),
        responseSerializer: TeamLog.GetTeamEventsResultSerializer(),
        errorSerializer: TeamLog.GetTeamEventsErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let getEventsContinue = Route(
        name: "get_events/continue",
        version: 1,
        namespace: "team_log",
        deprecated: false,
        argSerializer: TeamLog.GetTeamEventsContinueArgSerializer(),
        responseSerializer: TeamLog.GetTeamEventsResultSerializer(),
        errorSerializer: TeamLog.GetTeamEventsContinueErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
}
