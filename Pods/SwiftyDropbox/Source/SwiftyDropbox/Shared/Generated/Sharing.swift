///
/// Copyright (c) 2016 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

import Foundation

/// Datatypes and serializers for the sharing namespace
open class Sharing {
    /// Information about the inheritance policy of a shared folder.
    public enum AccessInheritance: CustomStringConvertible {
        /// The shared folder inherits its members from the parent folder.
        case inherit
        /// The shared folder does not inherit its members from the parent folder.
        case noInherit
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AccessInheritanceSerializer().serialize(self)))"
        }
    }
    open class AccessInheritanceSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AccessInheritance) -> JSON {
            switch value {
                case .inherit:
                    var d = [String: JSON]()
                    d[".tag"] = .str("inherit")
                    return .dictionary(d)
                case .noInherit:
                    var d = [String: JSON]()
                    d[".tag"] = .str("no_inherit")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> AccessInheritance {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "inherit":
                            return AccessInheritance.inherit
                        case "no_inherit":
                            return AccessInheritance.noInherit
                        case "other":
                            return AccessInheritance.other
                        default:
                            return AccessInheritance.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Defines the access levels for collaborators.
    public enum AccessLevel: CustomStringConvertible {
        /// The collaborator is the owner of the shared folder. Owners can view and edit the shared folder as well as
        /// set the folder's policies using updateFolderPolicy.
        case owner
        /// The collaborator can both view and edit the shared folder.
        case editor
        /// The collaborator can only view the shared folder.
        case viewer
        /// The collaborator can only view the shared folder and does not have any access to comments.
        case viewerNoComment
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AccessLevelSerializer().serialize(self)))"
        }
    }
    open class AccessLevelSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AccessLevel) -> JSON {
            switch value {
                case .owner:
                    var d = [String: JSON]()
                    d[".tag"] = .str("owner")
                    return .dictionary(d)
                case .editor:
                    var d = [String: JSON]()
                    d[".tag"] = .str("editor")
                    return .dictionary(d)
                case .viewer:
                    var d = [String: JSON]()
                    d[".tag"] = .str("viewer")
                    return .dictionary(d)
                case .viewerNoComment:
                    var d = [String: JSON]()
                    d[".tag"] = .str("viewer_no_comment")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> AccessLevel {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "owner":
                            return AccessLevel.owner
                        case "editor":
                            return AccessLevel.editor
                        case "viewer":
                            return AccessLevel.viewer
                        case "viewer_no_comment":
                            return AccessLevel.viewerNoComment
                        case "other":
                            return AccessLevel.other
                        default:
                            return AccessLevel.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Who can change a shared folder's access control list (ACL). In other words, who can add, remove, or change the
    /// privileges of members.
    public enum AclUpdatePolicy: CustomStringConvertible {
        /// Only the owner can update the ACL.
        case owner
        /// Any editor can update the ACL. This may be further restricted to editors on the same team.
        case editors
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AclUpdatePolicySerializer().serialize(self)))"
        }
    }
    open class AclUpdatePolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AclUpdatePolicy) -> JSON {
            switch value {
                case .owner:
                    var d = [String: JSON]()
                    d[".tag"] = .str("owner")
                    return .dictionary(d)
                case .editors:
                    var d = [String: JSON]()
                    d[".tag"] = .str("editors")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> AclUpdatePolicy {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "owner":
                            return AclUpdatePolicy.owner
                        case "editors":
                            return AclUpdatePolicy.editors
                        case "other":
                            return AclUpdatePolicy.other
                        default:
                            return AclUpdatePolicy.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Arguments for addFileMember.
    open class AddFileMemberArgs: CustomStringConvertible {
        /// File to which to add members.
        public let file: String
        /// Members to add. Note that even an email address is given, this may result in a user being directy added to
        /// the membership if that email is the user's main account email.
        public let members: Array<Sharing.MemberSelector>
        /// Message to send to added members in their invitation.
        public let customMessage: String?
        /// Whether added members should be notified via device notifications of their invitation.
        public let quiet: Bool
        /// AccessLevel union object, describing what access level we want to give new members.
        public let accessLevel: Sharing.AccessLevel
        /// If the custom message should be added as a comment on the file.
        public let addMessageAsComment: Bool
        public init(file: String, members: Array<Sharing.MemberSelector>, customMessage: String? = nil, quiet: Bool = false, accessLevel: Sharing.AccessLevel = .viewer, addMessageAsComment: Bool = false) {
            stringValidator(minLength: 1, pattern: "((/|id:).*|nspath:[0-9]+:.*)|ns:[0-9]+(/.*)?")(file)
            self.file = file
            self.members = members
            nullableValidator(stringValidator())(customMessage)
            self.customMessage = customMessage
            self.quiet = quiet
            self.accessLevel = accessLevel
            self.addMessageAsComment = addMessageAsComment
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AddFileMemberArgsSerializer().serialize(self)))"
        }
    }
    open class AddFileMemberArgsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AddFileMemberArgs) -> JSON {
            let output = [ 
            "file": Serialization._StringSerializer.serialize(value.file),
            "members": ArraySerializer(Sharing.MemberSelectorSerializer()).serialize(value.members),
            "custom_message": NullableSerializer(Serialization._StringSerializer).serialize(value.customMessage),
            "quiet": Serialization._BoolSerializer.serialize(value.quiet),
            "access_level": Sharing.AccessLevelSerializer().serialize(value.accessLevel),
            "add_message_as_comment": Serialization._BoolSerializer.serialize(value.addMessageAsComment),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> AddFileMemberArgs {
            switch json {
                case .dictionary(let dict):
                    let file = Serialization._StringSerializer.deserialize(dict["file"] ?? .null)
                    let members = ArraySerializer(Sharing.MemberSelectorSerializer()).deserialize(dict["members"] ?? .null)
                    let customMessage = NullableSerializer(Serialization._StringSerializer).deserialize(dict["custom_message"] ?? .null)
                    let quiet = Serialization._BoolSerializer.deserialize(dict["quiet"] ?? .number(0))
                    let accessLevel = Sharing.AccessLevelSerializer().deserialize(dict["access_level"] ?? Sharing.AccessLevelSerializer().serialize(.viewer))
                    let addMessageAsComment = Serialization._BoolSerializer.deserialize(dict["add_message_as_comment"] ?? .number(0))
                    return AddFileMemberArgs(file: file, members: members, customMessage: customMessage, quiet: quiet, accessLevel: accessLevel, addMessageAsComment: addMessageAsComment)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Errors for addFileMember.
    public enum AddFileMemberError: CustomStringConvertible {
        /// An unspecified error.
        case userError(Sharing.SharingUserError)
        /// An unspecified error.
        case accessError(Sharing.SharingFileAccessError)
        /// The user has reached the rate limit for invitations.
        case rateLimit
        /// The custom message did not pass comment permissions checks.
        case invalidComment
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AddFileMemberErrorSerializer().serialize(self)))"
        }
    }
    open class AddFileMemberErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AddFileMemberError) -> JSON {
            switch value {
                case .userError(let arg):
                    var d = ["user_error": Sharing.SharingUserErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("user_error")
                    return .dictionary(d)
                case .accessError(let arg):
                    var d = ["access_error": Sharing.SharingFileAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("access_error")
                    return .dictionary(d)
                case .rateLimit:
                    var d = [String: JSON]()
                    d[".tag"] = .str("rate_limit")
                    return .dictionary(d)
                case .invalidComment:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_comment")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> AddFileMemberError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "user_error":
                            let v = Sharing.SharingUserErrorSerializer().deserialize(d["user_error"] ?? .null)
                            return AddFileMemberError.userError(v)
                        case "access_error":
                            let v = Sharing.SharingFileAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                            return AddFileMemberError.accessError(v)
                        case "rate_limit":
                            return AddFileMemberError.rateLimit
                        case "invalid_comment":
                            return AddFileMemberError.invalidComment
                        case "other":
                            return AddFileMemberError.other
                        default:
                            return AddFileMemberError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The AddFolderMemberArg struct
    open class AddFolderMemberArg: CustomStringConvertible {
        /// The ID for the shared folder.
        public let sharedFolderId: String
        /// The intended list of members to add.  Added members will receive invites to join the shared folder.
        public let members: Array<Sharing.AddMember>
        /// Whether added members should be notified via email and device notifications of their invite.
        public let quiet: Bool
        /// Optional message to display to added members in their invitation.
        public let customMessage: String?
        public init(sharedFolderId: String, members: Array<Sharing.AddMember>, quiet: Bool = false, customMessage: String? = nil) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.members = members
            self.quiet = quiet
            nullableValidator(stringValidator(minLength: 1))(customMessage)
            self.customMessage = customMessage
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AddFolderMemberArgSerializer().serialize(self)))"
        }
    }
    open class AddFolderMemberArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AddFolderMemberArg) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            "members": ArraySerializer(Sharing.AddMemberSerializer()).serialize(value.members),
            "quiet": Serialization._BoolSerializer.serialize(value.quiet),
            "custom_message": NullableSerializer(Serialization._StringSerializer).serialize(value.customMessage),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> AddFolderMemberArg {
            switch json {
                case .dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                    let members = ArraySerializer(Sharing.AddMemberSerializer()).deserialize(dict["members"] ?? .null)
                    let quiet = Serialization._BoolSerializer.deserialize(dict["quiet"] ?? .number(0))
                    let customMessage = NullableSerializer(Serialization._StringSerializer).deserialize(dict["custom_message"] ?? .null)
                    return AddFolderMemberArg(sharedFolderId: sharedFolderId, members: members, quiet: quiet, customMessage: customMessage)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The AddFolderMemberError union
    public enum AddFolderMemberError: CustomStringConvertible {
        /// Unable to access shared folder.
        case accessError(Sharing.SharedFolderAccessError)
        /// The current user's e-mail address is unverified.
        case emailUnverified
        /// members in AddFolderMemberArg contains a bad invitation recipient.
        case badMember(Sharing.AddMemberSelectorError)
        /// Your team policy does not allow sharing outside of the team.
        case cantShareOutsideTeam
        /// The value is the member limit that was reached.
        case tooManyMembers(UInt64)
        /// The value is the pending invite limit that was reached.
        case tooManyPendingInvites(UInt64)
        /// The current user has hit the limit of invites they can send per day. Try again in 24 hours.
        case rateLimit
        /// The current user is trying to share with too many people at once.
        case tooManyInvitees
        /// The current user's account doesn't support this action. An example of this is when adding a read-only
        /// member. This action can only be performed by users that have upgraded to a Pro or Business plan.
        case insufficientPlan
        /// This action cannot be performed on a team shared folder.
        case teamFolder
        /// The current user does not have permission to perform this action.
        case noPermission
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AddFolderMemberErrorSerializer().serialize(self)))"
        }
    }
    open class AddFolderMemberErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AddFolderMemberError) -> JSON {
            switch value {
                case .accessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("access_error")
                    return .dictionary(d)
                case .emailUnverified:
                    var d = [String: JSON]()
                    d[".tag"] = .str("email_unverified")
                    return .dictionary(d)
                case .badMember(let arg):
                    var d = ["bad_member": Sharing.AddMemberSelectorErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("bad_member")
                    return .dictionary(d)
                case .cantShareOutsideTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .str("cant_share_outside_team")
                    return .dictionary(d)
                case .tooManyMembers(let arg):
                    var d = ["too_many_members": Serialization._UInt64Serializer.serialize(arg)]
                    d[".tag"] = .str("too_many_members")
                    return .dictionary(d)
                case .tooManyPendingInvites(let arg):
                    var d = ["too_many_pending_invites": Serialization._UInt64Serializer.serialize(arg)]
                    d[".tag"] = .str("too_many_pending_invites")
                    return .dictionary(d)
                case .rateLimit:
                    var d = [String: JSON]()
                    d[".tag"] = .str("rate_limit")
                    return .dictionary(d)
                case .tooManyInvitees:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_invitees")
                    return .dictionary(d)
                case .insufficientPlan:
                    var d = [String: JSON]()
                    d[".tag"] = .str("insufficient_plan")
                    return .dictionary(d)
                case .teamFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("team_folder")
                    return .dictionary(d)
                case .noPermission:
                    var d = [String: JSON]()
                    d[".tag"] = .str("no_permission")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> AddFolderMemberError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                            return AddFolderMemberError.accessError(v)
                        case "email_unverified":
                            return AddFolderMemberError.emailUnverified
                        case "bad_member":
                            let v = Sharing.AddMemberSelectorErrorSerializer().deserialize(d["bad_member"] ?? .null)
                            return AddFolderMemberError.badMember(v)
                        case "cant_share_outside_team":
                            return AddFolderMemberError.cantShareOutsideTeam
                        case "too_many_members":
                            let v = Serialization._UInt64Serializer.deserialize(d["too_many_members"] ?? .null)
                            return AddFolderMemberError.tooManyMembers(v)
                        case "too_many_pending_invites":
                            let v = Serialization._UInt64Serializer.deserialize(d["too_many_pending_invites"] ?? .null)
                            return AddFolderMemberError.tooManyPendingInvites(v)
                        case "rate_limit":
                            return AddFolderMemberError.rateLimit
                        case "too_many_invitees":
                            return AddFolderMemberError.tooManyInvitees
                        case "insufficient_plan":
                            return AddFolderMemberError.insufficientPlan
                        case "team_folder":
                            return AddFolderMemberError.teamFolder
                        case "no_permission":
                            return AddFolderMemberError.noPermission
                        case "other":
                            return AddFolderMemberError.other
                        default:
                            return AddFolderMemberError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The member and type of access the member should have when added to a shared folder.
    open class AddMember: CustomStringConvertible {
        /// The member to add to the shared folder.
        public let member: Sharing.MemberSelector
        /// The access level to grant member to the shared folder.  owner in AccessLevel is disallowed.
        public let accessLevel: Sharing.AccessLevel
        public init(member: Sharing.MemberSelector, accessLevel: Sharing.AccessLevel = .viewer) {
            self.member = member
            self.accessLevel = accessLevel
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AddMemberSerializer().serialize(self)))"
        }
    }
    open class AddMemberSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AddMember) -> JSON {
            let output = [ 
            "member": Sharing.MemberSelectorSerializer().serialize(value.member),
            "access_level": Sharing.AccessLevelSerializer().serialize(value.accessLevel),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> AddMember {
            switch json {
                case .dictionary(let dict):
                    let member = Sharing.MemberSelectorSerializer().deserialize(dict["member"] ?? .null)
                    let accessLevel = Sharing.AccessLevelSerializer().deserialize(dict["access_level"] ?? Sharing.AccessLevelSerializer().serialize(.viewer))
                    return AddMember(member: member, accessLevel: accessLevel)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The AddMemberSelectorError union
    public enum AddMemberSelectorError: CustomStringConvertible {
        /// Automatically created groups can only be added to team folders.
        case automaticGroup
        /// The value is the ID that could not be identified.
        case invalidDropboxId(String)
        /// The value is the e-email address that is malformed.
        case invalidEmail(String)
        /// The value is the ID of the Dropbox user with an unverified e-mail address.  Invite unverified users by
        /// e-mail address instead of by their Dropbox ID.
        case unverifiedDropboxId(String)
        /// At least one of the specified groups in members in AddFolderMemberArg is deleted.
        case groupDeleted
        /// Sharing to a group that is not on the current user's team.
        case groupNotOnTeam
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AddMemberSelectorErrorSerializer().serialize(self)))"
        }
    }
    open class AddMemberSelectorErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AddMemberSelectorError) -> JSON {
            switch value {
                case .automaticGroup:
                    var d = [String: JSON]()
                    d[".tag"] = .str("automatic_group")
                    return .dictionary(d)
                case .invalidDropboxId(let arg):
                    var d = ["invalid_dropbox_id": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("invalid_dropbox_id")
                    return .dictionary(d)
                case .invalidEmail(let arg):
                    var d = ["invalid_email": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("invalid_email")
                    return .dictionary(d)
                case .unverifiedDropboxId(let arg):
                    var d = ["unverified_dropbox_id": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("unverified_dropbox_id")
                    return .dictionary(d)
                case .groupDeleted:
                    var d = [String: JSON]()
                    d[".tag"] = .str("group_deleted")
                    return .dictionary(d)
                case .groupNotOnTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .str("group_not_on_team")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> AddMemberSelectorError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "automatic_group":
                            return AddMemberSelectorError.automaticGroup
                        case "invalid_dropbox_id":
                            let v = Serialization._StringSerializer.deserialize(d["invalid_dropbox_id"] ?? .null)
                            return AddMemberSelectorError.invalidDropboxId(v)
                        case "invalid_email":
                            let v = Serialization._StringSerializer.deserialize(d["invalid_email"] ?? .null)
                            return AddMemberSelectorError.invalidEmail(v)
                        case "unverified_dropbox_id":
                            let v = Serialization._StringSerializer.deserialize(d["unverified_dropbox_id"] ?? .null)
                            return AddMemberSelectorError.unverifiedDropboxId(v)
                        case "group_deleted":
                            return AddMemberSelectorError.groupDeleted
                        case "group_not_on_team":
                            return AddMemberSelectorError.groupNotOnTeam
                        case "other":
                            return AddMemberSelectorError.other
                        default:
                            return AddMemberSelectorError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Information about the content that has a link audience different than that of this folder.
    open class AudienceExceptionContentInfo: CustomStringConvertible {
        /// The name of the content, which is either a file or a folder.
        public let name: String
        public init(name: String) {
            stringValidator()(name)
            self.name = name
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AudienceExceptionContentInfoSerializer().serialize(self)))"
        }
    }
    open class AudienceExceptionContentInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AudienceExceptionContentInfo) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> AudienceExceptionContentInfo {
            switch json {
                case .dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                    return AudienceExceptionContentInfo(name: name)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The total count and truncated list of information of content inside this folder that has a different audience
    /// than the link on this folder. This is only returned for folders.
    open class AudienceExceptions: CustomStringConvertible {
        /// (no description)
        public let count: UInt32
        /// A truncated list of some of the content that is an exception. The length of this list could be smaller than
        /// the count since it is only a sample but will not be empty as long as count is not 0.
        public let exceptions: Array<Sharing.AudienceExceptionContentInfo>
        public init(count: UInt32, exceptions: Array<Sharing.AudienceExceptionContentInfo>) {
            comparableValidator()(count)
            self.count = count
            self.exceptions = exceptions
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AudienceExceptionsSerializer().serialize(self)))"
        }
    }
    open class AudienceExceptionsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AudienceExceptions) -> JSON {
            let output = [ 
            "count": Serialization._UInt32Serializer.serialize(value.count),
            "exceptions": ArraySerializer(Sharing.AudienceExceptionContentInfoSerializer()).serialize(value.exceptions),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> AudienceExceptions {
            switch json {
                case .dictionary(let dict):
                    let count = Serialization._UInt32Serializer.deserialize(dict["count"] ?? .null)
                    let exceptions = ArraySerializer(Sharing.AudienceExceptionContentInfoSerializer()).deserialize(dict["exceptions"] ?? .null)
                    return AudienceExceptions(count: count, exceptions: exceptions)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Information about the shared folder that prevents the link audience for this link from being more restrictive.
    open class AudienceRestrictingSharedFolder: CustomStringConvertible {
        /// The ID of the shared folder.
        public let sharedFolderId: String
        /// The name of the shared folder.
        public let name: String
        /// The link audience of the shared folder.
        public let audience: Sharing.LinkAudience
        public init(sharedFolderId: String, name: String, audience: Sharing.LinkAudience) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            stringValidator()(name)
            self.name = name
            self.audience = audience
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AudienceRestrictingSharedFolderSerializer().serialize(self)))"
        }
    }
    open class AudienceRestrictingSharedFolderSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AudienceRestrictingSharedFolder) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            "name": Serialization._StringSerializer.serialize(value.name),
            "audience": Sharing.LinkAudienceSerializer().serialize(value.audience),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> AudienceRestrictingSharedFolder {
            switch json {
                case .dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                    let audience = Sharing.LinkAudienceSerializer().deserialize(dict["audience"] ?? .null)
                    return AudienceRestrictingSharedFolder(sharedFolderId: sharedFolderId, name: name, audience: audience)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Arguments for changeFileMemberAccess.
    open class ChangeFileMemberAccessArgs: CustomStringConvertible {
        /// File for which we are changing a member's access.
        public let file: String
        /// The member whose access we are changing.
        public let member: Sharing.MemberSelector
        /// The new access level for the member.
        public let accessLevel: Sharing.AccessLevel
        public init(file: String, member: Sharing.MemberSelector, accessLevel: Sharing.AccessLevel) {
            stringValidator(minLength: 1, pattern: "((/|id:).*|nspath:[0-9]+:.*)|ns:[0-9]+(/.*)?")(file)
            self.file = file
            self.member = member
            self.accessLevel = accessLevel
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ChangeFileMemberAccessArgsSerializer().serialize(self)))"
        }
    }
    open class ChangeFileMemberAccessArgsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ChangeFileMemberAccessArgs) -> JSON {
            let output = [ 
            "file": Serialization._StringSerializer.serialize(value.file),
            "member": Sharing.MemberSelectorSerializer().serialize(value.member),
            "access_level": Sharing.AccessLevelSerializer().serialize(value.accessLevel),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ChangeFileMemberAccessArgs {
            switch json {
                case .dictionary(let dict):
                    let file = Serialization._StringSerializer.deserialize(dict["file"] ?? .null)
                    let member = Sharing.MemberSelectorSerializer().deserialize(dict["member"] ?? .null)
                    let accessLevel = Sharing.AccessLevelSerializer().deserialize(dict["access_level"] ?? .null)
                    return ChangeFileMemberAccessArgs(file: file, member: member, accessLevel: accessLevel)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Metadata for a shared link. This can be either a PathLinkMetadata or CollectionLinkMetadata.
    open class LinkMetadata: CustomStringConvertible {
        /// URL of the shared link.
        public let url: String
        /// Who can access the link.
        public let visibility: Sharing.Visibility
        /// Expiration time, if set. By default the link won't expire.
        public let expires: Date?
        public init(url: String, visibility: Sharing.Visibility, expires: Date? = nil) {
            stringValidator()(url)
            self.url = url
            self.visibility = visibility
            self.expires = expires
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(LinkMetadataSerializer().serialize(self)))"
        }
    }
    open class LinkMetadataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: LinkMetadata) -> JSON {
            var output = [ 
            "url": Serialization._StringSerializer.serialize(value.url),
            "visibility": Sharing.VisibilitySerializer().serialize(value.visibility),
            "expires": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.expires),
            ]
            switch value {
                case let path as Sharing.PathLinkMetadata:
                    for (k, v) in Serialization.getFields(Sharing.PathLinkMetadataSerializer().serialize(path)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("path")
                case let collection as Sharing.CollectionLinkMetadata:
                    for (k, v) in Serialization.getFields(Sharing.CollectionLinkMetadataSerializer().serialize(collection)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("collection")
                default: fatalError("Tried to serialize unexpected subtype")
            }
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> LinkMetadata {
            switch json {
                case .dictionary(let dict):
                    let tag = Serialization.getTag(dict)
                    switch tag {
                        case "path":
                            return Sharing.PathLinkMetadataSerializer().deserialize(json)
                        case "collection":
                            return Sharing.CollectionLinkMetadataSerializer().deserialize(json)
                        default:
                            let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .null)
                            let visibility = Sharing.VisibilitySerializer().deserialize(dict["visibility"] ?? .null)
                            let expires = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["expires"] ?? .null)
                            return LinkMetadata(url: url, visibility: visibility, expires: expires)
                    }
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Metadata for a collection-based shared link.
    open class CollectionLinkMetadata: Sharing.LinkMetadata {
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CollectionLinkMetadataSerializer().serialize(self)))"
        }
    }
    open class CollectionLinkMetadataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CollectionLinkMetadata) -> JSON {
            let output = [ 
            "url": Serialization._StringSerializer.serialize(value.url),
            "visibility": Sharing.VisibilitySerializer().serialize(value.visibility),
            "expires": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.expires),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> CollectionLinkMetadata {
            switch json {
                case .dictionary(let dict):
                    let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .null)
                    let visibility = Sharing.VisibilitySerializer().deserialize(dict["visibility"] ?? .null)
                    let expires = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["expires"] ?? .null)
                    return CollectionLinkMetadata(url: url, visibility: visibility, expires: expires)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The CreateSharedLinkArg struct
    open class CreateSharedLinkArg: CustomStringConvertible {
        /// The path to share.
        public let path: String
        /// Whether to return a shortened URL.
        public let shortUrl: Bool
        /// If it's okay to share a path that does not yet exist, set this to either file in PendingUploadMode or folder
        /// in PendingUploadMode to indicate whether to assume it's a file or folder.
        public let pendingUpload: Sharing.PendingUploadMode?
        public init(path: String, shortUrl: Bool = false, pendingUpload: Sharing.PendingUploadMode? = nil) {
            stringValidator()(path)
            self.path = path
            self.shortUrl = shortUrl
            self.pendingUpload = pendingUpload
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CreateSharedLinkArgSerializer().serialize(self)))"
        }
    }
    open class CreateSharedLinkArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CreateSharedLinkArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "short_url": Serialization._BoolSerializer.serialize(value.shortUrl),
            "pending_upload": NullableSerializer(Sharing.PendingUploadModeSerializer()).serialize(value.pendingUpload),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> CreateSharedLinkArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let shortUrl = Serialization._BoolSerializer.deserialize(dict["short_url"] ?? .number(0))
                    let pendingUpload = NullableSerializer(Sharing.PendingUploadModeSerializer()).deserialize(dict["pending_upload"] ?? .null)
                    return CreateSharedLinkArg(path: path, shortUrl: shortUrl, pendingUpload: pendingUpload)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The CreateSharedLinkError union
    public enum CreateSharedLinkError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.LookupError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CreateSharedLinkErrorSerializer().serialize(self)))"
        }
    }
    open class CreateSharedLinkErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CreateSharedLinkError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> CreateSharedLinkError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return CreateSharedLinkError.path(v)
                        case "other":
                            return CreateSharedLinkError.other
                        default:
                            return CreateSharedLinkError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The CreateSharedLinkWithSettingsArg struct
    open class CreateSharedLinkWithSettingsArg: CustomStringConvertible {
        /// The path to be shared by the shared link.
        public let path: String
        /// The requested settings for the newly created shared link.
        public let settings: Sharing.SharedLinkSettings?
        public init(path: String, settings: Sharing.SharedLinkSettings? = nil) {
            stringValidator(pattern: "(/(.|[\\r\\n])*|id:.*)|(rev:[0-9a-f]{9,})|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            self.settings = settings
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CreateSharedLinkWithSettingsArgSerializer().serialize(self)))"
        }
    }
    open class CreateSharedLinkWithSettingsArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CreateSharedLinkWithSettingsArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "settings": NullableSerializer(Sharing.SharedLinkSettingsSerializer()).serialize(value.settings),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> CreateSharedLinkWithSettingsArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let settings = NullableSerializer(Sharing.SharedLinkSettingsSerializer()).deserialize(dict["settings"] ?? .null)
                    return CreateSharedLinkWithSettingsArg(path: path, settings: settings)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The CreateSharedLinkWithSettingsError union
    public enum CreateSharedLinkWithSettingsError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.LookupError)
        /// User's email should be verified.
        case emailNotVerified
        /// The shared link already exists. You can call listSharedLinks to get the existing link.
        case sharedLinkAlreadyExists
        /// There is an error with the given settings.
        case settingsError(Sharing.SharedLinkSettingsError)
        /// Access to the requested path is forbidden.
        case accessDenied

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CreateSharedLinkWithSettingsErrorSerializer().serialize(self)))"
        }
    }
    open class CreateSharedLinkWithSettingsErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CreateSharedLinkWithSettingsError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .emailNotVerified:
                    var d = [String: JSON]()
                    d[".tag"] = .str("email_not_verified")
                    return .dictionary(d)
                case .sharedLinkAlreadyExists:
                    var d = [String: JSON]()
                    d[".tag"] = .str("shared_link_already_exists")
                    return .dictionary(d)
                case .settingsError(let arg):
                    var d = ["settings_error": Sharing.SharedLinkSettingsErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("settings_error")
                    return .dictionary(d)
                case .accessDenied:
                    var d = [String: JSON]()
                    d[".tag"] = .str("access_denied")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> CreateSharedLinkWithSettingsError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return CreateSharedLinkWithSettingsError.path(v)
                        case "email_not_verified":
                            return CreateSharedLinkWithSettingsError.emailNotVerified
                        case "shared_link_already_exists":
                            return CreateSharedLinkWithSettingsError.sharedLinkAlreadyExists
                        case "settings_error":
                            let v = Sharing.SharedLinkSettingsErrorSerializer().deserialize(d["settings_error"] ?? .null)
                            return CreateSharedLinkWithSettingsError.settingsError(v)
                        case "access_denied":
                            return CreateSharedLinkWithSettingsError.accessDenied
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The SharedContentLinkMetadataBase struct
    open class SharedContentLinkMetadataBase: CustomStringConvertible {
        /// The access level on the link for this file.
        public let accessLevel: Sharing.AccessLevel?
        /// The audience options that are available for the content. Some audience options may be unavailable. For
        /// example, team_only may be unavailable if the content is not owned by a user on a team. The 'default'
        /// audience option is always available if the user can modify link settings.
        public let audienceOptions: Array<Sharing.LinkAudience>
        /// The shared folder that prevents the link audience for this link from being more restrictive.
        public let audienceRestrictingSharedFolder: Sharing.AudienceRestrictingSharedFolder?
        /// The current audience of the link.
        public let currentAudience: Sharing.LinkAudience
        /// Whether the link has an expiry set on it. A link with an expiry will have its  audience changed to members
        /// when the expiry is reached.
        public let expiry: Date?
        /// A list of permissions for actions you can perform on the link.
        public let linkPermissions: Array<Sharing.LinkPermission>
        /// Whether the link is protected by a password.
        public let passwordProtected: Bool
        public init(audienceOptions: Array<Sharing.LinkAudience>, currentAudience: Sharing.LinkAudience, linkPermissions: Array<Sharing.LinkPermission>, passwordProtected: Bool, accessLevel: Sharing.AccessLevel? = nil, audienceRestrictingSharedFolder: Sharing.AudienceRestrictingSharedFolder? = nil, expiry: Date? = nil) {
            self.accessLevel = accessLevel
            self.audienceOptions = audienceOptions
            self.audienceRestrictingSharedFolder = audienceRestrictingSharedFolder
            self.currentAudience = currentAudience
            self.expiry = expiry
            self.linkPermissions = linkPermissions
            self.passwordProtected = passwordProtected
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentLinkMetadataBaseSerializer().serialize(self)))"
        }
    }
    open class SharedContentLinkMetadataBaseSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentLinkMetadataBase) -> JSON {
            let output = [ 
            "audience_options": ArraySerializer(Sharing.LinkAudienceSerializer()).serialize(value.audienceOptions),
            "current_audience": Sharing.LinkAudienceSerializer().serialize(value.currentAudience),
            "link_permissions": ArraySerializer(Sharing.LinkPermissionSerializer()).serialize(value.linkPermissions),
            "password_protected": Serialization._BoolSerializer.serialize(value.passwordProtected),
            "access_level": NullableSerializer(Sharing.AccessLevelSerializer()).serialize(value.accessLevel),
            "audience_restricting_shared_folder": NullableSerializer(Sharing.AudienceRestrictingSharedFolderSerializer()).serialize(value.audienceRestrictingSharedFolder),
            "expiry": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.expiry),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentLinkMetadataBase {
            switch json {
                case .dictionary(let dict):
                    let audienceOptions = ArraySerializer(Sharing.LinkAudienceSerializer()).deserialize(dict["audience_options"] ?? .null)
                    let currentAudience = Sharing.LinkAudienceSerializer().deserialize(dict["current_audience"] ?? .null)
                    let linkPermissions = ArraySerializer(Sharing.LinkPermissionSerializer()).deserialize(dict["link_permissions"] ?? .null)
                    let passwordProtected = Serialization._BoolSerializer.deserialize(dict["password_protected"] ?? .null)
                    let accessLevel = NullableSerializer(Sharing.AccessLevelSerializer()).deserialize(dict["access_level"] ?? .null)
                    let audienceRestrictingSharedFolder = NullableSerializer(Sharing.AudienceRestrictingSharedFolderSerializer()).deserialize(dict["audience_restricting_shared_folder"] ?? .null)
                    let expiry = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["expiry"] ?? .null)
                    return SharedContentLinkMetadataBase(audienceOptions: audienceOptions, currentAudience: currentAudience, linkPermissions: linkPermissions, passwordProtected: passwordProtected, accessLevel: accessLevel, audienceRestrictingSharedFolder: audienceRestrictingSharedFolder, expiry: expiry)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The expected metadata of a shared link for a file or folder when a link is first created for the content. Absent
    /// if the link already exists.
    open class ExpectedSharedContentLinkMetadata: Sharing.SharedContentLinkMetadataBase {
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ExpectedSharedContentLinkMetadataSerializer().serialize(self)))"
        }
    }
    open class ExpectedSharedContentLinkMetadataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ExpectedSharedContentLinkMetadata) -> JSON {
            let output = [ 
            "audience_options": ArraySerializer(Sharing.LinkAudienceSerializer()).serialize(value.audienceOptions),
            "current_audience": Sharing.LinkAudienceSerializer().serialize(value.currentAudience),
            "link_permissions": ArraySerializer(Sharing.LinkPermissionSerializer()).serialize(value.linkPermissions),
            "password_protected": Serialization._BoolSerializer.serialize(value.passwordProtected),
            "access_level": NullableSerializer(Sharing.AccessLevelSerializer()).serialize(value.accessLevel),
            "audience_restricting_shared_folder": NullableSerializer(Sharing.AudienceRestrictingSharedFolderSerializer()).serialize(value.audienceRestrictingSharedFolder),
            "expiry": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.expiry),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ExpectedSharedContentLinkMetadata {
            switch json {
                case .dictionary(let dict):
                    let audienceOptions = ArraySerializer(Sharing.LinkAudienceSerializer()).deserialize(dict["audience_options"] ?? .null)
                    let currentAudience = Sharing.LinkAudienceSerializer().deserialize(dict["current_audience"] ?? .null)
                    let linkPermissions = ArraySerializer(Sharing.LinkPermissionSerializer()).deserialize(dict["link_permissions"] ?? .null)
                    let passwordProtected = Serialization._BoolSerializer.deserialize(dict["password_protected"] ?? .null)
                    let accessLevel = NullableSerializer(Sharing.AccessLevelSerializer()).deserialize(dict["access_level"] ?? .null)
                    let audienceRestrictingSharedFolder = NullableSerializer(Sharing.AudienceRestrictingSharedFolderSerializer()).deserialize(dict["audience_restricting_shared_folder"] ?? .null)
                    let expiry = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["expiry"] ?? .null)
                    return ExpectedSharedContentLinkMetadata(audienceOptions: audienceOptions, currentAudience: currentAudience, linkPermissions: linkPermissions, passwordProtected: passwordProtected, accessLevel: accessLevel, audienceRestrictingSharedFolder: audienceRestrictingSharedFolder, expiry: expiry)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Sharing actions that may be taken on files.
    public enum FileAction: CustomStringConvertible {
        /// Disable viewer information on the file.
        case disableViewerInfo
        /// Change or edit contents of the file.
        case editContents
        /// Enable viewer information on the file.
        case enableViewerInfo
        /// Add a member with view permissions.
        case inviteViewer
        /// Add a member with view permissions but no comment permissions.
        case inviteViewerNoComment
        /// Add a member with edit permissions.
        case inviteEditor
        /// Stop sharing this file.
        case unshare
        /// Relinquish one's own membership to the file.
        case relinquishMembership
        /// Use create_link instead.
        case shareLink
        /// Create a shared link to the file.
        case createLink
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileActionSerializer().serialize(self)))"
        }
    }
    open class FileActionSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileAction) -> JSON {
            switch value {
                case .disableViewerInfo:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disable_viewer_info")
                    return .dictionary(d)
                case .editContents:
                    var d = [String: JSON]()
                    d[".tag"] = .str("edit_contents")
                    return .dictionary(d)
                case .enableViewerInfo:
                    var d = [String: JSON]()
                    d[".tag"] = .str("enable_viewer_info")
                    return .dictionary(d)
                case .inviteViewer:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invite_viewer")
                    return .dictionary(d)
                case .inviteViewerNoComment:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invite_viewer_no_comment")
                    return .dictionary(d)
                case .inviteEditor:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invite_editor")
                    return .dictionary(d)
                case .unshare:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unshare")
                    return .dictionary(d)
                case .relinquishMembership:
                    var d = [String: JSON]()
                    d[".tag"] = .str("relinquish_membership")
                    return .dictionary(d)
                case .shareLink:
                    var d = [String: JSON]()
                    d[".tag"] = .str("share_link")
                    return .dictionary(d)
                case .createLink:
                    var d = [String: JSON]()
                    d[".tag"] = .str("create_link")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> FileAction {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "disable_viewer_info":
                            return FileAction.disableViewerInfo
                        case "edit_contents":
                            return FileAction.editContents
                        case "enable_viewer_info":
                            return FileAction.enableViewerInfo
                        case "invite_viewer":
                            return FileAction.inviteViewer
                        case "invite_viewer_no_comment":
                            return FileAction.inviteViewerNoComment
                        case "invite_editor":
                            return FileAction.inviteEditor
                        case "unshare":
                            return FileAction.unshare
                        case "relinquish_membership":
                            return FileAction.relinquishMembership
                        case "share_link":
                            return FileAction.shareLink
                        case "create_link":
                            return FileAction.createLink
                        case "other":
                            return FileAction.other
                        default:
                            return FileAction.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The FileErrorResult union
    public enum FileErrorResult: CustomStringConvertible {
        /// File specified by id was not found.
        case fileNotFoundError(String)
        /// User does not have permission to take the specified action on the file.
        case invalidFileActionError(String)
        /// User does not have permission to access file specified by file.Id.
        case permissionDeniedError(String)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileErrorResultSerializer().serialize(self)))"
        }
    }
    open class FileErrorResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileErrorResult) -> JSON {
            switch value {
                case .fileNotFoundError(let arg):
                    var d = ["file_not_found_error": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("file_not_found_error")
                    return .dictionary(d)
                case .invalidFileActionError(let arg):
                    var d = ["invalid_file_action_error": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("invalid_file_action_error")
                    return .dictionary(d)
                case .permissionDeniedError(let arg):
                    var d = ["permission_denied_error": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("permission_denied_error")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> FileErrorResult {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "file_not_found_error":
                            let v = Serialization._StringSerializer.deserialize(d["file_not_found_error"] ?? .null)
                            return FileErrorResult.fileNotFoundError(v)
                        case "invalid_file_action_error":
                            let v = Serialization._StringSerializer.deserialize(d["invalid_file_action_error"] ?? .null)
                            return FileErrorResult.invalidFileActionError(v)
                        case "permission_denied_error":
                            let v = Serialization._StringSerializer.deserialize(d["permission_denied_error"] ?? .null)
                            return FileErrorResult.permissionDeniedError(v)
                        case "other":
                            return FileErrorResult.other
                        default:
                            return FileErrorResult.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The metadata of a shared link.
    open class SharedLinkMetadata: CustomStringConvertible {
        /// URL of the shared link.
        public let url: String
        /// A unique identifier for the linked file.
        public let id: String?
        /// The linked file name (including extension). This never contains a slash.
        public let name: String
        /// Expiration time, if set. By default the link won't expire.
        public let expires: Date?
        /// The lowercased full path in the user's Dropbox. This always starts with a slash. This field will only be
        /// present only if the linked file is in the authenticated user's  dropbox.
        public let pathLower: String?
        /// The link's access permissions.
        public let linkPermissions: Sharing.LinkPermissions
        /// The team membership information of the link's owner.  This field will only be present  if the link's owner
        /// is a team member.
        public let teamMemberInfo: Sharing.TeamMemberInfo?
        /// The team information of the content's owner. This field will only be present if the content's owner is a
        /// team member and the content's owner team is different from the link's owner team.
        public let contentOwnerTeamInfo: Users.Team?
        public init(url: String, name: String, linkPermissions: Sharing.LinkPermissions, id: String? = nil, expires: Date? = nil, pathLower: String? = nil, teamMemberInfo: Sharing.TeamMemberInfo? = nil, contentOwnerTeamInfo: Users.Team? = nil) {
            stringValidator()(url)
            self.url = url
            nullableValidator(stringValidator(minLength: 1))(id)
            self.id = id
            stringValidator()(name)
            self.name = name
            self.expires = expires
            nullableValidator(stringValidator())(pathLower)
            self.pathLower = pathLower
            self.linkPermissions = linkPermissions
            self.teamMemberInfo = teamMemberInfo
            self.contentOwnerTeamInfo = contentOwnerTeamInfo
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedLinkMetadataSerializer().serialize(self)))"
        }
    }
    open class SharedLinkMetadataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedLinkMetadata) -> JSON {
            var output = [ 
            "url": Serialization._StringSerializer.serialize(value.url),
            "name": Serialization._StringSerializer.serialize(value.name),
            "link_permissions": Sharing.LinkPermissionsSerializer().serialize(value.linkPermissions),
            "id": NullableSerializer(Serialization._StringSerializer).serialize(value.id),
            "expires": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.expires),
            "path_lower": NullableSerializer(Serialization._StringSerializer).serialize(value.pathLower),
            "team_member_info": NullableSerializer(Sharing.TeamMemberInfoSerializer()).serialize(value.teamMemberInfo),
            "content_owner_team_info": NullableSerializer(Users.TeamSerializer()).serialize(value.contentOwnerTeamInfo),
            ]
            switch value {
                case let file as Sharing.FileLinkMetadata:
                    for (k, v) in Serialization.getFields(Sharing.FileLinkMetadataSerializer().serialize(file)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("file")
                case let folder as Sharing.FolderLinkMetadata:
                    for (k, v) in Serialization.getFields(Sharing.FolderLinkMetadataSerializer().serialize(folder)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("folder")
                default: fatalError("Tried to serialize unexpected subtype")
            }
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedLinkMetadata {
            switch json {
                case .dictionary(let dict):
                    let tag = Serialization.getTag(dict)
                    switch tag {
                        case "file":
                            return Sharing.FileLinkMetadataSerializer().deserialize(json)
                        case "folder":
                            return Sharing.FolderLinkMetadataSerializer().deserialize(json)
                        default:
                            let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .null)
                            let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                            let linkPermissions = Sharing.LinkPermissionsSerializer().deserialize(dict["link_permissions"] ?? .null)
                            let id = NullableSerializer(Serialization._StringSerializer).deserialize(dict["id"] ?? .null)
                            let expires = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["expires"] ?? .null)
                            let pathLower = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_lower"] ?? .null)
                            let teamMemberInfo = NullableSerializer(Sharing.TeamMemberInfoSerializer()).deserialize(dict["team_member_info"] ?? .null)
                            let contentOwnerTeamInfo = NullableSerializer(Users.TeamSerializer()).deserialize(dict["content_owner_team_info"] ?? .null)
                            return SharedLinkMetadata(url: url, name: name, linkPermissions: linkPermissions, id: id, expires: expires, pathLower: pathLower, teamMemberInfo: teamMemberInfo, contentOwnerTeamInfo: contentOwnerTeamInfo)
                    }
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The metadata of a file shared link.
    open class FileLinkMetadata: Sharing.SharedLinkMetadata {
        /// The modification time set by the desktop client when the file was added to Dropbox. Since this time is not
        /// verified (the Dropbox server stores whatever the desktop client sends up), this should only be used for
        /// display purposes (such as sorting) and not, for example, to determine if a file has changed or not.
        public let clientModified: Date
        /// The last time the file was modified on Dropbox.
        public let serverModified: Date
        /// A unique identifier for the current revision of a file. This field is the same rev as elsewhere in the API
        /// and can be used to detect changes and avoid conflicts.
        public let rev: String
        /// The file size in bytes.
        public let size: UInt64
        public init(url: String, name: String, linkPermissions: Sharing.LinkPermissions, clientModified: Date, serverModified: Date, rev: String, size: UInt64, id: String? = nil, expires: Date? = nil, pathLower: String? = nil, teamMemberInfo: Sharing.TeamMemberInfo? = nil, contentOwnerTeamInfo: Users.Team? = nil) {
            self.clientModified = clientModified
            self.serverModified = serverModified
            stringValidator(minLength: 9, pattern: "[0-9a-f]+")(rev)
            self.rev = rev
            comparableValidator()(size)
            self.size = size
            super.init(url: url, name: name, linkPermissions: linkPermissions, id: id, expires: expires, pathLower: pathLower, teamMemberInfo: teamMemberInfo, contentOwnerTeamInfo: contentOwnerTeamInfo)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileLinkMetadataSerializer().serialize(self)))"
        }
    }
    open class FileLinkMetadataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileLinkMetadata) -> JSON {
            let output = [ 
            "url": Serialization._StringSerializer.serialize(value.url),
            "name": Serialization._StringSerializer.serialize(value.name),
            "link_permissions": Sharing.LinkPermissionsSerializer().serialize(value.linkPermissions),
            "client_modified": NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.clientModified),
            "server_modified": NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.serverModified),
            "rev": Serialization._StringSerializer.serialize(value.rev),
            "size": Serialization._UInt64Serializer.serialize(value.size),
            "id": NullableSerializer(Serialization._StringSerializer).serialize(value.id),
            "expires": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.expires),
            "path_lower": NullableSerializer(Serialization._StringSerializer).serialize(value.pathLower),
            "team_member_info": NullableSerializer(Sharing.TeamMemberInfoSerializer()).serialize(value.teamMemberInfo),
            "content_owner_team_info": NullableSerializer(Users.TeamSerializer()).serialize(value.contentOwnerTeamInfo),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileLinkMetadata {
            switch json {
                case .dictionary(let dict):
                    let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .null)
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                    let linkPermissions = Sharing.LinkPermissionsSerializer().deserialize(dict["link_permissions"] ?? .null)
                    let clientModified = NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["client_modified"] ?? .null)
                    let serverModified = NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["server_modified"] ?? .null)
                    let rev = Serialization._StringSerializer.deserialize(dict["rev"] ?? .null)
                    let size = Serialization._UInt64Serializer.deserialize(dict["size"] ?? .null)
                    let id = NullableSerializer(Serialization._StringSerializer).deserialize(dict["id"] ?? .null)
                    let expires = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["expires"] ?? .null)
                    let pathLower = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_lower"] ?? .null)
                    let teamMemberInfo = NullableSerializer(Sharing.TeamMemberInfoSerializer()).deserialize(dict["team_member_info"] ?? .null)
                    let contentOwnerTeamInfo = NullableSerializer(Users.TeamSerializer()).deserialize(dict["content_owner_team_info"] ?? .null)
                    return FileLinkMetadata(url: url, name: name, linkPermissions: linkPermissions, clientModified: clientModified, serverModified: serverModified, rev: rev, size: size, id: id, expires: expires, pathLower: pathLower, teamMemberInfo: teamMemberInfo, contentOwnerTeamInfo: contentOwnerTeamInfo)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FileMemberActionError union
    public enum FileMemberActionError: CustomStringConvertible {
        /// Specified member was not found.
        case invalidMember
        /// User does not have permission to perform this action on this member.
        case noPermission
        /// Specified file was invalid or user does not have access.
        case accessError(Sharing.SharingFileAccessError)
        /// The action cannot be completed because the target member does not have explicit access to the file. The
        /// return value is the access that the member has to the file from a parent folder.
        case noExplicitAccess(Sharing.MemberAccessLevelResult)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileMemberActionErrorSerializer().serialize(self)))"
        }
    }
    open class FileMemberActionErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileMemberActionError) -> JSON {
            switch value {
                case .invalidMember:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_member")
                    return .dictionary(d)
                case .noPermission:
                    var d = [String: JSON]()
                    d[".tag"] = .str("no_permission")
                    return .dictionary(d)
                case .accessError(let arg):
                    var d = ["access_error": Sharing.SharingFileAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("access_error")
                    return .dictionary(d)
                case .noExplicitAccess(let arg):
                    var d = Serialization.getFields(Sharing.MemberAccessLevelResultSerializer().serialize(arg))
                    d[".tag"] = .str("no_explicit_access")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> FileMemberActionError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "invalid_member":
                            return FileMemberActionError.invalidMember
                        case "no_permission":
                            return FileMemberActionError.noPermission
                        case "access_error":
                            let v = Sharing.SharingFileAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                            return FileMemberActionError.accessError(v)
                        case "no_explicit_access":
                            let v = Sharing.MemberAccessLevelResultSerializer().deserialize(json)
                            return FileMemberActionError.noExplicitAccess(v)
                        case "other":
                            return FileMemberActionError.other
                        default:
                            return FileMemberActionError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The FileMemberActionIndividualResult union
    public enum FileMemberActionIndividualResult: CustomStringConvertible {
        /// Member was successfully removed from this file. If AccessLevel is given, the member still has access via a
        /// parent shared folder.
        case success(Sharing.AccessLevel?)
        /// User was not able to perform this action.
        case memberError(Sharing.FileMemberActionError)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileMemberActionIndividualResultSerializer().serialize(self)))"
        }
    }
    open class FileMemberActionIndividualResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileMemberActionIndividualResult) -> JSON {
            switch value {
                case .success(let arg):
                    var d = ["success": NullableSerializer(Sharing.AccessLevelSerializer()).serialize(arg)]
                    d[".tag"] = .str("success")
                    return .dictionary(d)
                case .memberError(let arg):
                    var d = ["member_error": Sharing.FileMemberActionErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("member_error")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> FileMemberActionIndividualResult {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "success":
                            let v = NullableSerializer(Sharing.AccessLevelSerializer()).deserialize(d["success"] ?? .null)
                            return FileMemberActionIndividualResult.success(v)
                        case "member_error":
                            let v = Sharing.FileMemberActionErrorSerializer().deserialize(d["member_error"] ?? .null)
                            return FileMemberActionIndividualResult.memberError(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Per-member result for addFileMember or changeFileMemberAccess.
    open class FileMemberActionResult: CustomStringConvertible {
        /// One of specified input members.
        public let member: Sharing.MemberSelector
        /// The outcome of the action on this member.
        public let result: Sharing.FileMemberActionIndividualResult
        public init(member: Sharing.MemberSelector, result: Sharing.FileMemberActionIndividualResult) {
            self.member = member
            self.result = result
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileMemberActionResultSerializer().serialize(self)))"
        }
    }
    open class FileMemberActionResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileMemberActionResult) -> JSON {
            let output = [ 
            "member": Sharing.MemberSelectorSerializer().serialize(value.member),
            "result": Sharing.FileMemberActionIndividualResultSerializer().serialize(value.result),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileMemberActionResult {
            switch json {
                case .dictionary(let dict):
                    let member = Sharing.MemberSelectorSerializer().deserialize(dict["member"] ?? .null)
                    let result = Sharing.FileMemberActionIndividualResultSerializer().deserialize(dict["result"] ?? .null)
                    return FileMemberActionResult(member: member, result: result)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FileMemberRemoveActionResult union
    public enum FileMemberRemoveActionResult: CustomStringConvertible {
        /// Member was successfully removed from this file.
        case success(Sharing.MemberAccessLevelResult)
        /// User was not able to remove this member.
        case memberError(Sharing.FileMemberActionError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileMemberRemoveActionResultSerializer().serialize(self)))"
        }
    }
    open class FileMemberRemoveActionResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileMemberRemoveActionResult) -> JSON {
            switch value {
                case .success(let arg):
                    var d = Serialization.getFields(Sharing.MemberAccessLevelResultSerializer().serialize(arg))
                    d[".tag"] = .str("success")
                    return .dictionary(d)
                case .memberError(let arg):
                    var d = ["member_error": Sharing.FileMemberActionErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("member_error")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> FileMemberRemoveActionResult {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "success":
                            let v = Sharing.MemberAccessLevelResultSerializer().deserialize(json)
                            return FileMemberRemoveActionResult.success(v)
                        case "member_error":
                            let v = Sharing.FileMemberActionErrorSerializer().deserialize(d["member_error"] ?? .null)
                            return FileMemberRemoveActionResult.memberError(v)
                        case "other":
                            return FileMemberRemoveActionResult.other
                        default:
                            return FileMemberRemoveActionResult.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Whether the user is allowed to take the sharing action on the file.
    open class FilePermission: CustomStringConvertible {
        /// The action that the user may wish to take on the file.
        public let action: Sharing.FileAction
        /// True if the user is allowed to take the action.
        public let allow: Bool
        /// The reason why the user is denied the permission. Not present if the action is allowed.
        public let reason: Sharing.PermissionDeniedReason?
        public init(action: Sharing.FileAction, allow: Bool, reason: Sharing.PermissionDeniedReason? = nil) {
            self.action = action
            self.allow = allow
            self.reason = reason
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FilePermissionSerializer().serialize(self)))"
        }
    }
    open class FilePermissionSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FilePermission) -> JSON {
            let output = [ 
            "action": Sharing.FileActionSerializer().serialize(value.action),
            "allow": Serialization._BoolSerializer.serialize(value.allow),
            "reason": NullableSerializer(Sharing.PermissionDeniedReasonSerializer()).serialize(value.reason),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FilePermission {
            switch json {
                case .dictionary(let dict):
                    let action = Sharing.FileActionSerializer().deserialize(dict["action"] ?? .null)
                    let allow = Serialization._BoolSerializer.deserialize(dict["allow"] ?? .null)
                    let reason = NullableSerializer(Sharing.PermissionDeniedReasonSerializer()).deserialize(dict["reason"] ?? .null)
                    return FilePermission(action: action, allow: allow, reason: reason)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Actions that may be taken on shared folders.
    public enum FolderAction: CustomStringConvertible {
        /// Change folder options, such as who can be invited to join the folder.
        case changeOptions
        /// Disable viewer information for this folder.
        case disableViewerInfo
        /// Change or edit contents of the folder.
        case editContents
        /// Enable viewer information on the folder.
        case enableViewerInfo
        /// Invite a user or group to join the folder with read and write permission.
        case inviteEditor
        /// Invite a user or group to join the folder with read permission.
        case inviteViewer
        /// Invite a user or group to join the folder with read permission but no comment permissions.
        case inviteViewerNoComment
        /// Relinquish one's own membership in the folder.
        case relinquishMembership
        /// Unmount the folder.
        case unmount
        /// Stop sharing this folder.
        case unshare
        /// Keep a copy of the contents upon leaving or being kicked from the folder.
        case leaveACopy
        /// Use create_link instead.
        case shareLink
        /// Create a shared link for folder.
        case createLink
        /// Set whether the folder inherits permissions from its parent.
        case setAccessInheritance
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FolderActionSerializer().serialize(self)))"
        }
    }
    open class FolderActionSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FolderAction) -> JSON {
            switch value {
                case .changeOptions:
                    var d = [String: JSON]()
                    d[".tag"] = .str("change_options")
                    return .dictionary(d)
                case .disableViewerInfo:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disable_viewer_info")
                    return .dictionary(d)
                case .editContents:
                    var d = [String: JSON]()
                    d[".tag"] = .str("edit_contents")
                    return .dictionary(d)
                case .enableViewerInfo:
                    var d = [String: JSON]()
                    d[".tag"] = .str("enable_viewer_info")
                    return .dictionary(d)
                case .inviteEditor:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invite_editor")
                    return .dictionary(d)
                case .inviteViewer:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invite_viewer")
                    return .dictionary(d)
                case .inviteViewerNoComment:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invite_viewer_no_comment")
                    return .dictionary(d)
                case .relinquishMembership:
                    var d = [String: JSON]()
                    d[".tag"] = .str("relinquish_membership")
                    return .dictionary(d)
                case .unmount:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unmount")
                    return .dictionary(d)
                case .unshare:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unshare")
                    return .dictionary(d)
                case .leaveACopy:
                    var d = [String: JSON]()
                    d[".tag"] = .str("leave_a_copy")
                    return .dictionary(d)
                case .shareLink:
                    var d = [String: JSON]()
                    d[".tag"] = .str("share_link")
                    return .dictionary(d)
                case .createLink:
                    var d = [String: JSON]()
                    d[".tag"] = .str("create_link")
                    return .dictionary(d)
                case .setAccessInheritance:
                    var d = [String: JSON]()
                    d[".tag"] = .str("set_access_inheritance")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> FolderAction {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "change_options":
                            return FolderAction.changeOptions
                        case "disable_viewer_info":
                            return FolderAction.disableViewerInfo
                        case "edit_contents":
                            return FolderAction.editContents
                        case "enable_viewer_info":
                            return FolderAction.enableViewerInfo
                        case "invite_editor":
                            return FolderAction.inviteEditor
                        case "invite_viewer":
                            return FolderAction.inviteViewer
                        case "invite_viewer_no_comment":
                            return FolderAction.inviteViewerNoComment
                        case "relinquish_membership":
                            return FolderAction.relinquishMembership
                        case "unmount":
                            return FolderAction.unmount
                        case "unshare":
                            return FolderAction.unshare
                        case "leave_a_copy":
                            return FolderAction.leaveACopy
                        case "share_link":
                            return FolderAction.shareLink
                        case "create_link":
                            return FolderAction.createLink
                        case "set_access_inheritance":
                            return FolderAction.setAccessInheritance
                        case "other":
                            return FolderAction.other
                        default:
                            return FolderAction.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The metadata of a folder shared link.
    open class FolderLinkMetadata: Sharing.SharedLinkMetadata {
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FolderLinkMetadataSerializer().serialize(self)))"
        }
    }
    open class FolderLinkMetadataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FolderLinkMetadata) -> JSON {
            let output = [ 
            "url": Serialization._StringSerializer.serialize(value.url),
            "name": Serialization._StringSerializer.serialize(value.name),
            "link_permissions": Sharing.LinkPermissionsSerializer().serialize(value.linkPermissions),
            "id": NullableSerializer(Serialization._StringSerializer).serialize(value.id),
            "expires": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.expires),
            "path_lower": NullableSerializer(Serialization._StringSerializer).serialize(value.pathLower),
            "team_member_info": NullableSerializer(Sharing.TeamMemberInfoSerializer()).serialize(value.teamMemberInfo),
            "content_owner_team_info": NullableSerializer(Users.TeamSerializer()).serialize(value.contentOwnerTeamInfo),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FolderLinkMetadata {
            switch json {
                case .dictionary(let dict):
                    let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .null)
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                    let linkPermissions = Sharing.LinkPermissionsSerializer().deserialize(dict["link_permissions"] ?? .null)
                    let id = NullableSerializer(Serialization._StringSerializer).deserialize(dict["id"] ?? .null)
                    let expires = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["expires"] ?? .null)
                    let pathLower = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_lower"] ?? .null)
                    let teamMemberInfo = NullableSerializer(Sharing.TeamMemberInfoSerializer()).deserialize(dict["team_member_info"] ?? .null)
                    let contentOwnerTeamInfo = NullableSerializer(Users.TeamSerializer()).deserialize(dict["content_owner_team_info"] ?? .null)
                    return FolderLinkMetadata(url: url, name: name, linkPermissions: linkPermissions, id: id, expires: expires, pathLower: pathLower, teamMemberInfo: teamMemberInfo, contentOwnerTeamInfo: contentOwnerTeamInfo)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Whether the user is allowed to take the action on the shared folder.
    open class FolderPermission: CustomStringConvertible {
        /// The action that the user may wish to take on the folder.
        public let action: Sharing.FolderAction
        /// True if the user is allowed to take the action.
        public let allow: Bool
        /// The reason why the user is denied the permission. Not present if the action is allowed, or if no reason is
        /// available.
        public let reason: Sharing.PermissionDeniedReason?
        public init(action: Sharing.FolderAction, allow: Bool, reason: Sharing.PermissionDeniedReason? = nil) {
            self.action = action
            self.allow = allow
            self.reason = reason
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FolderPermissionSerializer().serialize(self)))"
        }
    }
    open class FolderPermissionSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FolderPermission) -> JSON {
            let output = [ 
            "action": Sharing.FolderActionSerializer().serialize(value.action),
            "allow": Serialization._BoolSerializer.serialize(value.allow),
            "reason": NullableSerializer(Sharing.PermissionDeniedReasonSerializer()).serialize(value.reason),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FolderPermission {
            switch json {
                case .dictionary(let dict):
                    let action = Sharing.FolderActionSerializer().deserialize(dict["action"] ?? .null)
                    let allow = Serialization._BoolSerializer.deserialize(dict["allow"] ?? .null)
                    let reason = NullableSerializer(Sharing.PermissionDeniedReasonSerializer()).deserialize(dict["reason"] ?? .null)
                    return FolderPermission(action: action, allow: allow, reason: reason)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// A set of policies governing membership and privileges for a shared folder.
    open class FolderPolicy: CustomStringConvertible {
        /// Who can be a member of this shared folder, as set on the folder itself. The effective policy may differ from
        /// this value if the team-wide policy is more restrictive. Present only if the folder is owned by a team.
        public let memberPolicy: Sharing.MemberPolicy?
        /// Who can be a member of this shared folder, taking into account both the folder and the team-wide policy.
        /// This value may differ from that of member_policy if the team-wide policy is more restrictive than the folder
        /// policy. Present only if the folder is owned by a team.
        public let resolvedMemberPolicy: Sharing.MemberPolicy?
        /// Who can add and remove members from this shared folder.
        public let aclUpdatePolicy: Sharing.AclUpdatePolicy
        /// Who links can be shared with.
        public let sharedLinkPolicy: Sharing.SharedLinkPolicy
        /// Who can enable/disable viewer info for this shared folder.
        public let viewerInfoPolicy: Sharing.ViewerInfoPolicy?
        public init(aclUpdatePolicy: Sharing.AclUpdatePolicy, sharedLinkPolicy: Sharing.SharedLinkPolicy, memberPolicy: Sharing.MemberPolicy? = nil, resolvedMemberPolicy: Sharing.MemberPolicy? = nil, viewerInfoPolicy: Sharing.ViewerInfoPolicy? = nil) {
            self.memberPolicy = memberPolicy
            self.resolvedMemberPolicy = resolvedMemberPolicy
            self.aclUpdatePolicy = aclUpdatePolicy
            self.sharedLinkPolicy = sharedLinkPolicy
            self.viewerInfoPolicy = viewerInfoPolicy
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FolderPolicySerializer().serialize(self)))"
        }
    }
    open class FolderPolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FolderPolicy) -> JSON {
            let output = [ 
            "acl_update_policy": Sharing.AclUpdatePolicySerializer().serialize(value.aclUpdatePolicy),
            "shared_link_policy": Sharing.SharedLinkPolicySerializer().serialize(value.sharedLinkPolicy),
            "member_policy": NullableSerializer(Sharing.MemberPolicySerializer()).serialize(value.memberPolicy),
            "resolved_member_policy": NullableSerializer(Sharing.MemberPolicySerializer()).serialize(value.resolvedMemberPolicy),
            "viewer_info_policy": NullableSerializer(Sharing.ViewerInfoPolicySerializer()).serialize(value.viewerInfoPolicy),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FolderPolicy {
            switch json {
                case .dictionary(let dict):
                    let aclUpdatePolicy = Sharing.AclUpdatePolicySerializer().deserialize(dict["acl_update_policy"] ?? .null)
                    let sharedLinkPolicy = Sharing.SharedLinkPolicySerializer().deserialize(dict["shared_link_policy"] ?? .null)
                    let memberPolicy = NullableSerializer(Sharing.MemberPolicySerializer()).deserialize(dict["member_policy"] ?? .null)
                    let resolvedMemberPolicy = NullableSerializer(Sharing.MemberPolicySerializer()).deserialize(dict["resolved_member_policy"] ?? .null)
                    let viewerInfoPolicy = NullableSerializer(Sharing.ViewerInfoPolicySerializer()).deserialize(dict["viewer_info_policy"] ?? .null)
                    return FolderPolicy(aclUpdatePolicy: aclUpdatePolicy, sharedLinkPolicy: sharedLinkPolicy, memberPolicy: memberPolicy, resolvedMemberPolicy: resolvedMemberPolicy, viewerInfoPolicy: viewerInfoPolicy)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Arguments of getFileMetadata.
    open class GetFileMetadataArg: CustomStringConvertible {
        /// The file to query.
        public let file: String
        /// A list of `FileAction`s corresponding to `FilePermission`s that should appear in the  response's permissions
        /// in SharedFileMetadata field describing the actions the  authenticated user can perform on the file.
        public let actions: Array<Sharing.FileAction>?
        public init(file: String, actions: Array<Sharing.FileAction>? = nil) {
            stringValidator(minLength: 1, pattern: "((/|id:).*|nspath:[0-9]+:.*)|ns:[0-9]+(/.*)?")(file)
            self.file = file
            self.actions = actions
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetFileMetadataArgSerializer().serialize(self)))"
        }
    }
    open class GetFileMetadataArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetFileMetadataArg) -> JSON {
            let output = [ 
            "file": Serialization._StringSerializer.serialize(value.file),
            "actions": NullableSerializer(ArraySerializer(Sharing.FileActionSerializer())).serialize(value.actions),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetFileMetadataArg {
            switch json {
                case .dictionary(let dict):
                    let file = Serialization._StringSerializer.deserialize(dict["file"] ?? .null)
                    let actions = NullableSerializer(ArraySerializer(Sharing.FileActionSerializer())).deserialize(dict["actions"] ?? .null)
                    return GetFileMetadataArg(file: file, actions: actions)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Arguments of getFileMetadataBatch.
    open class GetFileMetadataBatchArg: CustomStringConvertible {
        /// The files to query.
        public let files: Array<String>
        /// A list of `FileAction`s corresponding to `FilePermission`s that should appear in the  response's permissions
        /// in SharedFileMetadata field describing the actions the  authenticated user can perform on the file.
        public let actions: Array<Sharing.FileAction>?
        public init(files: Array<String>, actions: Array<Sharing.FileAction>? = nil) {
            arrayValidator(maxItems: 100, itemValidator: stringValidator(minLength: 1, pattern: "((/|id:).*|nspath:[0-9]+:.*)|ns:[0-9]+(/.*)?"))(files)
            self.files = files
            self.actions = actions
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetFileMetadataBatchArgSerializer().serialize(self)))"
        }
    }
    open class GetFileMetadataBatchArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetFileMetadataBatchArg) -> JSON {
            let output = [ 
            "files": ArraySerializer(Serialization._StringSerializer).serialize(value.files),
            "actions": NullableSerializer(ArraySerializer(Sharing.FileActionSerializer())).serialize(value.actions),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetFileMetadataBatchArg {
            switch json {
                case .dictionary(let dict):
                    let files = ArraySerializer(Serialization._StringSerializer).deserialize(dict["files"] ?? .null)
                    let actions = NullableSerializer(ArraySerializer(Sharing.FileActionSerializer())).deserialize(dict["actions"] ?? .null)
                    return GetFileMetadataBatchArg(files: files, actions: actions)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Per file results of getFileMetadataBatch.
    open class GetFileMetadataBatchResult: CustomStringConvertible {
        /// This is the input file identifier corresponding to one of files in GetFileMetadataBatchArg.
        public let file: String
        /// The result for this particular file.
        public let result: Sharing.GetFileMetadataIndividualResult
        public init(file: String, result: Sharing.GetFileMetadataIndividualResult) {
            stringValidator(minLength: 1, pattern: "((/|id:).*|nspath:[0-9]+:.*)|ns:[0-9]+(/.*)?")(file)
            self.file = file
            self.result = result
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetFileMetadataBatchResultSerializer().serialize(self)))"
        }
    }
    open class GetFileMetadataBatchResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetFileMetadataBatchResult) -> JSON {
            let output = [ 
            "file": Serialization._StringSerializer.serialize(value.file),
            "result": Sharing.GetFileMetadataIndividualResultSerializer().serialize(value.result),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetFileMetadataBatchResult {
            switch json {
                case .dictionary(let dict):
                    let file = Serialization._StringSerializer.deserialize(dict["file"] ?? .null)
                    let result = Sharing.GetFileMetadataIndividualResultSerializer().deserialize(dict["result"] ?? .null)
                    return GetFileMetadataBatchResult(file: file, result: result)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Error result for getFileMetadata.
    public enum GetFileMetadataError: CustomStringConvertible {
        /// An unspecified error.
        case userError(Sharing.SharingUserError)
        /// An unspecified error.
        case accessError(Sharing.SharingFileAccessError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetFileMetadataErrorSerializer().serialize(self)))"
        }
    }
    open class GetFileMetadataErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetFileMetadataError) -> JSON {
            switch value {
                case .userError(let arg):
                    var d = ["user_error": Sharing.SharingUserErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("user_error")
                    return .dictionary(d)
                case .accessError(let arg):
                    var d = ["access_error": Sharing.SharingFileAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("access_error")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GetFileMetadataError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "user_error":
                            let v = Sharing.SharingUserErrorSerializer().deserialize(d["user_error"] ?? .null)
                            return GetFileMetadataError.userError(v)
                        case "access_error":
                            let v = Sharing.SharingFileAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                            return GetFileMetadataError.accessError(v)
                        case "other":
                            return GetFileMetadataError.other
                        default:
                            return GetFileMetadataError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GetFileMetadataIndividualResult union
    public enum GetFileMetadataIndividualResult: CustomStringConvertible {
        /// The result for this file if it was successful.
        case metadata(Sharing.SharedFileMetadata)
        /// The result for this file if it was an error.
        case accessError(Sharing.SharingFileAccessError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetFileMetadataIndividualResultSerializer().serialize(self)))"
        }
    }
    open class GetFileMetadataIndividualResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetFileMetadataIndividualResult) -> JSON {
            switch value {
                case .metadata(let arg):
                    var d = Serialization.getFields(Sharing.SharedFileMetadataSerializer().serialize(arg))
                    d[".tag"] = .str("metadata")
                    return .dictionary(d)
                case .accessError(let arg):
                    var d = ["access_error": Sharing.SharingFileAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("access_error")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GetFileMetadataIndividualResult {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "metadata":
                            let v = Sharing.SharedFileMetadataSerializer().deserialize(json)
                            return GetFileMetadataIndividualResult.metadata(v)
                        case "access_error":
                            let v = Sharing.SharingFileAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                            return GetFileMetadataIndividualResult.accessError(v)
                        case "other":
                            return GetFileMetadataIndividualResult.other
                        default:
                            return GetFileMetadataIndividualResult.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GetMetadataArgs struct
    open class GetMetadataArgs: CustomStringConvertible {
        /// The ID for the shared folder.
        public let sharedFolderId: String
        /// A list of `FolderAction`s corresponding to `FolderPermission`s that should appear in the  response's
        /// permissions in SharedFolderMetadata field describing the actions the  authenticated user can perform on the
        /// folder.
        public let actions: Array<Sharing.FolderAction>?
        public init(sharedFolderId: String, actions: Array<Sharing.FolderAction>? = nil) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.actions = actions
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetMetadataArgsSerializer().serialize(self)))"
        }
    }
    open class GetMetadataArgsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetMetadataArgs) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            "actions": NullableSerializer(ArraySerializer(Sharing.FolderActionSerializer())).serialize(value.actions),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetMetadataArgs {
            switch json {
                case .dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                    let actions = NullableSerializer(ArraySerializer(Sharing.FolderActionSerializer())).deserialize(dict["actions"] ?? .null)
                    return GetMetadataArgs(sharedFolderId: sharedFolderId, actions: actions)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedLinkError union
    public enum SharedLinkError: CustomStringConvertible {
        /// The shared link wasn't found.
        case sharedLinkNotFound
        /// The caller is not allowed to access this shared link.
        case sharedLinkAccessDenied
        /// This type of link is not supported.
        case unsupportedLinkType
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedLinkErrorSerializer().serialize(self)))"
        }
    }
    open class SharedLinkErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedLinkError) -> JSON {
            switch value {
                case .sharedLinkNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("shared_link_not_found")
                    return .dictionary(d)
                case .sharedLinkAccessDenied:
                    var d = [String: JSON]()
                    d[".tag"] = .str("shared_link_access_denied")
                    return .dictionary(d)
                case .unsupportedLinkType:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unsupported_link_type")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SharedLinkError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "shared_link_not_found":
                            return SharedLinkError.sharedLinkNotFound
                        case "shared_link_access_denied":
                            return SharedLinkError.sharedLinkAccessDenied
                        case "unsupported_link_type":
                            return SharedLinkError.unsupportedLinkType
                        case "other":
                            return SharedLinkError.other
                        default:
                            return SharedLinkError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GetSharedLinkFileError union
    public enum GetSharedLinkFileError: CustomStringConvertible {
        /// The shared link wasn't found.
        case sharedLinkNotFound
        /// The caller is not allowed to access this shared link.
        case sharedLinkAccessDenied
        /// This type of link is not supported.
        case unsupportedLinkType
        /// An unspecified error.
        case other
        /// Directories cannot be retrieved by this endpoint.
        case sharedLinkIsDirectory

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetSharedLinkFileErrorSerializer().serialize(self)))"
        }
    }
    open class GetSharedLinkFileErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetSharedLinkFileError) -> JSON {
            switch value {
                case .sharedLinkNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("shared_link_not_found")
                    return .dictionary(d)
                case .sharedLinkAccessDenied:
                    var d = [String: JSON]()
                    d[".tag"] = .str("shared_link_access_denied")
                    return .dictionary(d)
                case .unsupportedLinkType:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unsupported_link_type")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .sharedLinkIsDirectory:
                    var d = [String: JSON]()
                    d[".tag"] = .str("shared_link_is_directory")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GetSharedLinkFileError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "shared_link_not_found":
                            return GetSharedLinkFileError.sharedLinkNotFound
                        case "shared_link_access_denied":
                            return GetSharedLinkFileError.sharedLinkAccessDenied
                        case "unsupported_link_type":
                            return GetSharedLinkFileError.unsupportedLinkType
                        case "other":
                            return GetSharedLinkFileError.other
                        case "shared_link_is_directory":
                            return GetSharedLinkFileError.sharedLinkIsDirectory
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GetSharedLinkMetadataArg struct
    open class GetSharedLinkMetadataArg: CustomStringConvertible {
        /// URL of the shared link.
        public let url: String
        /// If the shared link is to a folder, this parameter can be used to retrieve the metadata for a specific file
        /// or sub-folder in this folder. A relative path should be used.
        public let path: String?
        /// If the shared link has a password, this parameter can be used.
        public let linkPassword: String?
        public init(url: String, path: String? = nil, linkPassword: String? = nil) {
            stringValidator()(url)
            self.url = url
            nullableValidator(stringValidator(pattern: "/(.|[\\r\\n])*"))(path)
            self.path = path
            nullableValidator(stringValidator())(linkPassword)
            self.linkPassword = linkPassword
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetSharedLinkMetadataArgSerializer().serialize(self)))"
        }
    }
    open class GetSharedLinkMetadataArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetSharedLinkMetadataArg) -> JSON {
            let output = [ 
            "url": Serialization._StringSerializer.serialize(value.url),
            "path": NullableSerializer(Serialization._StringSerializer).serialize(value.path),
            "link_password": NullableSerializer(Serialization._StringSerializer).serialize(value.linkPassword),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetSharedLinkMetadataArg {
            switch json {
                case .dictionary(let dict):
                    let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .null)
                    let path = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path"] ?? .null)
                    let linkPassword = NullableSerializer(Serialization._StringSerializer).deserialize(dict["link_password"] ?? .null)
                    return GetSharedLinkMetadataArg(url: url, path: path, linkPassword: linkPassword)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetSharedLinksArg struct
    open class GetSharedLinksArg: CustomStringConvertible {
        /// See getSharedLinks description.
        public let path: String?
        public init(path: String? = nil) {
            nullableValidator(stringValidator())(path)
            self.path = path
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetSharedLinksArgSerializer().serialize(self)))"
        }
    }
    open class GetSharedLinksArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetSharedLinksArg) -> JSON {
            let output = [ 
            "path": NullableSerializer(Serialization._StringSerializer).serialize(value.path),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetSharedLinksArg {
            switch json {
                case .dictionary(let dict):
                    let path = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path"] ?? .null)
                    return GetSharedLinksArg(path: path)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetSharedLinksError union
    public enum GetSharedLinksError: CustomStringConvertible {
        /// An unspecified error.
        case path(String?)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetSharedLinksErrorSerializer().serialize(self)))"
        }
    }
    open class GetSharedLinksErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetSharedLinksError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": NullableSerializer(Serialization._StringSerializer).serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GetSharedLinksError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = NullableSerializer(Serialization._StringSerializer).deserialize(d["path"] ?? .null)
                            return GetSharedLinksError.path(v)
                        case "other":
                            return GetSharedLinksError.other
                        default:
                            return GetSharedLinksError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GetSharedLinksResult struct
    open class GetSharedLinksResult: CustomStringConvertible {
        /// Shared links applicable to the path argument.
        public let links: Array<Sharing.LinkMetadata>
        public init(links: Array<Sharing.LinkMetadata>) {
            self.links = links
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetSharedLinksResultSerializer().serialize(self)))"
        }
    }
    open class GetSharedLinksResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetSharedLinksResult) -> JSON {
            let output = [ 
            "links": ArraySerializer(Sharing.LinkMetadataSerializer()).serialize(value.links),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetSharedLinksResult {
            switch json {
                case .dictionary(let dict):
                    let links = ArraySerializer(Sharing.LinkMetadataSerializer()).deserialize(dict["links"] ?? .null)
                    return GetSharedLinksResult(links: links)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The information about a group. Groups is a way to manage a list of users  who need same access permission to the
    /// shared folder.
    open class GroupInfo: TeamCommon.GroupSummary {
        /// The type of group.
        public let groupType: TeamCommon.GroupType
        /// If the current user is a member of the group.
        public let isMember: Bool
        /// If the current user is an owner of the group.
        public let isOwner: Bool
        /// If the group is owned by the current user's team.
        public let sameTeam: Bool
        public init(groupName: String, groupId: String, groupManagementType: TeamCommon.GroupManagementType, groupType: TeamCommon.GroupType, isMember: Bool, isOwner: Bool, sameTeam: Bool, groupExternalId: String? = nil, memberCount: UInt32? = nil) {
            self.groupType = groupType
            self.isMember = isMember
            self.isOwner = isOwner
            self.sameTeam = sameTeam
            super.init(groupName: groupName, groupId: groupId, groupManagementType: groupManagementType, groupExternalId: groupExternalId, memberCount: memberCount)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupInfoSerializer().serialize(self)))"
        }
    }
    open class GroupInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupInfo) -> JSON {
            let output = [ 
            "group_name": Serialization._StringSerializer.serialize(value.groupName),
            "group_id": Serialization._StringSerializer.serialize(value.groupId),
            "group_management_type": TeamCommon.GroupManagementTypeSerializer().serialize(value.groupManagementType),
            "group_type": TeamCommon.GroupTypeSerializer().serialize(value.groupType),
            "is_member": Serialization._BoolSerializer.serialize(value.isMember),
            "is_owner": Serialization._BoolSerializer.serialize(value.isOwner),
            "same_team": Serialization._BoolSerializer.serialize(value.sameTeam),
            "group_external_id": NullableSerializer(Serialization._StringSerializer).serialize(value.groupExternalId),
            "member_count": NullableSerializer(Serialization._UInt32Serializer).serialize(value.memberCount),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupInfo {
            switch json {
                case .dictionary(let dict):
                    let groupName = Serialization._StringSerializer.deserialize(dict["group_name"] ?? .null)
                    let groupId = Serialization._StringSerializer.deserialize(dict["group_id"] ?? .null)
                    let groupManagementType = TeamCommon.GroupManagementTypeSerializer().deserialize(dict["group_management_type"] ?? .null)
                    let groupType = TeamCommon.GroupTypeSerializer().deserialize(dict["group_type"] ?? .null)
                    let isMember = Serialization._BoolSerializer.deserialize(dict["is_member"] ?? .null)
                    let isOwner = Serialization._BoolSerializer.deserialize(dict["is_owner"] ?? .null)
                    let sameTeam = Serialization._BoolSerializer.deserialize(dict["same_team"] ?? .null)
                    let groupExternalId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["group_external_id"] ?? .null)
                    let memberCount = NullableSerializer(Serialization._UInt32Serializer).deserialize(dict["member_count"] ?? .null)
                    return GroupInfo(groupName: groupName, groupId: groupId, groupManagementType: groupManagementType, groupType: groupType, isMember: isMember, isOwner: isOwner, sameTeam: sameTeam, groupExternalId: groupExternalId, memberCount: memberCount)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The information about a member of the shared content.
    open class MembershipInfo: CustomStringConvertible {
        /// The access type for this member. It contains inherited access type from parent folder, and acquired access
        /// type from this folder.
        public let accessType: Sharing.AccessLevel
        /// The permissions that requesting user has on this member. The set of permissions corresponds to the
        /// MemberActions in the request.
        public let permissions: Array<Sharing.MemberPermission>?
        /// Never set.
        public let initials: String?
        /// True if the member has access from a parent folder.
        public let isInherited: Bool
        public init(accessType: Sharing.AccessLevel, permissions: Array<Sharing.MemberPermission>? = nil, initials: String? = nil, isInherited: Bool = false) {
            self.accessType = accessType
            self.permissions = permissions
            nullableValidator(stringValidator())(initials)
            self.initials = initials
            self.isInherited = isInherited
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembershipInfoSerializer().serialize(self)))"
        }
    }
    open class MembershipInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MembershipInfo) -> JSON {
            let output = [ 
            "access_type": Sharing.AccessLevelSerializer().serialize(value.accessType),
            "permissions": NullableSerializer(ArraySerializer(Sharing.MemberPermissionSerializer())).serialize(value.permissions),
            "initials": NullableSerializer(Serialization._StringSerializer).serialize(value.initials),
            "is_inherited": Serialization._BoolSerializer.serialize(value.isInherited),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MembershipInfo {
            switch json {
                case .dictionary(let dict):
                    let accessType = Sharing.AccessLevelSerializer().deserialize(dict["access_type"] ?? .null)
                    let permissions = NullableSerializer(ArraySerializer(Sharing.MemberPermissionSerializer())).deserialize(dict["permissions"] ?? .null)
                    let initials = NullableSerializer(Serialization._StringSerializer).deserialize(dict["initials"] ?? .null)
                    let isInherited = Serialization._BoolSerializer.deserialize(dict["is_inherited"] ?? .number(0))
                    return MembershipInfo(accessType: accessType, permissions: permissions, initials: initials, isInherited: isInherited)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The information about a group member of the shared content.
    open class GroupMembershipInfo: Sharing.MembershipInfo {
        /// The information about the membership group.
        public let group: Sharing.GroupInfo
        public init(accessType: Sharing.AccessLevel, group: Sharing.GroupInfo, permissions: Array<Sharing.MemberPermission>? = nil, initials: String? = nil, isInherited: Bool = false) {
            self.group = group
            super.init(accessType: accessType, permissions: permissions, initials: initials, isInherited: isInherited)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupMembershipInfoSerializer().serialize(self)))"
        }
    }
    open class GroupMembershipInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupMembershipInfo) -> JSON {
            let output = [ 
            "access_type": Sharing.AccessLevelSerializer().serialize(value.accessType),
            "group": Sharing.GroupInfoSerializer().serialize(value.group),
            "permissions": NullableSerializer(ArraySerializer(Sharing.MemberPermissionSerializer())).serialize(value.permissions),
            "initials": NullableSerializer(Serialization._StringSerializer).serialize(value.initials),
            "is_inherited": Serialization._BoolSerializer.serialize(value.isInherited),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupMembershipInfo {
            switch json {
                case .dictionary(let dict):
                    let accessType = Sharing.AccessLevelSerializer().deserialize(dict["access_type"] ?? .null)
                    let group = Sharing.GroupInfoSerializer().deserialize(dict["group"] ?? .null)
                    let permissions = NullableSerializer(ArraySerializer(Sharing.MemberPermissionSerializer())).deserialize(dict["permissions"] ?? .null)
                    let initials = NullableSerializer(Serialization._StringSerializer).deserialize(dict["initials"] ?? .null)
                    let isInherited = Serialization._BoolSerializer.deserialize(dict["is_inherited"] ?? .number(0))
                    return GroupMembershipInfo(accessType: accessType, group: group, permissions: permissions, initials: initials, isInherited: isInherited)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The InsufficientPlan struct
    open class InsufficientPlan: CustomStringConvertible {
        /// A message to tell the user to upgrade in order to support expected action.
        public let message: String
        /// A URL to send the user to in order to obtain the account type they need, e.g. upgrading. Absent if there is
        /// no action the user can take to upgrade.
        public let upsellUrl: String?
        public init(message: String, upsellUrl: String? = nil) {
            stringValidator()(message)
            self.message = message
            nullableValidator(stringValidator())(upsellUrl)
            self.upsellUrl = upsellUrl
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(InsufficientPlanSerializer().serialize(self)))"
        }
    }
    open class InsufficientPlanSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: InsufficientPlan) -> JSON {
            let output = [ 
            "message": Serialization._StringSerializer.serialize(value.message),
            "upsell_url": NullableSerializer(Serialization._StringSerializer).serialize(value.upsellUrl),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> InsufficientPlan {
            switch json {
                case .dictionary(let dict):
                    let message = Serialization._StringSerializer.deserialize(dict["message"] ?? .null)
                    let upsellUrl = NullableSerializer(Serialization._StringSerializer).deserialize(dict["upsell_url"] ?? .null)
                    return InsufficientPlan(message: message, upsellUrl: upsellUrl)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The InsufficientQuotaAmounts struct
    open class InsufficientQuotaAmounts: CustomStringConvertible {
        /// The amount of space needed to add the item (the size of the item).
        public let spaceNeeded: UInt64
        /// The amount of extra space needed to add the item.
        public let spaceShortage: UInt64
        /// The amount of space left in the user's Dropbox, less than space_needed.
        public let spaceLeft: UInt64
        public init(spaceNeeded: UInt64, spaceShortage: UInt64, spaceLeft: UInt64) {
            comparableValidator()(spaceNeeded)
            self.spaceNeeded = spaceNeeded
            comparableValidator()(spaceShortage)
            self.spaceShortage = spaceShortage
            comparableValidator()(spaceLeft)
            self.spaceLeft = spaceLeft
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(InsufficientQuotaAmountsSerializer().serialize(self)))"
        }
    }
    open class InsufficientQuotaAmountsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: InsufficientQuotaAmounts) -> JSON {
            let output = [ 
            "space_needed": Serialization._UInt64Serializer.serialize(value.spaceNeeded),
            "space_shortage": Serialization._UInt64Serializer.serialize(value.spaceShortage),
            "space_left": Serialization._UInt64Serializer.serialize(value.spaceLeft),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> InsufficientQuotaAmounts {
            switch json {
                case .dictionary(let dict):
                    let spaceNeeded = Serialization._UInt64Serializer.deserialize(dict["space_needed"] ?? .null)
                    let spaceShortage = Serialization._UInt64Serializer.deserialize(dict["space_shortage"] ?? .null)
                    let spaceLeft = Serialization._UInt64Serializer.deserialize(dict["space_left"] ?? .null)
                    return InsufficientQuotaAmounts(spaceNeeded: spaceNeeded, spaceShortage: spaceShortage, spaceLeft: spaceLeft)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Information about the recipient of a shared content invitation.
    public enum InviteeInfo: CustomStringConvertible {
        /// E-mail address of invited user.
        case email(String)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(InviteeInfoSerializer().serialize(self)))"
        }
    }
    open class InviteeInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: InviteeInfo) -> JSON {
            switch value {
                case .email(let arg):
                    var d = ["email": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("email")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> InviteeInfo {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "email":
                            let v = Serialization._StringSerializer.deserialize(d["email"] ?? .null)
                            return InviteeInfo.email(v)
                        case "other":
                            return InviteeInfo.other
                        default:
                            return InviteeInfo.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Information about an invited member of a shared content.
    open class InviteeMembershipInfo: Sharing.MembershipInfo {
        /// Recipient of the invitation.
        public let invitee: Sharing.InviteeInfo
        /// The user this invitation is tied to, if available.
        public let user: Sharing.UserInfo?
        public init(accessType: Sharing.AccessLevel, invitee: Sharing.InviteeInfo, permissions: Array<Sharing.MemberPermission>? = nil, initials: String? = nil, isInherited: Bool = false, user: Sharing.UserInfo? = nil) {
            self.invitee = invitee
            self.user = user
            super.init(accessType: accessType, permissions: permissions, initials: initials, isInherited: isInherited)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(InviteeMembershipInfoSerializer().serialize(self)))"
        }
    }
    open class InviteeMembershipInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: InviteeMembershipInfo) -> JSON {
            let output = [ 
            "access_type": Sharing.AccessLevelSerializer().serialize(value.accessType),
            "invitee": Sharing.InviteeInfoSerializer().serialize(value.invitee),
            "permissions": NullableSerializer(ArraySerializer(Sharing.MemberPermissionSerializer())).serialize(value.permissions),
            "initials": NullableSerializer(Serialization._StringSerializer).serialize(value.initials),
            "is_inherited": Serialization._BoolSerializer.serialize(value.isInherited),
            "user": NullableSerializer(Sharing.UserInfoSerializer()).serialize(value.user),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> InviteeMembershipInfo {
            switch json {
                case .dictionary(let dict):
                    let accessType = Sharing.AccessLevelSerializer().deserialize(dict["access_type"] ?? .null)
                    let invitee = Sharing.InviteeInfoSerializer().deserialize(dict["invitee"] ?? .null)
                    let permissions = NullableSerializer(ArraySerializer(Sharing.MemberPermissionSerializer())).deserialize(dict["permissions"] ?? .null)
                    let initials = NullableSerializer(Serialization._StringSerializer).deserialize(dict["initials"] ?? .null)
                    let isInherited = Serialization._BoolSerializer.deserialize(dict["is_inherited"] ?? .number(0))
                    let user = NullableSerializer(Sharing.UserInfoSerializer()).deserialize(dict["user"] ?? .null)
                    return InviteeMembershipInfo(accessType: accessType, invitee: invitee, permissions: permissions, initials: initials, isInherited: isInherited, user: user)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Error occurred while performing an asynchronous job from unshareFolder or removeFolderMember.
    public enum JobError: CustomStringConvertible {
        /// Error occurred while performing unshareFolder action.
        case unshareFolderError(Sharing.UnshareFolderError)
        /// Error occurred while performing removeFolderMember action.
        case removeFolderMemberError(Sharing.RemoveFolderMemberError)
        /// Error occurred while performing relinquishFolderMembership action.
        case relinquishFolderMembershipError(Sharing.RelinquishFolderMembershipError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(JobErrorSerializer().serialize(self)))"
        }
    }
    open class JobErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: JobError) -> JSON {
            switch value {
                case .unshareFolderError(let arg):
                    var d = ["unshare_folder_error": Sharing.UnshareFolderErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("unshare_folder_error")
                    return .dictionary(d)
                case .removeFolderMemberError(let arg):
                    var d = ["remove_folder_member_error": Sharing.RemoveFolderMemberErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("remove_folder_member_error")
                    return .dictionary(d)
                case .relinquishFolderMembershipError(let arg):
                    var d = ["relinquish_folder_membership_error": Sharing.RelinquishFolderMembershipErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("relinquish_folder_membership_error")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> JobError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "unshare_folder_error":
                            let v = Sharing.UnshareFolderErrorSerializer().deserialize(d["unshare_folder_error"] ?? .null)
                            return JobError.unshareFolderError(v)
                        case "remove_folder_member_error":
                            let v = Sharing.RemoveFolderMemberErrorSerializer().deserialize(d["remove_folder_member_error"] ?? .null)
                            return JobError.removeFolderMemberError(v)
                        case "relinquish_folder_membership_error":
                            let v = Sharing.RelinquishFolderMembershipErrorSerializer().deserialize(d["relinquish_folder_membership_error"] ?? .null)
                            return JobError.relinquishFolderMembershipError(v)
                        case "other":
                            return JobError.other
                        default:
                            return JobError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The JobStatus union
    public enum JobStatus: CustomStringConvertible {
        /// The asynchronous job is still in progress.
        case inProgress
        /// The asynchronous job has finished.
        case complete
        /// The asynchronous job returned an error.
        case failed(Sharing.JobError)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(JobStatusSerializer().serialize(self)))"
        }
    }
    open class JobStatusSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: JobStatus) -> JSON {
            switch value {
                case .inProgress:
                    var d = [String: JSON]()
                    d[".tag"] = .str("in_progress")
                    return .dictionary(d)
                case .complete:
                    var d = [String: JSON]()
                    d[".tag"] = .str("complete")
                    return .dictionary(d)
                case .failed(let arg):
                    var d = ["failed": Sharing.JobErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("failed")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> JobStatus {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "in_progress":
                            return JobStatus.inProgress
                        case "complete":
                            return JobStatus.complete
                        case "failed":
                            let v = Sharing.JobErrorSerializer().deserialize(d["failed"] ?? .null)
                            return JobStatus.failed(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Actions that can be performed on a link.
    public enum LinkAction: CustomStringConvertible {
        /// Change the access level of the link.
        case changeAccessLevel
        /// Change the audience of the link.
        case changeAudience
        /// Remove the expiry date of the link.
        case removeExpiry
        /// Remove the password of the link.
        case removePassword
        /// Create or modify the expiry date of the link.
        case setExpiry
        /// Create or modify the password of the link.
        case setPassword
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(LinkActionSerializer().serialize(self)))"
        }
    }
    open class LinkActionSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: LinkAction) -> JSON {
            switch value {
                case .changeAccessLevel:
                    var d = [String: JSON]()
                    d[".tag"] = .str("change_access_level")
                    return .dictionary(d)
                case .changeAudience:
                    var d = [String: JSON]()
                    d[".tag"] = .str("change_audience")
                    return .dictionary(d)
                case .removeExpiry:
                    var d = [String: JSON]()
                    d[".tag"] = .str("remove_expiry")
                    return .dictionary(d)
                case .removePassword:
                    var d = [String: JSON]()
                    d[".tag"] = .str("remove_password")
                    return .dictionary(d)
                case .setExpiry:
                    var d = [String: JSON]()
                    d[".tag"] = .str("set_expiry")
                    return .dictionary(d)
                case .setPassword:
                    var d = [String: JSON]()
                    d[".tag"] = .str("set_password")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> LinkAction {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "change_access_level":
                            return LinkAction.changeAccessLevel
                        case "change_audience":
                            return LinkAction.changeAudience
                        case "remove_expiry":
                            return LinkAction.removeExpiry
                        case "remove_password":
                            return LinkAction.removePassword
                        case "set_expiry":
                            return LinkAction.setExpiry
                        case "set_password":
                            return LinkAction.setPassword
                        case "other":
                            return LinkAction.other
                        default:
                            return LinkAction.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The LinkAudience union
    public enum LinkAudience: CustomStringConvertible {
        /// Link is accessible by anyone.
        case public_
        /// Link is accessible only by team members.
        case team
        /// The link can be used by no one. The link merely points the user to the content, and does not grant
        /// additional rights to the user. Members of the content who use this link can only access the content with
        /// their pre-existing access rights.
        case noOne
        /// Link is accessible only by members of the content.
        case members
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(LinkAudienceSerializer().serialize(self)))"
        }
    }
    open class LinkAudienceSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: LinkAudience) -> JSON {
            switch value {
                case .public_:
                    var d = [String: JSON]()
                    d[".tag"] = .str("public")
                    return .dictionary(d)
                case .team:
                    var d = [String: JSON]()
                    d[".tag"] = .str("team")
                    return .dictionary(d)
                case .noOne:
                    var d = [String: JSON]()
                    d[".tag"] = .str("no_one")
                    return .dictionary(d)
                case .members:
                    var d = [String: JSON]()
                    d[".tag"] = .str("members")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> LinkAudience {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "public":
                            return LinkAudience.public_
                        case "team":
                            return LinkAudience.team
                        case "no_one":
                            return LinkAudience.noOne
                        case "members":
                            return LinkAudience.members
                        case "other":
                            return LinkAudience.other
                        default:
                            return LinkAudience.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The LinkExpiry union
    public enum LinkExpiry: CustomStringConvertible {
        /// Remove the currently set expiry for the link.
        case removeExpiry
        /// Set a new expiry or change an existing expiry.
        case setExpiry(Date)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(LinkExpirySerializer().serialize(self)))"
        }
    }
    open class LinkExpirySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: LinkExpiry) -> JSON {
            switch value {
                case .removeExpiry:
                    var d = [String: JSON]()
                    d[".tag"] = .str("remove_expiry")
                    return .dictionary(d)
                case .setExpiry(let arg):
                    var d = ["set_expiry": NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(arg)]
                    d[".tag"] = .str("set_expiry")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> LinkExpiry {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "remove_expiry":
                            return LinkExpiry.removeExpiry
                        case "set_expiry":
                            let v = NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(d["set_expiry"] ?? .null)
                            return LinkExpiry.setExpiry(v)
                        case "other":
                            return LinkExpiry.other
                        default:
                            return LinkExpiry.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The LinkPassword union
    public enum LinkPassword: CustomStringConvertible {
        /// Remove the currently set password for the link.
        case removePassword
        /// Set a new password or change an existing password.
        case setPassword(String)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(LinkPasswordSerializer().serialize(self)))"
        }
    }
    open class LinkPasswordSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: LinkPassword) -> JSON {
            switch value {
                case .removePassword:
                    var d = [String: JSON]()
                    d[".tag"] = .str("remove_password")
                    return .dictionary(d)
                case .setPassword(let arg):
                    var d = ["set_password": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("set_password")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> LinkPassword {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "remove_password":
                            return LinkPassword.removePassword
                        case "set_password":
                            let v = Serialization._StringSerializer.deserialize(d["set_password"] ?? .null)
                            return LinkPassword.setPassword(v)
                        case "other":
                            return LinkPassword.other
                        default:
                            return LinkPassword.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Permissions for actions that can be performed on a link.
    open class LinkPermission: CustomStringConvertible {
        /// (no description)
        public let action: Sharing.LinkAction
        /// (no description)
        public let allow: Bool
        /// (no description)
        public let reason: Sharing.PermissionDeniedReason?
        public init(action: Sharing.LinkAction, allow: Bool, reason: Sharing.PermissionDeniedReason? = nil) {
            self.action = action
            self.allow = allow
            self.reason = reason
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(LinkPermissionSerializer().serialize(self)))"
        }
    }
    open class LinkPermissionSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: LinkPermission) -> JSON {
            let output = [ 
            "action": Sharing.LinkActionSerializer().serialize(value.action),
            "allow": Serialization._BoolSerializer.serialize(value.allow),
            "reason": NullableSerializer(Sharing.PermissionDeniedReasonSerializer()).serialize(value.reason),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> LinkPermission {
            switch json {
                case .dictionary(let dict):
                    let action = Sharing.LinkActionSerializer().deserialize(dict["action"] ?? .null)
                    let allow = Serialization._BoolSerializer.deserialize(dict["allow"] ?? .null)
                    let reason = NullableSerializer(Sharing.PermissionDeniedReasonSerializer()).deserialize(dict["reason"] ?? .null)
                    return LinkPermission(action: action, allow: allow, reason: reason)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The LinkPermissions struct
    open class LinkPermissions: CustomStringConvertible {
        /// The current visibility of the link after considering the shared links policies of the the team (in case the
        /// link's owner is part of a team) and the shared folder (in case the linked file is part of a shared folder).
        /// This field is shown only if the caller has access to this info (the link's owner always has access to this
        /// data).
        public let resolvedVisibility: Sharing.ResolvedVisibility?
        /// The shared link's requested visibility. This can be overridden by the team and shared folder policies. The
        /// final visibility, after considering these policies, can be found in resolvedVisibility. This is shown only
        /// if the caller is the link's owner.
        public let requestedVisibility: Sharing.RequestedVisibility?
        /// Whether the caller can revoke the shared link.
        public let canRevoke: Bool
        /// The failure reason for revoking the link. This field will only be present if the canRevoke is false.
        public let revokeFailureReason: Sharing.SharedLinkAccessFailureReason?
        public init(canRevoke: Bool, resolvedVisibility: Sharing.ResolvedVisibility? = nil, requestedVisibility: Sharing.RequestedVisibility? = nil, revokeFailureReason: Sharing.SharedLinkAccessFailureReason? = nil) {
            self.resolvedVisibility = resolvedVisibility
            self.requestedVisibility = requestedVisibility
            self.canRevoke = canRevoke
            self.revokeFailureReason = revokeFailureReason
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(LinkPermissionsSerializer().serialize(self)))"
        }
    }
    open class LinkPermissionsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: LinkPermissions) -> JSON {
            let output = [ 
            "can_revoke": Serialization._BoolSerializer.serialize(value.canRevoke),
            "resolved_visibility": NullableSerializer(Sharing.ResolvedVisibilitySerializer()).serialize(value.resolvedVisibility),
            "requested_visibility": NullableSerializer(Sharing.RequestedVisibilitySerializer()).serialize(value.requestedVisibility),
            "revoke_failure_reason": NullableSerializer(Sharing.SharedLinkAccessFailureReasonSerializer()).serialize(value.revokeFailureReason),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> LinkPermissions {
            switch json {
                case .dictionary(let dict):
                    let canRevoke = Serialization._BoolSerializer.deserialize(dict["can_revoke"] ?? .null)
                    let resolvedVisibility = NullableSerializer(Sharing.ResolvedVisibilitySerializer()).deserialize(dict["resolved_visibility"] ?? .null)
                    let requestedVisibility = NullableSerializer(Sharing.RequestedVisibilitySerializer()).deserialize(dict["requested_visibility"] ?? .null)
                    let revokeFailureReason = NullableSerializer(Sharing.SharedLinkAccessFailureReasonSerializer()).deserialize(dict["revoke_failure_reason"] ?? .null)
                    return LinkPermissions(canRevoke: canRevoke, resolvedVisibility: resolvedVisibility, requestedVisibility: requestedVisibility, revokeFailureReason: revokeFailureReason)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Settings that apply to a link.
    open class LinkSettings: CustomStringConvertible {
        /// The access level on the link for this file. Currently, it only accepts 'viewer' and 'viewer_no_comment'.
        public let accessLevel: Sharing.AccessLevel?
        /// The type of audience on the link for this file.
        public let audience: Sharing.LinkAudience?
        /// An expiry timestamp to set on a link.
        public let expiry: Sharing.LinkExpiry?
        /// The password for the link.
        public let password: Sharing.LinkPassword?
        public init(accessLevel: Sharing.AccessLevel? = nil, audience: Sharing.LinkAudience? = nil, expiry: Sharing.LinkExpiry? = nil, password: Sharing.LinkPassword? = nil) {
            self.accessLevel = accessLevel
            self.audience = audience
            self.expiry = expiry
            self.password = password
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(LinkSettingsSerializer().serialize(self)))"
        }
    }
    open class LinkSettingsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: LinkSettings) -> JSON {
            let output = [ 
            "access_level": NullableSerializer(Sharing.AccessLevelSerializer()).serialize(value.accessLevel),
            "audience": NullableSerializer(Sharing.LinkAudienceSerializer()).serialize(value.audience),
            "expiry": NullableSerializer(Sharing.LinkExpirySerializer()).serialize(value.expiry),
            "password": NullableSerializer(Sharing.LinkPasswordSerializer()).serialize(value.password),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> LinkSettings {
            switch json {
                case .dictionary(let dict):
                    let accessLevel = NullableSerializer(Sharing.AccessLevelSerializer()).deserialize(dict["access_level"] ?? .null)
                    let audience = NullableSerializer(Sharing.LinkAudienceSerializer()).deserialize(dict["audience"] ?? .null)
                    let expiry = NullableSerializer(Sharing.LinkExpirySerializer()).deserialize(dict["expiry"] ?? .null)
                    let password = NullableSerializer(Sharing.LinkPasswordSerializer()).deserialize(dict["password"] ?? .null)
                    return LinkSettings(accessLevel: accessLevel, audience: audience, expiry: expiry, password: password)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Arguments for listFileMembers.
    open class ListFileMembersArg: CustomStringConvertible {
        /// The file for which you want to see members.
        public let file: String
        /// The actions for which to return permissions on a member.
        public let actions: Array<Sharing.MemberAction>?
        /// Whether to include members who only have access from a parent shared folder.
        public let includeInherited: Bool
        /// Number of members to return max per query. Defaults to 100 if no limit is specified.
        public let limit: UInt32
        public init(file: String, actions: Array<Sharing.MemberAction>? = nil, includeInherited: Bool = true, limit: UInt32 = 100) {
            stringValidator(minLength: 1, pattern: "((/|id:).*|nspath:[0-9]+:.*)|ns:[0-9]+(/.*)?")(file)
            self.file = file
            self.actions = actions
            self.includeInherited = includeInherited
            comparableValidator(minValue: 1, maxValue: 300)(limit)
            self.limit = limit
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFileMembersArgSerializer().serialize(self)))"
        }
    }
    open class ListFileMembersArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFileMembersArg) -> JSON {
            let output = [ 
            "file": Serialization._StringSerializer.serialize(value.file),
            "actions": NullableSerializer(ArraySerializer(Sharing.MemberActionSerializer())).serialize(value.actions),
            "include_inherited": Serialization._BoolSerializer.serialize(value.includeInherited),
            "limit": Serialization._UInt32Serializer.serialize(value.limit),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFileMembersArg {
            switch json {
                case .dictionary(let dict):
                    let file = Serialization._StringSerializer.deserialize(dict["file"] ?? .null)
                    let actions = NullableSerializer(ArraySerializer(Sharing.MemberActionSerializer())).deserialize(dict["actions"] ?? .null)
                    let includeInherited = Serialization._BoolSerializer.deserialize(dict["include_inherited"] ?? .number(1))
                    let limit = Serialization._UInt32Serializer.deserialize(dict["limit"] ?? .number(100))
                    return ListFileMembersArg(file: file, actions: actions, includeInherited: includeInherited, limit: limit)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Arguments for listFileMembersBatch.
    open class ListFileMembersBatchArg: CustomStringConvertible {
        /// Files for which to return members.
        public let files: Array<String>
        /// Number of members to return max per query. Defaults to 10 if no limit is specified.
        public let limit: UInt32
        public init(files: Array<String>, limit: UInt32 = 10) {
            arrayValidator(maxItems: 100, itemValidator: stringValidator(minLength: 1, pattern: "((/|id:).*|nspath:[0-9]+:.*)|ns:[0-9]+(/.*)?"))(files)
            self.files = files
            comparableValidator(maxValue: 20)(limit)
            self.limit = limit
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFileMembersBatchArgSerializer().serialize(self)))"
        }
    }
    open class ListFileMembersBatchArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFileMembersBatchArg) -> JSON {
            let output = [ 
            "files": ArraySerializer(Serialization._StringSerializer).serialize(value.files),
            "limit": Serialization._UInt32Serializer.serialize(value.limit),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFileMembersBatchArg {
            switch json {
                case .dictionary(let dict):
                    let files = ArraySerializer(Serialization._StringSerializer).deserialize(dict["files"] ?? .null)
                    let limit = Serialization._UInt32Serializer.deserialize(dict["limit"] ?? .number(10))
                    return ListFileMembersBatchArg(files: files, limit: limit)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Per-file result for listFileMembersBatch.
    open class ListFileMembersBatchResult: CustomStringConvertible {
        /// This is the input file identifier, whether an ID or a path.
        public let file: String
        /// The result for this particular file.
        public let result: Sharing.ListFileMembersIndividualResult
        public init(file: String, result: Sharing.ListFileMembersIndividualResult) {
            stringValidator(minLength: 1, pattern: "((/|id:).*|nspath:[0-9]+:.*)|ns:[0-9]+(/.*)?")(file)
            self.file = file
            self.result = result
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFileMembersBatchResultSerializer().serialize(self)))"
        }
    }
    open class ListFileMembersBatchResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFileMembersBatchResult) -> JSON {
            let output = [ 
            "file": Serialization._StringSerializer.serialize(value.file),
            "result": Sharing.ListFileMembersIndividualResultSerializer().serialize(value.result),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFileMembersBatchResult {
            switch json {
                case .dictionary(let dict):
                    let file = Serialization._StringSerializer.deserialize(dict["file"] ?? .null)
                    let result = Sharing.ListFileMembersIndividualResultSerializer().deserialize(dict["result"] ?? .null)
                    return ListFileMembersBatchResult(file: file, result: result)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Arguments for listFileMembersContinue.
    open class ListFileMembersContinueArg: CustomStringConvertible {
        /// The cursor returned by your last call to listFileMembers, listFileMembersContinue, or listFileMembersBatch.
        public let cursor: String
        public init(cursor: String) {
            stringValidator()(cursor)
            self.cursor = cursor
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFileMembersContinueArgSerializer().serialize(self)))"
        }
    }
    open class ListFileMembersContinueArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFileMembersContinueArg) -> JSON {
            let output = [ 
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFileMembersContinueArg {
            switch json {
                case .dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                    return ListFileMembersContinueArg(cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Error for listFileMembersContinue.
    public enum ListFileMembersContinueError: CustomStringConvertible {
        /// An unspecified error.
        case userError(Sharing.SharingUserError)
        /// An unspecified error.
        case accessError(Sharing.SharingFileAccessError)
        /// cursor in ListFileMembersContinueArg is invalid.
        case invalidCursor
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFileMembersContinueErrorSerializer().serialize(self)))"
        }
    }
    open class ListFileMembersContinueErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFileMembersContinueError) -> JSON {
            switch value {
                case .userError(let arg):
                    var d = ["user_error": Sharing.SharingUserErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("user_error")
                    return .dictionary(d)
                case .accessError(let arg):
                    var d = ["access_error": Sharing.SharingFileAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("access_error")
                    return .dictionary(d)
                case .invalidCursor:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_cursor")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ListFileMembersContinueError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "user_error":
                            let v = Sharing.SharingUserErrorSerializer().deserialize(d["user_error"] ?? .null)
                            return ListFileMembersContinueError.userError(v)
                        case "access_error":
                            let v = Sharing.SharingFileAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                            return ListFileMembersContinueError.accessError(v)
                        case "invalid_cursor":
                            return ListFileMembersContinueError.invalidCursor
                        case "other":
                            return ListFileMembersContinueError.other
                        default:
                            return ListFileMembersContinueError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ListFileMembersCountResult struct
    open class ListFileMembersCountResult: CustomStringConvertible {
        /// A list of members on this file.
        public let members: Sharing.SharedFileMembers
        /// The number of members on this file. This does not include inherited members.
        public let memberCount: UInt32
        public init(members: Sharing.SharedFileMembers, memberCount: UInt32) {
            self.members = members
            comparableValidator()(memberCount)
            self.memberCount = memberCount
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFileMembersCountResultSerializer().serialize(self)))"
        }
    }
    open class ListFileMembersCountResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFileMembersCountResult) -> JSON {
            let output = [ 
            "members": Sharing.SharedFileMembersSerializer().serialize(value.members),
            "member_count": Serialization._UInt32Serializer.serialize(value.memberCount),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFileMembersCountResult {
            switch json {
                case .dictionary(let dict):
                    let members = Sharing.SharedFileMembersSerializer().deserialize(dict["members"] ?? .null)
                    let memberCount = Serialization._UInt32Serializer.deserialize(dict["member_count"] ?? .null)
                    return ListFileMembersCountResult(members: members, memberCount: memberCount)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Error for listFileMembers.
    public enum ListFileMembersError: CustomStringConvertible {
        /// An unspecified error.
        case userError(Sharing.SharingUserError)
        /// An unspecified error.
        case accessError(Sharing.SharingFileAccessError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFileMembersErrorSerializer().serialize(self)))"
        }
    }
    open class ListFileMembersErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFileMembersError) -> JSON {
            switch value {
                case .userError(let arg):
                    var d = ["user_error": Sharing.SharingUserErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("user_error")
                    return .dictionary(d)
                case .accessError(let arg):
                    var d = ["access_error": Sharing.SharingFileAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("access_error")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ListFileMembersError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "user_error":
                            let v = Sharing.SharingUserErrorSerializer().deserialize(d["user_error"] ?? .null)
                            return ListFileMembersError.userError(v)
                        case "access_error":
                            let v = Sharing.SharingFileAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                            return ListFileMembersError.accessError(v)
                        case "other":
                            return ListFileMembersError.other
                        default:
                            return ListFileMembersError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ListFileMembersIndividualResult union
    public enum ListFileMembersIndividualResult: CustomStringConvertible {
        /// The results of the query for this file if it was successful.
        case result(Sharing.ListFileMembersCountResult)
        /// The result of the query for this file if it was an error.
        case accessError(Sharing.SharingFileAccessError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFileMembersIndividualResultSerializer().serialize(self)))"
        }
    }
    open class ListFileMembersIndividualResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFileMembersIndividualResult) -> JSON {
            switch value {
                case .result(let arg):
                    var d = Serialization.getFields(Sharing.ListFileMembersCountResultSerializer().serialize(arg))
                    d[".tag"] = .str("result")
                    return .dictionary(d)
                case .accessError(let arg):
                    var d = ["access_error": Sharing.SharingFileAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("access_error")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ListFileMembersIndividualResult {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "result":
                            let v = Sharing.ListFileMembersCountResultSerializer().deserialize(json)
                            return ListFileMembersIndividualResult.result(v)
                        case "access_error":
                            let v = Sharing.SharingFileAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                            return ListFileMembersIndividualResult.accessError(v)
                        case "other":
                            return ListFileMembersIndividualResult.other
                        default:
                            return ListFileMembersIndividualResult.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Arguments for listReceivedFiles.
    open class ListFilesArg: CustomStringConvertible {
        /// Number of files to return max per query. Defaults to 100 if no limit is specified.
        public let limit: UInt32
        /// A list of `FileAction`s corresponding to `FilePermission`s that should appear in the  response's permissions
        /// in SharedFileMetadata field describing the actions the  authenticated user can perform on the file.
        public let actions: Array<Sharing.FileAction>?
        public init(limit: UInt32 = 100, actions: Array<Sharing.FileAction>? = nil) {
            comparableValidator(minValue: 1, maxValue: 300)(limit)
            self.limit = limit
            self.actions = actions
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFilesArgSerializer().serialize(self)))"
        }
    }
    open class ListFilesArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFilesArg) -> JSON {
            let output = [ 
            "limit": Serialization._UInt32Serializer.serialize(value.limit),
            "actions": NullableSerializer(ArraySerializer(Sharing.FileActionSerializer())).serialize(value.actions),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFilesArg {
            switch json {
                case .dictionary(let dict):
                    let limit = Serialization._UInt32Serializer.deserialize(dict["limit"] ?? .number(100))
                    let actions = NullableSerializer(ArraySerializer(Sharing.FileActionSerializer())).deserialize(dict["actions"] ?? .null)
                    return ListFilesArg(limit: limit, actions: actions)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Arguments for listReceivedFilesContinue.
    open class ListFilesContinueArg: CustomStringConvertible {
        /// Cursor in cursor in ListFilesResult.
        public let cursor: String
        public init(cursor: String) {
            stringValidator()(cursor)
            self.cursor = cursor
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFilesContinueArgSerializer().serialize(self)))"
        }
    }
    open class ListFilesContinueArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFilesContinueArg) -> JSON {
            let output = [ 
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFilesContinueArg {
            switch json {
                case .dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                    return ListFilesContinueArg(cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Error results for listReceivedFilesContinue.
    public enum ListFilesContinueError: CustomStringConvertible {
        /// User account had a problem.
        case userError(Sharing.SharingUserError)
        /// cursor in ListFilesContinueArg is invalid.
        case invalidCursor
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFilesContinueErrorSerializer().serialize(self)))"
        }
    }
    open class ListFilesContinueErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFilesContinueError) -> JSON {
            switch value {
                case .userError(let arg):
                    var d = ["user_error": Sharing.SharingUserErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("user_error")
                    return .dictionary(d)
                case .invalidCursor:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_cursor")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ListFilesContinueError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "user_error":
                            let v = Sharing.SharingUserErrorSerializer().deserialize(d["user_error"] ?? .null)
                            return ListFilesContinueError.userError(v)
                        case "invalid_cursor":
                            return ListFilesContinueError.invalidCursor
                        case "other":
                            return ListFilesContinueError.other
                        default:
                            return ListFilesContinueError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Success results for listReceivedFiles.
    open class ListFilesResult: CustomStringConvertible {
        /// Information about the files shared with current user.
        public let entries: Array<Sharing.SharedFileMetadata>
        /// Cursor used to obtain additional shared files.
        public let cursor: String?
        public init(entries: Array<Sharing.SharedFileMetadata>, cursor: String? = nil) {
            self.entries = entries
            nullableValidator(stringValidator())(cursor)
            self.cursor = cursor
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFilesResultSerializer().serialize(self)))"
        }
    }
    open class ListFilesResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFilesResult) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Sharing.SharedFileMetadataSerializer()).serialize(value.entries),
            "cursor": NullableSerializer(Serialization._StringSerializer).serialize(value.cursor),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFilesResult {
            switch json {
                case .dictionary(let dict):
                    let entries = ArraySerializer(Sharing.SharedFileMetadataSerializer()).deserialize(dict["entries"] ?? .null)
                    let cursor = NullableSerializer(Serialization._StringSerializer).deserialize(dict["cursor"] ?? .null)
                    return ListFilesResult(entries: entries, cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListFolderMembersCursorArg struct
    open class ListFolderMembersCursorArg: CustomStringConvertible {
        /// This is a list indicating whether each returned member will include a boolean value allow in
        /// MemberPermission that describes whether the current user can perform the MemberAction on the member.
        public let actions: Array<Sharing.MemberAction>?
        /// The maximum number of results that include members, groups and invitees to return per request.
        public let limit: UInt32
        public init(actions: Array<Sharing.MemberAction>? = nil, limit: UInt32 = 1000) {
            self.actions = actions
            comparableValidator(minValue: 1, maxValue: 1000)(limit)
            self.limit = limit
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFolderMembersCursorArgSerializer().serialize(self)))"
        }
    }
    open class ListFolderMembersCursorArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFolderMembersCursorArg) -> JSON {
            let output = [ 
            "actions": NullableSerializer(ArraySerializer(Sharing.MemberActionSerializer())).serialize(value.actions),
            "limit": Serialization._UInt32Serializer.serialize(value.limit),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFolderMembersCursorArg {
            switch json {
                case .dictionary(let dict):
                    let actions = NullableSerializer(ArraySerializer(Sharing.MemberActionSerializer())).deserialize(dict["actions"] ?? .null)
                    let limit = Serialization._UInt32Serializer.deserialize(dict["limit"] ?? .number(1000))
                    return ListFolderMembersCursorArg(actions: actions, limit: limit)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListFolderMembersArgs struct
    open class ListFolderMembersArgs: Sharing.ListFolderMembersCursorArg {
        /// The ID for the shared folder.
        public let sharedFolderId: String
        public init(sharedFolderId: String, actions: Array<Sharing.MemberAction>? = nil, limit: UInt32 = 1000) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            super.init(actions: actions, limit: limit)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFolderMembersArgsSerializer().serialize(self)))"
        }
    }
    open class ListFolderMembersArgsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFolderMembersArgs) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            "actions": NullableSerializer(ArraySerializer(Sharing.MemberActionSerializer())).serialize(value.actions),
            "limit": Serialization._UInt32Serializer.serialize(value.limit),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFolderMembersArgs {
            switch json {
                case .dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                    let actions = NullableSerializer(ArraySerializer(Sharing.MemberActionSerializer())).deserialize(dict["actions"] ?? .null)
                    let limit = Serialization._UInt32Serializer.deserialize(dict["limit"] ?? .number(1000))
                    return ListFolderMembersArgs(sharedFolderId: sharedFolderId, actions: actions, limit: limit)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListFolderMembersContinueArg struct
    open class ListFolderMembersContinueArg: CustomStringConvertible {
        /// The cursor returned by your last call to listFolderMembers or listFolderMembersContinue.
        public let cursor: String
        public init(cursor: String) {
            stringValidator()(cursor)
            self.cursor = cursor
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFolderMembersContinueArgSerializer().serialize(self)))"
        }
    }
    open class ListFolderMembersContinueArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFolderMembersContinueArg) -> JSON {
            let output = [ 
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFolderMembersContinueArg {
            switch json {
                case .dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                    return ListFolderMembersContinueArg(cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListFolderMembersContinueError union
    public enum ListFolderMembersContinueError: CustomStringConvertible {
        /// An unspecified error.
        case accessError(Sharing.SharedFolderAccessError)
        /// cursor in ListFolderMembersContinueArg is invalid.
        case invalidCursor
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFolderMembersContinueErrorSerializer().serialize(self)))"
        }
    }
    open class ListFolderMembersContinueErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFolderMembersContinueError) -> JSON {
            switch value {
                case .accessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("access_error")
                    return .dictionary(d)
                case .invalidCursor:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_cursor")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ListFolderMembersContinueError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                            return ListFolderMembersContinueError.accessError(v)
                        case "invalid_cursor":
                            return ListFolderMembersContinueError.invalidCursor
                        case "other":
                            return ListFolderMembersContinueError.other
                        default:
                            return ListFolderMembersContinueError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ListFoldersArgs struct
    open class ListFoldersArgs: CustomStringConvertible {
        /// The maximum number of results to return per request.
        public let limit: UInt32
        /// A list of `FolderAction`s corresponding to `FolderPermission`s that should appear in the  response's
        /// permissions in SharedFolderMetadata field describing the actions the  authenticated user can perform on the
        /// folder.
        public let actions: Array<Sharing.FolderAction>?
        public init(limit: UInt32 = 1000, actions: Array<Sharing.FolderAction>? = nil) {
            comparableValidator(minValue: 1, maxValue: 1000)(limit)
            self.limit = limit
            self.actions = actions
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFoldersArgsSerializer().serialize(self)))"
        }
    }
    open class ListFoldersArgsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFoldersArgs) -> JSON {
            let output = [ 
            "limit": Serialization._UInt32Serializer.serialize(value.limit),
            "actions": NullableSerializer(ArraySerializer(Sharing.FolderActionSerializer())).serialize(value.actions),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFoldersArgs {
            switch json {
                case .dictionary(let dict):
                    let limit = Serialization._UInt32Serializer.deserialize(dict["limit"] ?? .number(1000))
                    let actions = NullableSerializer(ArraySerializer(Sharing.FolderActionSerializer())).deserialize(dict["actions"] ?? .null)
                    return ListFoldersArgs(limit: limit, actions: actions)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListFoldersContinueArg struct
    open class ListFoldersContinueArg: CustomStringConvertible {
        /// The cursor returned by the previous API call specified in the endpoint description.
        public let cursor: String
        public init(cursor: String) {
            stringValidator()(cursor)
            self.cursor = cursor
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFoldersContinueArgSerializer().serialize(self)))"
        }
    }
    open class ListFoldersContinueArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFoldersContinueArg) -> JSON {
            let output = [ 
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFoldersContinueArg {
            switch json {
                case .dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                    return ListFoldersContinueArg(cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListFoldersContinueError union
    public enum ListFoldersContinueError: CustomStringConvertible {
        /// cursor in ListFoldersContinueArg is invalid.
        case invalidCursor
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFoldersContinueErrorSerializer().serialize(self)))"
        }
    }
    open class ListFoldersContinueErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFoldersContinueError) -> JSON {
            switch value {
                case .invalidCursor:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_cursor")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ListFoldersContinueError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "invalid_cursor":
                            return ListFoldersContinueError.invalidCursor
                        case "other":
                            return ListFoldersContinueError.other
                        default:
                            return ListFoldersContinueError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Result for listFolders or listMountableFolders, depending on which endpoint was requested. Unmounted shared
    /// folders can be identified by the absence of pathLower in SharedFolderMetadata.
    open class ListFoldersResult: CustomStringConvertible {
        /// List of all shared folders the authenticated user has access to.
        public let entries: Array<Sharing.SharedFolderMetadata>
        /// Present if there are additional shared folders that have not been returned yet. Pass the cursor into the
        /// corresponding continue endpoint (either listFoldersContinue or listMountableFoldersContinue) to list
        /// additional folders.
        public let cursor: String?
        public init(entries: Array<Sharing.SharedFolderMetadata>, cursor: String? = nil) {
            self.entries = entries
            nullableValidator(stringValidator())(cursor)
            self.cursor = cursor
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFoldersResultSerializer().serialize(self)))"
        }
    }
    open class ListFoldersResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFoldersResult) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Sharing.SharedFolderMetadataSerializer()).serialize(value.entries),
            "cursor": NullableSerializer(Serialization._StringSerializer).serialize(value.cursor),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFoldersResult {
            switch json {
                case .dictionary(let dict):
                    let entries = ArraySerializer(Sharing.SharedFolderMetadataSerializer()).deserialize(dict["entries"] ?? .null)
                    let cursor = NullableSerializer(Serialization._StringSerializer).deserialize(dict["cursor"] ?? .null)
                    return ListFoldersResult(entries: entries, cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListSharedLinksArg struct
    open class ListSharedLinksArg: CustomStringConvertible {
        /// See listSharedLinks description.
        public let path: String?
        /// The cursor returned by your last call to listSharedLinks.
        public let cursor: String?
        /// See listSharedLinks description.
        public let directOnly: Bool?
        public init(path: String? = nil, cursor: String? = nil, directOnly: Bool? = nil) {
            nullableValidator(stringValidator(pattern: "(/(.|[\\r\\n])*|id:.*)|(rev:[0-9a-f]{9,})|(ns:[0-9]+(/.*)?)"))(path)
            self.path = path
            nullableValidator(stringValidator())(cursor)
            self.cursor = cursor
            self.directOnly = directOnly
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListSharedLinksArgSerializer().serialize(self)))"
        }
    }
    open class ListSharedLinksArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListSharedLinksArg) -> JSON {
            let output = [ 
            "path": NullableSerializer(Serialization._StringSerializer).serialize(value.path),
            "cursor": NullableSerializer(Serialization._StringSerializer).serialize(value.cursor),
            "direct_only": NullableSerializer(Serialization._BoolSerializer).serialize(value.directOnly),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListSharedLinksArg {
            switch json {
                case .dictionary(let dict):
                    let path = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path"] ?? .null)
                    let cursor = NullableSerializer(Serialization._StringSerializer).deserialize(dict["cursor"] ?? .null)
                    let directOnly = NullableSerializer(Serialization._BoolSerializer).deserialize(dict["direct_only"] ?? .null)
                    return ListSharedLinksArg(path: path, cursor: cursor, directOnly: directOnly)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListSharedLinksError union
    public enum ListSharedLinksError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.LookupError)
        /// Indicates that the cursor has been invalidated. Call listSharedLinks to obtain a new cursor.
        case reset
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListSharedLinksErrorSerializer().serialize(self)))"
        }
    }
    open class ListSharedLinksErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListSharedLinksError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .reset:
                    var d = [String: JSON]()
                    d[".tag"] = .str("reset")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ListSharedLinksError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return ListSharedLinksError.path(v)
                        case "reset":
                            return ListSharedLinksError.reset
                        case "other":
                            return ListSharedLinksError.other
                        default:
                            return ListSharedLinksError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ListSharedLinksResult struct
    open class ListSharedLinksResult: CustomStringConvertible {
        /// Shared links applicable to the path argument.
        public let links: Array<Sharing.SharedLinkMetadata>
        /// Is true if there are additional shared links that have not been returned yet. Pass the cursor into
        /// listSharedLinks to retrieve them.
        public let hasMore: Bool
        /// Pass the cursor into listSharedLinks to obtain the additional links. Cursor is returned only if no path is
        /// given.
        public let cursor: String?
        public init(links: Array<Sharing.SharedLinkMetadata>, hasMore: Bool, cursor: String? = nil) {
            self.links = links
            self.hasMore = hasMore
            nullableValidator(stringValidator())(cursor)
            self.cursor = cursor
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListSharedLinksResultSerializer().serialize(self)))"
        }
    }
    open class ListSharedLinksResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListSharedLinksResult) -> JSON {
            let output = [ 
            "links": ArraySerializer(Sharing.SharedLinkMetadataSerializer()).serialize(value.links),
            "has_more": Serialization._BoolSerializer.serialize(value.hasMore),
            "cursor": NullableSerializer(Serialization._StringSerializer).serialize(value.cursor),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListSharedLinksResult {
            switch json {
                case .dictionary(let dict):
                    let links = ArraySerializer(Sharing.SharedLinkMetadataSerializer()).deserialize(dict["links"] ?? .null)
                    let hasMore = Serialization._BoolSerializer.deserialize(dict["has_more"] ?? .null)
                    let cursor = NullableSerializer(Serialization._StringSerializer).deserialize(dict["cursor"] ?? .null)
                    return ListSharedLinksResult(links: links, hasMore: hasMore, cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Contains information about a member's access level to content after an operation.
    open class MemberAccessLevelResult: CustomStringConvertible {
        /// The member still has this level of access to the content through a parent folder.
        public let accessLevel: Sharing.AccessLevel?
        /// A localized string with additional information about why the user has this access level to the content.
        public let warning: String?
        /// The parent folders that a member has access to. The field is present if the user has access to the first
        /// parent folder where the member gains access.
        public let accessDetails: Array<Sharing.ParentFolderAccessInfo>?
        public init(accessLevel: Sharing.AccessLevel? = nil, warning: String? = nil, accessDetails: Array<Sharing.ParentFolderAccessInfo>? = nil) {
            self.accessLevel = accessLevel
            nullableValidator(stringValidator())(warning)
            self.warning = warning
            self.accessDetails = accessDetails
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberAccessLevelResultSerializer().serialize(self)))"
        }
    }
    open class MemberAccessLevelResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberAccessLevelResult) -> JSON {
            let output = [ 
            "access_level": NullableSerializer(Sharing.AccessLevelSerializer()).serialize(value.accessLevel),
            "warning": NullableSerializer(Serialization._StringSerializer).serialize(value.warning),
            "access_details": NullableSerializer(ArraySerializer(Sharing.ParentFolderAccessInfoSerializer())).serialize(value.accessDetails),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberAccessLevelResult {
            switch json {
                case .dictionary(let dict):
                    let accessLevel = NullableSerializer(Sharing.AccessLevelSerializer()).deserialize(dict["access_level"] ?? .null)
                    let warning = NullableSerializer(Serialization._StringSerializer).deserialize(dict["warning"] ?? .null)
                    let accessDetails = NullableSerializer(ArraySerializer(Sharing.ParentFolderAccessInfoSerializer())).deserialize(dict["access_details"] ?? .null)
                    return MemberAccessLevelResult(accessLevel: accessLevel, warning: warning, accessDetails: accessDetails)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Actions that may be taken on members of a shared folder.
    public enum MemberAction: CustomStringConvertible {
        /// Allow the member to keep a copy of the folder when removing.
        case leaveACopy
        /// Make the member an editor of the folder.
        case makeEditor
        /// Make the member an owner of the folder.
        case makeOwner
        /// Make the member a viewer of the folder.
        case makeViewer
        /// Make the member a viewer of the folder without commenting permissions.
        case makeViewerNoComment
        /// Remove the member from the folder.
        case remove
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberActionSerializer().serialize(self)))"
        }
    }
    open class MemberActionSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberAction) -> JSON {
            switch value {
                case .leaveACopy:
                    var d = [String: JSON]()
                    d[".tag"] = .str("leave_a_copy")
                    return .dictionary(d)
                case .makeEditor:
                    var d = [String: JSON]()
                    d[".tag"] = .str("make_editor")
                    return .dictionary(d)
                case .makeOwner:
                    var d = [String: JSON]()
                    d[".tag"] = .str("make_owner")
                    return .dictionary(d)
                case .makeViewer:
                    var d = [String: JSON]()
                    d[".tag"] = .str("make_viewer")
                    return .dictionary(d)
                case .makeViewerNoComment:
                    var d = [String: JSON]()
                    d[".tag"] = .str("make_viewer_no_comment")
                    return .dictionary(d)
                case .remove:
                    var d = [String: JSON]()
                    d[".tag"] = .str("remove")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> MemberAction {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "leave_a_copy":
                            return MemberAction.leaveACopy
                        case "make_editor":
                            return MemberAction.makeEditor
                        case "make_owner":
                            return MemberAction.makeOwner
                        case "make_viewer":
                            return MemberAction.makeViewer
                        case "make_viewer_no_comment":
                            return MemberAction.makeViewerNoComment
                        case "remove":
                            return MemberAction.remove
                        case "other":
                            return MemberAction.other
                        default:
                            return MemberAction.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Whether the user is allowed to take the action on the associated member.
    open class MemberPermission: CustomStringConvertible {
        /// The action that the user may wish to take on the member.
        public let action: Sharing.MemberAction
        /// True if the user is allowed to take the action.
        public let allow: Bool
        /// The reason why the user is denied the permission. Not present if the action is allowed.
        public let reason: Sharing.PermissionDeniedReason?
        public init(action: Sharing.MemberAction, allow: Bool, reason: Sharing.PermissionDeniedReason? = nil) {
            self.action = action
            self.allow = allow
            self.reason = reason
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberPermissionSerializer().serialize(self)))"
        }
    }
    open class MemberPermissionSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberPermission) -> JSON {
            let output = [ 
            "action": Sharing.MemberActionSerializer().serialize(value.action),
            "allow": Serialization._BoolSerializer.serialize(value.allow),
            "reason": NullableSerializer(Sharing.PermissionDeniedReasonSerializer()).serialize(value.reason),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberPermission {
            switch json {
                case .dictionary(let dict):
                    let action = Sharing.MemberActionSerializer().deserialize(dict["action"] ?? .null)
                    let allow = Serialization._BoolSerializer.deserialize(dict["allow"] ?? .null)
                    let reason = NullableSerializer(Sharing.PermissionDeniedReasonSerializer()).deserialize(dict["reason"] ?? .null)
                    return MemberPermission(action: action, allow: allow, reason: reason)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Policy governing who can be a member of a shared folder. Only applicable to folders owned by a user on a team.
    public enum MemberPolicy: CustomStringConvertible {
        /// Only a teammate can become a member.
        case team
        /// Anyone can become a member.
        case anyone
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberPolicySerializer().serialize(self)))"
        }
    }
    open class MemberPolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberPolicy) -> JSON {
            switch value {
                case .team:
                    var d = [String: JSON]()
                    d[".tag"] = .str("team")
                    return .dictionary(d)
                case .anyone:
                    var d = [String: JSON]()
                    d[".tag"] = .str("anyone")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> MemberPolicy {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "team":
                            return MemberPolicy.team
                        case "anyone":
                            return MemberPolicy.anyone
                        case "other":
                            return MemberPolicy.other
                        default:
                            return MemberPolicy.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Includes different ways to identify a member of a shared folder.
    public enum MemberSelector: CustomStringConvertible {
        /// Dropbox account, team member, or group ID of member.
        case dropboxId(String)
        /// E-mail address of member.
        case email(String)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberSelectorSerializer().serialize(self)))"
        }
    }
    open class MemberSelectorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberSelector) -> JSON {
            switch value {
                case .dropboxId(let arg):
                    var d = ["dropbox_id": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("dropbox_id")
                    return .dictionary(d)
                case .email(let arg):
                    var d = ["email": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("email")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> MemberSelector {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "dropbox_id":
                            let v = Serialization._StringSerializer.deserialize(d["dropbox_id"] ?? .null)
                            return MemberSelector.dropboxId(v)
                        case "email":
                            let v = Serialization._StringSerializer.deserialize(d["email"] ?? .null)
                            return MemberSelector.email(v)
                        case "other":
                            return MemberSelector.other
                        default:
                            return MemberSelector.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ModifySharedLinkSettingsArgs struct
    open class ModifySharedLinkSettingsArgs: CustomStringConvertible {
        /// URL of the shared link to change its settings.
        public let url: String
        /// Set of settings for the shared link.
        public let settings: Sharing.SharedLinkSettings
        /// If set to true, removes the expiration of the shared link.
        public let removeExpiration: Bool
        public init(url: String, settings: Sharing.SharedLinkSettings, removeExpiration: Bool = false) {
            stringValidator()(url)
            self.url = url
            self.settings = settings
            self.removeExpiration = removeExpiration
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ModifySharedLinkSettingsArgsSerializer().serialize(self)))"
        }
    }
    open class ModifySharedLinkSettingsArgsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ModifySharedLinkSettingsArgs) -> JSON {
            let output = [ 
            "url": Serialization._StringSerializer.serialize(value.url),
            "settings": Sharing.SharedLinkSettingsSerializer().serialize(value.settings),
            "remove_expiration": Serialization._BoolSerializer.serialize(value.removeExpiration),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ModifySharedLinkSettingsArgs {
            switch json {
                case .dictionary(let dict):
                    let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .null)
                    let settings = Sharing.SharedLinkSettingsSerializer().deserialize(dict["settings"] ?? .null)
                    let removeExpiration = Serialization._BoolSerializer.deserialize(dict["remove_expiration"] ?? .number(0))
                    return ModifySharedLinkSettingsArgs(url: url, settings: settings, removeExpiration: removeExpiration)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ModifySharedLinkSettingsError union
    public enum ModifySharedLinkSettingsError: CustomStringConvertible {
        /// The shared link wasn't found.
        case sharedLinkNotFound
        /// The caller is not allowed to access this shared link.
        case sharedLinkAccessDenied
        /// This type of link is not supported.
        case unsupportedLinkType
        /// An unspecified error.
        case other
        /// There is an error with the given settings.
        case settingsError(Sharing.SharedLinkSettingsError)
        /// The caller's email should be verified.
        case emailNotVerified

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ModifySharedLinkSettingsErrorSerializer().serialize(self)))"
        }
    }
    open class ModifySharedLinkSettingsErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ModifySharedLinkSettingsError) -> JSON {
            switch value {
                case .sharedLinkNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("shared_link_not_found")
                    return .dictionary(d)
                case .sharedLinkAccessDenied:
                    var d = [String: JSON]()
                    d[".tag"] = .str("shared_link_access_denied")
                    return .dictionary(d)
                case .unsupportedLinkType:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unsupported_link_type")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .settingsError(let arg):
                    var d = ["settings_error": Sharing.SharedLinkSettingsErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("settings_error")
                    return .dictionary(d)
                case .emailNotVerified:
                    var d = [String: JSON]()
                    d[".tag"] = .str("email_not_verified")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ModifySharedLinkSettingsError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "shared_link_not_found":
                            return ModifySharedLinkSettingsError.sharedLinkNotFound
                        case "shared_link_access_denied":
                            return ModifySharedLinkSettingsError.sharedLinkAccessDenied
                        case "unsupported_link_type":
                            return ModifySharedLinkSettingsError.unsupportedLinkType
                        case "other":
                            return ModifySharedLinkSettingsError.other
                        case "settings_error":
                            let v = Sharing.SharedLinkSettingsErrorSerializer().deserialize(d["settings_error"] ?? .null)
                            return ModifySharedLinkSettingsError.settingsError(v)
                        case "email_not_verified":
                            return ModifySharedLinkSettingsError.emailNotVerified
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The MountFolderArg struct
    open class MountFolderArg: CustomStringConvertible {
        /// The ID of the shared folder to mount.
        public let sharedFolderId: String
        public init(sharedFolderId: String) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MountFolderArgSerializer().serialize(self)))"
        }
    }
    open class MountFolderArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MountFolderArg) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MountFolderArg {
            switch json {
                case .dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                    return MountFolderArg(sharedFolderId: sharedFolderId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MountFolderError union
    public enum MountFolderError: CustomStringConvertible {
        /// An unspecified error.
        case accessError(Sharing.SharedFolderAccessError)
        /// Mounting would cause a shared folder to be inside another, which is disallowed.
        case insideSharedFolder
        /// The current user does not have enough space to mount the shared folder.
        case insufficientQuota(Sharing.InsufficientQuotaAmounts)
        /// The shared folder is already mounted.
        case alreadyMounted
        /// The current user does not have permission to perform this action.
        case noPermission
        /// The shared folder is not mountable. One example where this can occur is when the shared folder belongs
        /// within a team folder in the user's Dropbox.
        case notMountable
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MountFolderErrorSerializer().serialize(self)))"
        }
    }
    open class MountFolderErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MountFolderError) -> JSON {
            switch value {
                case .accessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("access_error")
                    return .dictionary(d)
                case .insideSharedFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("inside_shared_folder")
                    return .dictionary(d)
                case .insufficientQuota(let arg):
                    var d = Serialization.getFields(Sharing.InsufficientQuotaAmountsSerializer().serialize(arg))
                    d[".tag"] = .str("insufficient_quota")
                    return .dictionary(d)
                case .alreadyMounted:
                    var d = [String: JSON]()
                    d[".tag"] = .str("already_mounted")
                    return .dictionary(d)
                case .noPermission:
                    var d = [String: JSON]()
                    d[".tag"] = .str("no_permission")
                    return .dictionary(d)
                case .notMountable:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_mountable")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> MountFolderError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                            return MountFolderError.accessError(v)
                        case "inside_shared_folder":
                            return MountFolderError.insideSharedFolder
                        case "insufficient_quota":
                            let v = Sharing.InsufficientQuotaAmountsSerializer().deserialize(json)
                            return MountFolderError.insufficientQuota(v)
                        case "already_mounted":
                            return MountFolderError.alreadyMounted
                        case "no_permission":
                            return MountFolderError.noPermission
                        case "not_mountable":
                            return MountFolderError.notMountable
                        case "other":
                            return MountFolderError.other
                        default:
                            return MountFolderError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Contains information about a parent folder that a member has access to.
    open class ParentFolderAccessInfo: CustomStringConvertible {
        /// Display name for the folder.
        public let folderName: String
        /// The identifier of the parent shared folder.
        public let sharedFolderId: String
        /// The user's permissions for the parent shared folder.
        public let permissions: Array<Sharing.MemberPermission>
        /// The full path to the parent shared folder relative to the acting user's root.
        public let path: String
        public init(folderName: String, sharedFolderId: String, permissions: Array<Sharing.MemberPermission>, path: String) {
            stringValidator()(folderName)
            self.folderName = folderName
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.permissions = permissions
            stringValidator()(path)
            self.path = path
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ParentFolderAccessInfoSerializer().serialize(self)))"
        }
    }
    open class ParentFolderAccessInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ParentFolderAccessInfo) -> JSON {
            let output = [ 
            "folder_name": Serialization._StringSerializer.serialize(value.folderName),
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            "permissions": ArraySerializer(Sharing.MemberPermissionSerializer()).serialize(value.permissions),
            "path": Serialization._StringSerializer.serialize(value.path),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ParentFolderAccessInfo {
            switch json {
                case .dictionary(let dict):
                    let folderName = Serialization._StringSerializer.deserialize(dict["folder_name"] ?? .null)
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                    let permissions = ArraySerializer(Sharing.MemberPermissionSerializer()).deserialize(dict["permissions"] ?? .null)
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    return ParentFolderAccessInfo(folderName: folderName, sharedFolderId: sharedFolderId, permissions: permissions, path: path)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Metadata for a path-based shared link.
    open class PathLinkMetadata: Sharing.LinkMetadata {
        /// Path in user's Dropbox.
        public let path: String
        public init(url: String, visibility: Sharing.Visibility, path: String, expires: Date? = nil) {
            stringValidator()(path)
            self.path = path
            super.init(url: url, visibility: visibility, expires: expires)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PathLinkMetadataSerializer().serialize(self)))"
        }
    }
    open class PathLinkMetadataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PathLinkMetadata) -> JSON {
            let output = [ 
            "url": Serialization._StringSerializer.serialize(value.url),
            "visibility": Sharing.VisibilitySerializer().serialize(value.visibility),
            "path": Serialization._StringSerializer.serialize(value.path),
            "expires": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.expires),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PathLinkMetadata {
            switch json {
                case .dictionary(let dict):
                    let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .null)
                    let visibility = Sharing.VisibilitySerializer().deserialize(dict["visibility"] ?? .null)
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let expires = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["expires"] ?? .null)
                    return PathLinkMetadata(url: url, visibility: visibility, path: path, expires: expires)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Flag to indicate pending upload default (for linking to not-yet-existing paths).
    public enum PendingUploadMode: CustomStringConvertible {
        /// Assume pending uploads are files.
        case file
        /// Assume pending uploads are folders.
        case folder

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PendingUploadModeSerializer().serialize(self)))"
        }
    }
    open class PendingUploadModeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PendingUploadMode) -> JSON {
            switch value {
                case .file:
                    var d = [String: JSON]()
                    d[".tag"] = .str("file")
                    return .dictionary(d)
                case .folder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("folder")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> PendingUploadMode {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "file":
                            return PendingUploadMode.file
                        case "folder":
                            return PendingUploadMode.folder
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Possible reasons the user is denied a permission.
    public enum PermissionDeniedReason: CustomStringConvertible {
        /// User is not on the same team as the folder owner.
        case userNotSameTeamAsOwner
        /// User is prohibited by the owner from taking the action.
        case userNotAllowedByOwner
        /// Target is indirectly a member of the folder, for example by being part of a group.
        case targetIsIndirectMember
        /// Target is the owner of the folder.
        case targetIsOwner
        /// Target is the user itself.
        case targetIsSelf
        /// Target is not an active member of the team.
        case targetNotActive
        /// Folder is team folder for a limited team.
        case folderIsLimitedTeamFolder
        /// The content owner needs to be on a Dropbox team to perform this action.
        case ownerNotOnTeam
        /// The user does not have permission to perform this action on the link.
        case permissionDenied
        /// The user's team policy prevents performing this action on the link.
        case restrictedByTeam
        /// The user's account type does not support this action.
        case userAccountType
        /// The user needs to be on a Dropbox team to perform this action.
        case userNotOnTeam
        /// Folder is inside of another shared folder.
        case folderIsInsideSharedFolder
        /// Policy cannot be changed due to restrictions from parent folder.
        case restrictedByParentFolder
        /// An unspecified error.
        case insufficientPlan(Sharing.InsufficientPlan)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PermissionDeniedReasonSerializer().serialize(self)))"
        }
    }
    open class PermissionDeniedReasonSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PermissionDeniedReason) -> JSON {
            switch value {
                case .userNotSameTeamAsOwner:
                    var d = [String: JSON]()
                    d[".tag"] = .str("user_not_same_team_as_owner")
                    return .dictionary(d)
                case .userNotAllowedByOwner:
                    var d = [String: JSON]()
                    d[".tag"] = .str("user_not_allowed_by_owner")
                    return .dictionary(d)
                case .targetIsIndirectMember:
                    var d = [String: JSON]()
                    d[".tag"] = .str("target_is_indirect_member")
                    return .dictionary(d)
                case .targetIsOwner:
                    var d = [String: JSON]()
                    d[".tag"] = .str("target_is_owner")
                    return .dictionary(d)
                case .targetIsSelf:
                    var d = [String: JSON]()
                    d[".tag"] = .str("target_is_self")
                    return .dictionary(d)
                case .targetNotActive:
                    var d = [String: JSON]()
                    d[".tag"] = .str("target_not_active")
                    return .dictionary(d)
                case .folderIsLimitedTeamFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("folder_is_limited_team_folder")
                    return .dictionary(d)
                case .ownerNotOnTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .str("owner_not_on_team")
                    return .dictionary(d)
                case .permissionDenied:
                    var d = [String: JSON]()
                    d[".tag"] = .str("permission_denied")
                    return .dictionary(d)
                case .restrictedByTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .str("restricted_by_team")
                    return .dictionary(d)
                case .userAccountType:
                    var d = [String: JSON]()
                    d[".tag"] = .str("user_account_type")
                    return .dictionary(d)
                case .userNotOnTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .str("user_not_on_team")
                    return .dictionary(d)
                case .folderIsInsideSharedFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("folder_is_inside_shared_folder")
                    return .dictionary(d)
                case .restrictedByParentFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("restricted_by_parent_folder")
                    return .dictionary(d)
                case .insufficientPlan(let arg):
                    var d = Serialization.getFields(Sharing.InsufficientPlanSerializer().serialize(arg))
                    d[".tag"] = .str("insufficient_plan")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> PermissionDeniedReason {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "user_not_same_team_as_owner":
                            return PermissionDeniedReason.userNotSameTeamAsOwner
                        case "user_not_allowed_by_owner":
                            return PermissionDeniedReason.userNotAllowedByOwner
                        case "target_is_indirect_member":
                            return PermissionDeniedReason.targetIsIndirectMember
                        case "target_is_owner":
                            return PermissionDeniedReason.targetIsOwner
                        case "target_is_self":
                            return PermissionDeniedReason.targetIsSelf
                        case "target_not_active":
                            return PermissionDeniedReason.targetNotActive
                        case "folder_is_limited_team_folder":
                            return PermissionDeniedReason.folderIsLimitedTeamFolder
                        case "owner_not_on_team":
                            return PermissionDeniedReason.ownerNotOnTeam
                        case "permission_denied":
                            return PermissionDeniedReason.permissionDenied
                        case "restricted_by_team":
                            return PermissionDeniedReason.restrictedByTeam
                        case "user_account_type":
                            return PermissionDeniedReason.userAccountType
                        case "user_not_on_team":
                            return PermissionDeniedReason.userNotOnTeam
                        case "folder_is_inside_shared_folder":
                            return PermissionDeniedReason.folderIsInsideSharedFolder
                        case "restricted_by_parent_folder":
                            return PermissionDeniedReason.restrictedByParentFolder
                        case "insufficient_plan":
                            let v = Sharing.InsufficientPlanSerializer().deserialize(json)
                            return PermissionDeniedReason.insufficientPlan(v)
                        case "other":
                            return PermissionDeniedReason.other
                        default:
                            return PermissionDeniedReason.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The RelinquishFileMembershipArg struct
    open class RelinquishFileMembershipArg: CustomStringConvertible {
        /// The path or id for the file.
        public let file: String
        public init(file: String) {
            stringValidator(minLength: 1, pattern: "((/|id:).*|nspath:[0-9]+:.*)|ns:[0-9]+(/.*)?")(file)
            self.file = file
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelinquishFileMembershipArgSerializer().serialize(self)))"
        }
    }
    open class RelinquishFileMembershipArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelinquishFileMembershipArg) -> JSON {
            let output = [ 
            "file": Serialization._StringSerializer.serialize(value.file),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RelinquishFileMembershipArg {
            switch json {
                case .dictionary(let dict):
                    let file = Serialization._StringSerializer.deserialize(dict["file"] ?? .null)
                    return RelinquishFileMembershipArg(file: file)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RelinquishFileMembershipError union
    public enum RelinquishFileMembershipError: CustomStringConvertible {
        /// An unspecified error.
        case accessError(Sharing.SharingFileAccessError)
        /// The current user has access to the shared file via a group.  You can't relinquish membership to a file
        /// shared via groups.
        case groupAccess
        /// The current user does not have permission to perform this action.
        case noPermission
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelinquishFileMembershipErrorSerializer().serialize(self)))"
        }
    }
    open class RelinquishFileMembershipErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelinquishFileMembershipError) -> JSON {
            switch value {
                case .accessError(let arg):
                    var d = ["access_error": Sharing.SharingFileAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("access_error")
                    return .dictionary(d)
                case .groupAccess:
                    var d = [String: JSON]()
                    d[".tag"] = .str("group_access")
                    return .dictionary(d)
                case .noPermission:
                    var d = [String: JSON]()
                    d[".tag"] = .str("no_permission")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> RelinquishFileMembershipError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharingFileAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                            return RelinquishFileMembershipError.accessError(v)
                        case "group_access":
                            return RelinquishFileMembershipError.groupAccess
                        case "no_permission":
                            return RelinquishFileMembershipError.noPermission
                        case "other":
                            return RelinquishFileMembershipError.other
                        default:
                            return RelinquishFileMembershipError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The RelinquishFolderMembershipArg struct
    open class RelinquishFolderMembershipArg: CustomStringConvertible {
        /// The ID for the shared folder.
        public let sharedFolderId: String
        /// Keep a copy of the folder's contents upon relinquishing membership.
        public let leaveACopy: Bool
        public init(sharedFolderId: String, leaveACopy: Bool = false) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.leaveACopy = leaveACopy
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelinquishFolderMembershipArgSerializer().serialize(self)))"
        }
    }
    open class RelinquishFolderMembershipArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelinquishFolderMembershipArg) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            "leave_a_copy": Serialization._BoolSerializer.serialize(value.leaveACopy),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RelinquishFolderMembershipArg {
            switch json {
                case .dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                    let leaveACopy = Serialization._BoolSerializer.deserialize(dict["leave_a_copy"] ?? .number(0))
                    return RelinquishFolderMembershipArg(sharedFolderId: sharedFolderId, leaveACopy: leaveACopy)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RelinquishFolderMembershipError union
    public enum RelinquishFolderMembershipError: CustomStringConvertible {
        /// An unspecified error.
        case accessError(Sharing.SharedFolderAccessError)
        /// The current user is the owner of the shared folder. Owners cannot relinquish membership to their own
        /// folders. Try unsharing or transferring ownership first.
        case folderOwner
        /// The shared folder is currently mounted.  Unmount the shared folder before relinquishing membership.
        case mounted
        /// The current user has access to the shared folder via a group.  You can't relinquish membership to folders
        /// shared via groups.
        case groupAccess
        /// This action cannot be performed on a team shared folder.
        case teamFolder
        /// The current user does not have permission to perform this action.
        case noPermission
        /// The current user only has inherited access to the shared folder.  You can't relinquish inherited membership
        /// to folders.
        case noExplicitAccess
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelinquishFolderMembershipErrorSerializer().serialize(self)))"
        }
    }
    open class RelinquishFolderMembershipErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelinquishFolderMembershipError) -> JSON {
            switch value {
                case .accessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("access_error")
                    return .dictionary(d)
                case .folderOwner:
                    var d = [String: JSON]()
                    d[".tag"] = .str("folder_owner")
                    return .dictionary(d)
                case .mounted:
                    var d = [String: JSON]()
                    d[".tag"] = .str("mounted")
                    return .dictionary(d)
                case .groupAccess:
                    var d = [String: JSON]()
                    d[".tag"] = .str("group_access")
                    return .dictionary(d)
                case .teamFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("team_folder")
                    return .dictionary(d)
                case .noPermission:
                    var d = [String: JSON]()
                    d[".tag"] = .str("no_permission")
                    return .dictionary(d)
                case .noExplicitAccess:
                    var d = [String: JSON]()
                    d[".tag"] = .str("no_explicit_access")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> RelinquishFolderMembershipError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                            return RelinquishFolderMembershipError.accessError(v)
                        case "folder_owner":
                            return RelinquishFolderMembershipError.folderOwner
                        case "mounted":
                            return RelinquishFolderMembershipError.mounted
                        case "group_access":
                            return RelinquishFolderMembershipError.groupAccess
                        case "team_folder":
                            return RelinquishFolderMembershipError.teamFolder
                        case "no_permission":
                            return RelinquishFolderMembershipError.noPermission
                        case "no_explicit_access":
                            return RelinquishFolderMembershipError.noExplicitAccess
                        case "other":
                            return RelinquishFolderMembershipError.other
                        default:
                            return RelinquishFolderMembershipError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Arguments for removeFileMember2.
    open class RemoveFileMemberArg: CustomStringConvertible {
        /// File from which to remove members.
        public let file: String
        /// Member to remove from this file. Note that even if an email is specified, it may result in the removal of a
        /// user (not an invitee) if the user's main account corresponds to that email address.
        public let member: Sharing.MemberSelector
        public init(file: String, member: Sharing.MemberSelector) {
            stringValidator(minLength: 1, pattern: "((/|id:).*|nspath:[0-9]+:.*)|ns:[0-9]+(/.*)?")(file)
            self.file = file
            self.member = member
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RemoveFileMemberArgSerializer().serialize(self)))"
        }
    }
    open class RemoveFileMemberArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RemoveFileMemberArg) -> JSON {
            let output = [ 
            "file": Serialization._StringSerializer.serialize(value.file),
            "member": Sharing.MemberSelectorSerializer().serialize(value.member),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RemoveFileMemberArg {
            switch json {
                case .dictionary(let dict):
                    let file = Serialization._StringSerializer.deserialize(dict["file"] ?? .null)
                    let member = Sharing.MemberSelectorSerializer().deserialize(dict["member"] ?? .null)
                    return RemoveFileMemberArg(file: file, member: member)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Errors for removeFileMember2.
    public enum RemoveFileMemberError: CustomStringConvertible {
        /// An unspecified error.
        case userError(Sharing.SharingUserError)
        /// An unspecified error.
        case accessError(Sharing.SharingFileAccessError)
        /// This member does not have explicit access to the file and therefore cannot be removed. The return value is
        /// the access that a user might have to the file from a parent folder.
        case noExplicitAccess(Sharing.MemberAccessLevelResult)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RemoveFileMemberErrorSerializer().serialize(self)))"
        }
    }
    open class RemoveFileMemberErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RemoveFileMemberError) -> JSON {
            switch value {
                case .userError(let arg):
                    var d = ["user_error": Sharing.SharingUserErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("user_error")
                    return .dictionary(d)
                case .accessError(let arg):
                    var d = ["access_error": Sharing.SharingFileAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("access_error")
                    return .dictionary(d)
                case .noExplicitAccess(let arg):
                    var d = Serialization.getFields(Sharing.MemberAccessLevelResultSerializer().serialize(arg))
                    d[".tag"] = .str("no_explicit_access")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> RemoveFileMemberError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "user_error":
                            let v = Sharing.SharingUserErrorSerializer().deserialize(d["user_error"] ?? .null)
                            return RemoveFileMemberError.userError(v)
                        case "access_error":
                            let v = Sharing.SharingFileAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                            return RemoveFileMemberError.accessError(v)
                        case "no_explicit_access":
                            let v = Sharing.MemberAccessLevelResultSerializer().deserialize(json)
                            return RemoveFileMemberError.noExplicitAccess(v)
                        case "other":
                            return RemoveFileMemberError.other
                        default:
                            return RemoveFileMemberError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The RemoveFolderMemberArg struct
    open class RemoveFolderMemberArg: CustomStringConvertible {
        /// The ID for the shared folder.
        public let sharedFolderId: String
        /// The member to remove from the folder.
        public let member: Sharing.MemberSelector
        /// If true, the removed user will keep their copy of the folder after it's unshared, assuming it was mounted.
        /// Otherwise, it will be removed from their Dropbox. Also, this must be set to false when kicking a group.
        public let leaveACopy: Bool
        public init(sharedFolderId: String, member: Sharing.MemberSelector, leaveACopy: Bool) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.member = member
            self.leaveACopy = leaveACopy
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RemoveFolderMemberArgSerializer().serialize(self)))"
        }
    }
    open class RemoveFolderMemberArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RemoveFolderMemberArg) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            "member": Sharing.MemberSelectorSerializer().serialize(value.member),
            "leave_a_copy": Serialization._BoolSerializer.serialize(value.leaveACopy),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RemoveFolderMemberArg {
            switch json {
                case .dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                    let member = Sharing.MemberSelectorSerializer().deserialize(dict["member"] ?? .null)
                    let leaveACopy = Serialization._BoolSerializer.deserialize(dict["leave_a_copy"] ?? .null)
                    return RemoveFolderMemberArg(sharedFolderId: sharedFolderId, member: member, leaveACopy: leaveACopy)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RemoveFolderMemberError union
    public enum RemoveFolderMemberError: CustomStringConvertible {
        /// An unspecified error.
        case accessError(Sharing.SharedFolderAccessError)
        /// An unspecified error.
        case memberError(Sharing.SharedFolderMemberError)
        /// The target user is the owner of the shared folder. You can't remove this user until ownership has been
        /// transferred to another member.
        case folderOwner
        /// The target user has access to the shared folder via a group.
        case groupAccess
        /// This action cannot be performed on a team shared folder.
        case teamFolder
        /// The current user does not have permission to perform this action.
        case noPermission
        /// This shared folder has too many files for leaving a copy. You can still remove this user without leaving a
        /// copy.
        case tooManyFiles
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RemoveFolderMemberErrorSerializer().serialize(self)))"
        }
    }
    open class RemoveFolderMemberErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RemoveFolderMemberError) -> JSON {
            switch value {
                case .accessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("access_error")
                    return .dictionary(d)
                case .memberError(let arg):
                    var d = ["member_error": Sharing.SharedFolderMemberErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("member_error")
                    return .dictionary(d)
                case .folderOwner:
                    var d = [String: JSON]()
                    d[".tag"] = .str("folder_owner")
                    return .dictionary(d)
                case .groupAccess:
                    var d = [String: JSON]()
                    d[".tag"] = .str("group_access")
                    return .dictionary(d)
                case .teamFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("team_folder")
                    return .dictionary(d)
                case .noPermission:
                    var d = [String: JSON]()
                    d[".tag"] = .str("no_permission")
                    return .dictionary(d)
                case .tooManyFiles:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_files")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> RemoveFolderMemberError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                            return RemoveFolderMemberError.accessError(v)
                        case "member_error":
                            let v = Sharing.SharedFolderMemberErrorSerializer().deserialize(d["member_error"] ?? .null)
                            return RemoveFolderMemberError.memberError(v)
                        case "folder_owner":
                            return RemoveFolderMemberError.folderOwner
                        case "group_access":
                            return RemoveFolderMemberError.groupAccess
                        case "team_folder":
                            return RemoveFolderMemberError.teamFolder
                        case "no_permission":
                            return RemoveFolderMemberError.noPermission
                        case "too_many_files":
                            return RemoveFolderMemberError.tooManyFiles
                        case "other":
                            return RemoveFolderMemberError.other
                        default:
                            return RemoveFolderMemberError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The RemoveMemberJobStatus union
    public enum RemoveMemberJobStatus: CustomStringConvertible {
        /// The asynchronous job is still in progress.
        case inProgress
        /// Removing the folder member has finished. The value is information about whether the member has another form
        /// of access.
        case complete(Sharing.MemberAccessLevelResult)
        /// An unspecified error.
        case failed(Sharing.RemoveFolderMemberError)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RemoveMemberJobStatusSerializer().serialize(self)))"
        }
    }
    open class RemoveMemberJobStatusSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RemoveMemberJobStatus) -> JSON {
            switch value {
                case .inProgress:
                    var d = [String: JSON]()
                    d[".tag"] = .str("in_progress")
                    return .dictionary(d)
                case .complete(let arg):
                    var d = Serialization.getFields(Sharing.MemberAccessLevelResultSerializer().serialize(arg))
                    d[".tag"] = .str("complete")
                    return .dictionary(d)
                case .failed(let arg):
                    var d = ["failed": Sharing.RemoveFolderMemberErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("failed")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> RemoveMemberJobStatus {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "in_progress":
                            return RemoveMemberJobStatus.inProgress
                        case "complete":
                            let v = Sharing.MemberAccessLevelResultSerializer().deserialize(json)
                            return RemoveMemberJobStatus.complete(v)
                        case "failed":
                            let v = Sharing.RemoveFolderMemberErrorSerializer().deserialize(d["failed"] ?? .null)
                            return RemoveMemberJobStatus.failed(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The access permission that can be requested by the caller for the shared link. Note that the final resolved
    /// visibility of the shared link takes into account other aspects, such as team and shared folder settings. Check
    /// the ResolvedVisibility for more info on the possible resolved visibility values of shared links.
    public enum RequestedVisibility: CustomStringConvertible {
        /// Anyone who has received the link can access it. No login required.
        case public_
        /// Only members of the same team can access the link. Login is required.
        case teamOnly
        /// A link-specific password is required to access the link. Login is not required.
        case password

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RequestedVisibilitySerializer().serialize(self)))"
        }
    }
    open class RequestedVisibilitySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RequestedVisibility) -> JSON {
            switch value {
                case .public_:
                    var d = [String: JSON]()
                    d[".tag"] = .str("public")
                    return .dictionary(d)
                case .teamOnly:
                    var d = [String: JSON]()
                    d[".tag"] = .str("team_only")
                    return .dictionary(d)
                case .password:
                    var d = [String: JSON]()
                    d[".tag"] = .str("password")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> RequestedVisibility {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "public":
                            return RequestedVisibility.public_
                        case "team_only":
                            return RequestedVisibility.teamOnly
                        case "password":
                            return RequestedVisibility.password
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The actual access permissions values of shared links after taking into account user preferences and the team and
    /// shared folder settings. Check the RequestedVisibility for more info on the possible visibility values that can
    /// be set by the shared link's owner.
    public enum ResolvedVisibility: CustomStringConvertible {
        /// Anyone who has received the link can access it. No login required.
        case public_
        /// Only members of the same team can access the link. Login is required.
        case teamOnly
        /// A link-specific password is required to access the link. Login is not required.
        case password
        /// Only members of the same team who have the link-specific password can access the link. Login is required.
        case teamAndPassword
        /// Only members of the shared folder containing the linked file can access the link. Login is required.
        case sharedFolderOnly
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ResolvedVisibilitySerializer().serialize(self)))"
        }
    }
    open class ResolvedVisibilitySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ResolvedVisibility) -> JSON {
            switch value {
                case .public_:
                    var d = [String: JSON]()
                    d[".tag"] = .str("public")
                    return .dictionary(d)
                case .teamOnly:
                    var d = [String: JSON]()
                    d[".tag"] = .str("team_only")
                    return .dictionary(d)
                case .password:
                    var d = [String: JSON]()
                    d[".tag"] = .str("password")
                    return .dictionary(d)
                case .teamAndPassword:
                    var d = [String: JSON]()
                    d[".tag"] = .str("team_and_password")
                    return .dictionary(d)
                case .sharedFolderOnly:
                    var d = [String: JSON]()
                    d[".tag"] = .str("shared_folder_only")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ResolvedVisibility {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "public":
                            return ResolvedVisibility.public_
                        case "team_only":
                            return ResolvedVisibility.teamOnly
                        case "password":
                            return ResolvedVisibility.password
                        case "team_and_password":
                            return ResolvedVisibility.teamAndPassword
                        case "shared_folder_only":
                            return ResolvedVisibility.sharedFolderOnly
                        case "other":
                            return ResolvedVisibility.other
                        default:
                            return ResolvedVisibility.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The RevokeSharedLinkArg struct
    open class RevokeSharedLinkArg: CustomStringConvertible {
        /// URL of the shared link.
        public let url: String
        public init(url: String) {
            stringValidator()(url)
            self.url = url
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RevokeSharedLinkArgSerializer().serialize(self)))"
        }
    }
    open class RevokeSharedLinkArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RevokeSharedLinkArg) -> JSON {
            let output = [ 
            "url": Serialization._StringSerializer.serialize(value.url),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RevokeSharedLinkArg {
            switch json {
                case .dictionary(let dict):
                    let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .null)
                    return RevokeSharedLinkArg(url: url)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RevokeSharedLinkError union
    public enum RevokeSharedLinkError: CustomStringConvertible {
        /// The shared link wasn't found.
        case sharedLinkNotFound
        /// The caller is not allowed to access this shared link.
        case sharedLinkAccessDenied
        /// This type of link is not supported.
        case unsupportedLinkType
        /// An unspecified error.
        case other
        /// Shared link is malformed.
        case sharedLinkMalformed

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RevokeSharedLinkErrorSerializer().serialize(self)))"
        }
    }
    open class RevokeSharedLinkErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RevokeSharedLinkError) -> JSON {
            switch value {
                case .sharedLinkNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("shared_link_not_found")
                    return .dictionary(d)
                case .sharedLinkAccessDenied:
                    var d = [String: JSON]()
                    d[".tag"] = .str("shared_link_access_denied")
                    return .dictionary(d)
                case .unsupportedLinkType:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unsupported_link_type")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .sharedLinkMalformed:
                    var d = [String: JSON]()
                    d[".tag"] = .str("shared_link_malformed")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> RevokeSharedLinkError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "shared_link_not_found":
                            return RevokeSharedLinkError.sharedLinkNotFound
                        case "shared_link_access_denied":
                            return RevokeSharedLinkError.sharedLinkAccessDenied
                        case "unsupported_link_type":
                            return RevokeSharedLinkError.unsupportedLinkType
                        case "other":
                            return RevokeSharedLinkError.other
                        case "shared_link_malformed":
                            return RevokeSharedLinkError.sharedLinkMalformed
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The SetAccessInheritanceArg struct
    open class SetAccessInheritanceArg: CustomStringConvertible {
        /// The access inheritance settings for the folder.
        public let accessInheritance: Sharing.AccessInheritance
        /// The ID for the shared folder.
        public let sharedFolderId: String
        public init(sharedFolderId: String, accessInheritance: Sharing.AccessInheritance = .inherit) {
            self.accessInheritance = accessInheritance
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SetAccessInheritanceArgSerializer().serialize(self)))"
        }
    }
    open class SetAccessInheritanceArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SetAccessInheritanceArg) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            "access_inheritance": Sharing.AccessInheritanceSerializer().serialize(value.accessInheritance),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SetAccessInheritanceArg {
            switch json {
                case .dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                    let accessInheritance = Sharing.AccessInheritanceSerializer().deserialize(dict["access_inheritance"] ?? Sharing.AccessInheritanceSerializer().serialize(.inherit))
                    return SetAccessInheritanceArg(sharedFolderId: sharedFolderId, accessInheritance: accessInheritance)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SetAccessInheritanceError union
    public enum SetAccessInheritanceError: CustomStringConvertible {
        /// Unable to access shared folder.
        case accessError(Sharing.SharedFolderAccessError)
        /// The current user does not have permission to perform this action.
        case noPermission
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SetAccessInheritanceErrorSerializer().serialize(self)))"
        }
    }
    open class SetAccessInheritanceErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SetAccessInheritanceError) -> JSON {
            switch value {
                case .accessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("access_error")
                    return .dictionary(d)
                case .noPermission:
                    var d = [String: JSON]()
                    d[".tag"] = .str("no_permission")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SetAccessInheritanceError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                            return SetAccessInheritanceError.accessError(v)
                        case "no_permission":
                            return SetAccessInheritanceError.noPermission
                        case "other":
                            return SetAccessInheritanceError.other
                        default:
                            return SetAccessInheritanceError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ShareFolderArgBase struct
    open class ShareFolderArgBase: CustomStringConvertible {
        /// Who can add and remove members of this shared folder.
        public let aclUpdatePolicy: Sharing.AclUpdatePolicy?
        /// Whether to force the share to happen asynchronously.
        public let forceAsync: Bool
        /// Who can be a member of this shared folder. Only applicable if the current user is on a team.
        public let memberPolicy: Sharing.MemberPolicy?
        /// The path to the folder to share. If it does not exist, then a new one is created.
        public let path: String
        /// The policy to apply to shared links created for content inside this shared folder.  The current user must be
        /// on a team to set this policy to members in SharedLinkPolicy.
        public let sharedLinkPolicy: Sharing.SharedLinkPolicy?
        /// Who can enable/disable viewer info for this shared folder.
        public let viewerInfoPolicy: Sharing.ViewerInfoPolicy?
        /// The access inheritance settings for the folder.
        public let accessInheritance: Sharing.AccessInheritance
        public init(path: String, aclUpdatePolicy: Sharing.AclUpdatePolicy? = nil, forceAsync: Bool = false, memberPolicy: Sharing.MemberPolicy? = nil, sharedLinkPolicy: Sharing.SharedLinkPolicy? = nil, viewerInfoPolicy: Sharing.ViewerInfoPolicy? = nil, accessInheritance: Sharing.AccessInheritance = .inherit) {
            self.aclUpdatePolicy = aclUpdatePolicy
            self.forceAsync = forceAsync
            self.memberPolicy = memberPolicy
            stringValidator(pattern: "(/(.|[\\r\\n])*)|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            self.sharedLinkPolicy = sharedLinkPolicy
            self.viewerInfoPolicy = viewerInfoPolicy
            self.accessInheritance = accessInheritance
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShareFolderArgBaseSerializer().serialize(self)))"
        }
    }
    open class ShareFolderArgBaseSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShareFolderArgBase) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "acl_update_policy": NullableSerializer(Sharing.AclUpdatePolicySerializer()).serialize(value.aclUpdatePolicy),
            "force_async": Serialization._BoolSerializer.serialize(value.forceAsync),
            "member_policy": NullableSerializer(Sharing.MemberPolicySerializer()).serialize(value.memberPolicy),
            "shared_link_policy": NullableSerializer(Sharing.SharedLinkPolicySerializer()).serialize(value.sharedLinkPolicy),
            "viewer_info_policy": NullableSerializer(Sharing.ViewerInfoPolicySerializer()).serialize(value.viewerInfoPolicy),
            "access_inheritance": Sharing.AccessInheritanceSerializer().serialize(value.accessInheritance),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShareFolderArgBase {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let aclUpdatePolicy = NullableSerializer(Sharing.AclUpdatePolicySerializer()).deserialize(dict["acl_update_policy"] ?? .null)
                    let forceAsync = Serialization._BoolSerializer.deserialize(dict["force_async"] ?? .number(0))
                    let memberPolicy = NullableSerializer(Sharing.MemberPolicySerializer()).deserialize(dict["member_policy"] ?? .null)
                    let sharedLinkPolicy = NullableSerializer(Sharing.SharedLinkPolicySerializer()).deserialize(dict["shared_link_policy"] ?? .null)
                    let viewerInfoPolicy = NullableSerializer(Sharing.ViewerInfoPolicySerializer()).deserialize(dict["viewer_info_policy"] ?? .null)
                    let accessInheritance = Sharing.AccessInheritanceSerializer().deserialize(dict["access_inheritance"] ?? Sharing.AccessInheritanceSerializer().serialize(.inherit))
                    return ShareFolderArgBase(path: path, aclUpdatePolicy: aclUpdatePolicy, forceAsync: forceAsync, memberPolicy: memberPolicy, sharedLinkPolicy: sharedLinkPolicy, viewerInfoPolicy: viewerInfoPolicy, accessInheritance: accessInheritance)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ShareFolderArg struct
    open class ShareFolderArg: Sharing.ShareFolderArgBase {
        /// A list of `FolderAction`s corresponding to `FolderPermission`s that should appear in the  response's
        /// permissions in SharedFolderMetadata field describing the actions the  authenticated user can perform on the
        /// folder.
        public let actions: Array<Sharing.FolderAction>?
        /// Settings on the link for this folder.
        public let linkSettings: Sharing.LinkSettings?
        public init(path: String, aclUpdatePolicy: Sharing.AclUpdatePolicy? = nil, forceAsync: Bool = false, memberPolicy: Sharing.MemberPolicy? = nil, sharedLinkPolicy: Sharing.SharedLinkPolicy? = nil, viewerInfoPolicy: Sharing.ViewerInfoPolicy? = nil, accessInheritance: Sharing.AccessInheritance = .inherit, actions: Array<Sharing.FolderAction>? = nil, linkSettings: Sharing.LinkSettings? = nil) {
            self.actions = actions
            self.linkSettings = linkSettings
            super.init(path: path, aclUpdatePolicy: aclUpdatePolicy, forceAsync: forceAsync, memberPolicy: memberPolicy, sharedLinkPolicy: sharedLinkPolicy, viewerInfoPolicy: viewerInfoPolicy, accessInheritance: accessInheritance)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShareFolderArgSerializer().serialize(self)))"
        }
    }
    open class ShareFolderArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShareFolderArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "acl_update_policy": NullableSerializer(Sharing.AclUpdatePolicySerializer()).serialize(value.aclUpdatePolicy),
            "force_async": Serialization._BoolSerializer.serialize(value.forceAsync),
            "member_policy": NullableSerializer(Sharing.MemberPolicySerializer()).serialize(value.memberPolicy),
            "shared_link_policy": NullableSerializer(Sharing.SharedLinkPolicySerializer()).serialize(value.sharedLinkPolicy),
            "viewer_info_policy": NullableSerializer(Sharing.ViewerInfoPolicySerializer()).serialize(value.viewerInfoPolicy),
            "access_inheritance": Sharing.AccessInheritanceSerializer().serialize(value.accessInheritance),
            "actions": NullableSerializer(ArraySerializer(Sharing.FolderActionSerializer())).serialize(value.actions),
            "link_settings": NullableSerializer(Sharing.LinkSettingsSerializer()).serialize(value.linkSettings),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShareFolderArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let aclUpdatePolicy = NullableSerializer(Sharing.AclUpdatePolicySerializer()).deserialize(dict["acl_update_policy"] ?? .null)
                    let forceAsync = Serialization._BoolSerializer.deserialize(dict["force_async"] ?? .number(0))
                    let memberPolicy = NullableSerializer(Sharing.MemberPolicySerializer()).deserialize(dict["member_policy"] ?? .null)
                    let sharedLinkPolicy = NullableSerializer(Sharing.SharedLinkPolicySerializer()).deserialize(dict["shared_link_policy"] ?? .null)
                    let viewerInfoPolicy = NullableSerializer(Sharing.ViewerInfoPolicySerializer()).deserialize(dict["viewer_info_policy"] ?? .null)
                    let accessInheritance = Sharing.AccessInheritanceSerializer().deserialize(dict["access_inheritance"] ?? Sharing.AccessInheritanceSerializer().serialize(.inherit))
                    let actions = NullableSerializer(ArraySerializer(Sharing.FolderActionSerializer())).deserialize(dict["actions"] ?? .null)
                    let linkSettings = NullableSerializer(Sharing.LinkSettingsSerializer()).deserialize(dict["link_settings"] ?? .null)
                    return ShareFolderArg(path: path, aclUpdatePolicy: aclUpdatePolicy, forceAsync: forceAsync, memberPolicy: memberPolicy, sharedLinkPolicy: sharedLinkPolicy, viewerInfoPolicy: viewerInfoPolicy, accessInheritance: accessInheritance, actions: actions, linkSettings: linkSettings)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ShareFolderErrorBase union
    public enum ShareFolderErrorBase: CustomStringConvertible {
        /// The current user's e-mail address is unverified.
        case emailUnverified
        /// path in ShareFolderArg is invalid.
        case badPath(Sharing.SharePathError)
        /// Team policy is more restrictive than memberPolicy in ShareFolderArg.
        case teamPolicyDisallowsMemberPolicy
        /// The current user's account is not allowed to select the specified sharedLinkPolicy in ShareFolderArg.
        case disallowedSharedLinkPolicy
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShareFolderErrorBaseSerializer().serialize(self)))"
        }
    }
    open class ShareFolderErrorBaseSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShareFolderErrorBase) -> JSON {
            switch value {
                case .emailUnverified:
                    var d = [String: JSON]()
                    d[".tag"] = .str("email_unverified")
                    return .dictionary(d)
                case .badPath(let arg):
                    var d = ["bad_path": Sharing.SharePathErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("bad_path")
                    return .dictionary(d)
                case .teamPolicyDisallowsMemberPolicy:
                    var d = [String: JSON]()
                    d[".tag"] = .str("team_policy_disallows_member_policy")
                    return .dictionary(d)
                case .disallowedSharedLinkPolicy:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disallowed_shared_link_policy")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ShareFolderErrorBase {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "email_unverified":
                            return ShareFolderErrorBase.emailUnverified
                        case "bad_path":
                            let v = Sharing.SharePathErrorSerializer().deserialize(d["bad_path"] ?? .null)
                            return ShareFolderErrorBase.badPath(v)
                        case "team_policy_disallows_member_policy":
                            return ShareFolderErrorBase.teamPolicyDisallowsMemberPolicy
                        case "disallowed_shared_link_policy":
                            return ShareFolderErrorBase.disallowedSharedLinkPolicy
                        case "other":
                            return ShareFolderErrorBase.other
                        default:
                            return ShareFolderErrorBase.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ShareFolderError union
    public enum ShareFolderError: CustomStringConvertible {
        /// The current user's e-mail address is unverified.
        case emailUnverified
        /// path in ShareFolderArg is invalid.
        case badPath(Sharing.SharePathError)
        /// Team policy is more restrictive than memberPolicy in ShareFolderArg.
        case teamPolicyDisallowsMemberPolicy
        /// The current user's account is not allowed to select the specified sharedLinkPolicy in ShareFolderArg.
        case disallowedSharedLinkPolicy
        /// An unspecified error.
        case other
        /// The current user does not have permission to perform this action.
        case noPermission

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShareFolderErrorSerializer().serialize(self)))"
        }
    }
    open class ShareFolderErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShareFolderError) -> JSON {
            switch value {
                case .emailUnverified:
                    var d = [String: JSON]()
                    d[".tag"] = .str("email_unverified")
                    return .dictionary(d)
                case .badPath(let arg):
                    var d = ["bad_path": Sharing.SharePathErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("bad_path")
                    return .dictionary(d)
                case .teamPolicyDisallowsMemberPolicy:
                    var d = [String: JSON]()
                    d[".tag"] = .str("team_policy_disallows_member_policy")
                    return .dictionary(d)
                case .disallowedSharedLinkPolicy:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disallowed_shared_link_policy")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .noPermission:
                    var d = [String: JSON]()
                    d[".tag"] = .str("no_permission")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ShareFolderError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "email_unverified":
                            return ShareFolderError.emailUnverified
                        case "bad_path":
                            let v = Sharing.SharePathErrorSerializer().deserialize(d["bad_path"] ?? .null)
                            return ShareFolderError.badPath(v)
                        case "team_policy_disallows_member_policy":
                            return ShareFolderError.teamPolicyDisallowsMemberPolicy
                        case "disallowed_shared_link_policy":
                            return ShareFolderError.disallowedSharedLinkPolicy
                        case "other":
                            return ShareFolderError.other
                        case "no_permission":
                            return ShareFolderError.noPermission
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ShareFolderJobStatus union
    public enum ShareFolderJobStatus: CustomStringConvertible {
        /// The asynchronous job is still in progress.
        case inProgress
        /// The share job has finished. The value is the metadata for the folder.
        case complete(Sharing.SharedFolderMetadata)
        /// An unspecified error.
        case failed(Sharing.ShareFolderError)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShareFolderJobStatusSerializer().serialize(self)))"
        }
    }
    open class ShareFolderJobStatusSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShareFolderJobStatus) -> JSON {
            switch value {
                case .inProgress:
                    var d = [String: JSON]()
                    d[".tag"] = .str("in_progress")
                    return .dictionary(d)
                case .complete(let arg):
                    var d = Serialization.getFields(Sharing.SharedFolderMetadataSerializer().serialize(arg))
                    d[".tag"] = .str("complete")
                    return .dictionary(d)
                case .failed(let arg):
                    var d = ["failed": Sharing.ShareFolderErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("failed")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ShareFolderJobStatus {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "in_progress":
                            return ShareFolderJobStatus.inProgress
                        case "complete":
                            let v = Sharing.SharedFolderMetadataSerializer().deserialize(json)
                            return ShareFolderJobStatus.complete(v)
                        case "failed":
                            let v = Sharing.ShareFolderErrorSerializer().deserialize(d["failed"] ?? .null)
                            return ShareFolderJobStatus.failed(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ShareFolderLaunch union
    public enum ShareFolderLaunch: CustomStringConvertible {
        /// This response indicates that the processing is asynchronous. The string is an id that can be used to obtain
        /// the status of the asynchronous job.
        case asyncJobId(String)
        /// An unspecified error.
        case complete(Sharing.SharedFolderMetadata)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShareFolderLaunchSerializer().serialize(self)))"
        }
    }
    open class ShareFolderLaunchSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShareFolderLaunch) -> JSON {
            switch value {
                case .asyncJobId(let arg):
                    var d = ["async_job_id": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("async_job_id")
                    return .dictionary(d)
                case .complete(let arg):
                    var d = Serialization.getFields(Sharing.SharedFolderMetadataSerializer().serialize(arg))
                    d[".tag"] = .str("complete")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ShareFolderLaunch {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "async_job_id":
                            let v = Serialization._StringSerializer.deserialize(d["async_job_id"] ?? .null)
                            return ShareFolderLaunch.asyncJobId(v)
                        case "complete":
                            let v = Sharing.SharedFolderMetadataSerializer().deserialize(json)
                            return ShareFolderLaunch.complete(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The SharePathError union
    public enum SharePathError: CustomStringConvertible {
        /// A file is at the specified path.
        case isFile
        /// We do not support sharing a folder inside a shared folder.
        case insideSharedFolder
        /// We do not support shared folders that contain shared folders.
        case containsSharedFolder
        /// We do not support shared folders that contain app folders.
        case containsAppFolder
        /// We do not support shared folders that contain team folders.
        case containsTeamFolder
        /// We do not support sharing an app folder.
        case isAppFolder
        /// We do not support sharing a folder inside an app folder.
        case insideAppFolder
        /// A public folder can't be shared this way. Use a public link instead.
        case isPublicFolder
        /// A folder inside a public folder can't be shared this way. Use a public link instead.
        case insidePublicFolder
        /// Folder is already shared. Contains metadata about the existing shared folder.
        case alreadyShared(Sharing.SharedFolderMetadata)
        /// Path is not valid.
        case invalidPath
        /// We do not support sharing a Mac OS X package.
        case isOsxPackage
        /// We do not support sharing a folder inside a Mac OS X package.
        case insideOsxPackage
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharePathErrorSerializer().serialize(self)))"
        }
    }
    open class SharePathErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharePathError) -> JSON {
            switch value {
                case .isFile:
                    var d = [String: JSON]()
                    d[".tag"] = .str("is_file")
                    return .dictionary(d)
                case .insideSharedFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("inside_shared_folder")
                    return .dictionary(d)
                case .containsSharedFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("contains_shared_folder")
                    return .dictionary(d)
                case .containsAppFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("contains_app_folder")
                    return .dictionary(d)
                case .containsTeamFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("contains_team_folder")
                    return .dictionary(d)
                case .isAppFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("is_app_folder")
                    return .dictionary(d)
                case .insideAppFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("inside_app_folder")
                    return .dictionary(d)
                case .isPublicFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("is_public_folder")
                    return .dictionary(d)
                case .insidePublicFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("inside_public_folder")
                    return .dictionary(d)
                case .alreadyShared(let arg):
                    var d = Serialization.getFields(Sharing.SharedFolderMetadataSerializer().serialize(arg))
                    d[".tag"] = .str("already_shared")
                    return .dictionary(d)
                case .invalidPath:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_path")
                    return .dictionary(d)
                case .isOsxPackage:
                    var d = [String: JSON]()
                    d[".tag"] = .str("is_osx_package")
                    return .dictionary(d)
                case .insideOsxPackage:
                    var d = [String: JSON]()
                    d[".tag"] = .str("inside_osx_package")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SharePathError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "is_file":
                            return SharePathError.isFile
                        case "inside_shared_folder":
                            return SharePathError.insideSharedFolder
                        case "contains_shared_folder":
                            return SharePathError.containsSharedFolder
                        case "contains_app_folder":
                            return SharePathError.containsAppFolder
                        case "contains_team_folder":
                            return SharePathError.containsTeamFolder
                        case "is_app_folder":
                            return SharePathError.isAppFolder
                        case "inside_app_folder":
                            return SharePathError.insideAppFolder
                        case "is_public_folder":
                            return SharePathError.isPublicFolder
                        case "inside_public_folder":
                            return SharePathError.insidePublicFolder
                        case "already_shared":
                            let v = Sharing.SharedFolderMetadataSerializer().deserialize(json)
                            return SharePathError.alreadyShared(v)
                        case "invalid_path":
                            return SharePathError.invalidPath
                        case "is_osx_package":
                            return SharePathError.isOsxPackage
                        case "inside_osx_package":
                            return SharePathError.insideOsxPackage
                        case "other":
                            return SharePathError.other
                        default:
                            return SharePathError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Metadata of a shared link for a file or folder.
    open class SharedContentLinkMetadata: Sharing.SharedContentLinkMetadataBase {
        /// The content inside this folder with link audience different than this folder's. This is only returned when
        /// an endpoint that returns metadata for a single shared folder is called, e.g. /get_folder_metadata.
        public let audienceExceptions: Sharing.AudienceExceptions?
        /// The URL of the link.
        public let url: String
        public init(audienceOptions: Array<Sharing.LinkAudience>, currentAudience: Sharing.LinkAudience, linkPermissions: Array<Sharing.LinkPermission>, passwordProtected: Bool, url: String, accessLevel: Sharing.AccessLevel? = nil, audienceRestrictingSharedFolder: Sharing.AudienceRestrictingSharedFolder? = nil, expiry: Date? = nil, audienceExceptions: Sharing.AudienceExceptions? = nil) {
            self.audienceExceptions = audienceExceptions
            stringValidator()(url)
            self.url = url
            super.init(audienceOptions: audienceOptions, currentAudience: currentAudience, linkPermissions: linkPermissions, passwordProtected: passwordProtected, accessLevel: accessLevel, audienceRestrictingSharedFolder: audienceRestrictingSharedFolder, expiry: expiry)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedContentLinkMetadataSerializer().serialize(self)))"
        }
    }
    open class SharedContentLinkMetadataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedContentLinkMetadata) -> JSON {
            let output = [ 
            "audience_options": ArraySerializer(Sharing.LinkAudienceSerializer()).serialize(value.audienceOptions),
            "current_audience": Sharing.LinkAudienceSerializer().serialize(value.currentAudience),
            "link_permissions": ArraySerializer(Sharing.LinkPermissionSerializer()).serialize(value.linkPermissions),
            "password_protected": Serialization._BoolSerializer.serialize(value.passwordProtected),
            "url": Serialization._StringSerializer.serialize(value.url),
            "access_level": NullableSerializer(Sharing.AccessLevelSerializer()).serialize(value.accessLevel),
            "audience_restricting_shared_folder": NullableSerializer(Sharing.AudienceRestrictingSharedFolderSerializer()).serialize(value.audienceRestrictingSharedFolder),
            "expiry": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.expiry),
            "audience_exceptions": NullableSerializer(Sharing.AudienceExceptionsSerializer()).serialize(value.audienceExceptions),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedContentLinkMetadata {
            switch json {
                case .dictionary(let dict):
                    let audienceOptions = ArraySerializer(Sharing.LinkAudienceSerializer()).deserialize(dict["audience_options"] ?? .null)
                    let currentAudience = Sharing.LinkAudienceSerializer().deserialize(dict["current_audience"] ?? .null)
                    let linkPermissions = ArraySerializer(Sharing.LinkPermissionSerializer()).deserialize(dict["link_permissions"] ?? .null)
                    let passwordProtected = Serialization._BoolSerializer.deserialize(dict["password_protected"] ?? .null)
                    let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .null)
                    let accessLevel = NullableSerializer(Sharing.AccessLevelSerializer()).deserialize(dict["access_level"] ?? .null)
                    let audienceRestrictingSharedFolder = NullableSerializer(Sharing.AudienceRestrictingSharedFolderSerializer()).deserialize(dict["audience_restricting_shared_folder"] ?? .null)
                    let expiry = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["expiry"] ?? .null)
                    let audienceExceptions = NullableSerializer(Sharing.AudienceExceptionsSerializer()).deserialize(dict["audience_exceptions"] ?? .null)
                    return SharedContentLinkMetadata(audienceOptions: audienceOptions, currentAudience: currentAudience, linkPermissions: linkPermissions, passwordProtected: passwordProtected, url: url, accessLevel: accessLevel, audienceRestrictingSharedFolder: audienceRestrictingSharedFolder, expiry: expiry, audienceExceptions: audienceExceptions)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Shared file user, group, and invitee membership. Used for the results of listFileMembers and
    /// listFileMembersContinue, and used as part of the results for listFileMembersBatch.
    open class SharedFileMembers: CustomStringConvertible {
        /// The list of user members of the shared file.
        public let users: Array<Sharing.UserFileMembershipInfo>
        /// The list of group members of the shared file.
        public let groups: Array<Sharing.GroupMembershipInfo>
        /// The list of invited members of a file, but have not logged in and claimed this.
        public let invitees: Array<Sharing.InviteeMembershipInfo>
        /// Present if there are additional shared file members that have not been returned yet. Pass the cursor into
        /// listFileMembersContinue to list additional members.
        public let cursor: String?
        public init(users: Array<Sharing.UserFileMembershipInfo>, groups: Array<Sharing.GroupMembershipInfo>, invitees: Array<Sharing.InviteeMembershipInfo>, cursor: String? = nil) {
            self.users = users
            self.groups = groups
            self.invitees = invitees
            nullableValidator(stringValidator())(cursor)
            self.cursor = cursor
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedFileMembersSerializer().serialize(self)))"
        }
    }
    open class SharedFileMembersSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedFileMembers) -> JSON {
            let output = [ 
            "users": ArraySerializer(Sharing.UserFileMembershipInfoSerializer()).serialize(value.users),
            "groups": ArraySerializer(Sharing.GroupMembershipInfoSerializer()).serialize(value.groups),
            "invitees": ArraySerializer(Sharing.InviteeMembershipInfoSerializer()).serialize(value.invitees),
            "cursor": NullableSerializer(Serialization._StringSerializer).serialize(value.cursor),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedFileMembers {
            switch json {
                case .dictionary(let dict):
                    let users = ArraySerializer(Sharing.UserFileMembershipInfoSerializer()).deserialize(dict["users"] ?? .null)
                    let groups = ArraySerializer(Sharing.GroupMembershipInfoSerializer()).deserialize(dict["groups"] ?? .null)
                    let invitees = ArraySerializer(Sharing.InviteeMembershipInfoSerializer()).deserialize(dict["invitees"] ?? .null)
                    let cursor = NullableSerializer(Serialization._StringSerializer).deserialize(dict["cursor"] ?? .null)
                    return SharedFileMembers(users: users, groups: groups, invitees: invitees, cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Properties of the shared file.
    open class SharedFileMetadata: CustomStringConvertible {
        /// The current user's access level for this shared file.
        public let accessType: Sharing.AccessLevel?
        /// The ID of the file.
        public let id: String
        /// The expected metadata of the link associated for the file when it is first shared. Absent if the link
        /// already exists. This is for an unreleased feature so it may not be returned yet.
        public let expectedLinkMetadata: Sharing.ExpectedSharedContentLinkMetadata?
        /// The metadata of the link associated for the file. This is for an unreleased feature so it may not be
        /// returned yet.
        public let linkMetadata: Sharing.SharedContentLinkMetadata?
        /// The name of this file.
        public let name: String
        /// The display names of the users that own the file. If the file is part of a team folder, the display names of
        /// the team admins are also included. Absent if the owner display names cannot be fetched.
        public let ownerDisplayNames: Array<String>?
        /// The team that owns the file. This field is not present if the file is not owned by a team.
        public let ownerTeam: Users.Team?
        /// The ID of the parent shared folder. This field is present only if the file is contained within a shared
        /// folder.
        public let parentSharedFolderId: String?
        /// The cased path to be used for display purposes only. In rare instances the casing will not correctly match
        /// the user's filesystem, but this behavior will match the path provided in the Core API v1. Absent for
        /// unmounted files.
        public let pathDisplay: String?
        /// The lower-case full path of this file. Absent for unmounted files.
        public let pathLower: String?
        /// The sharing permissions that requesting user has on this file. This corresponds to the entries given in
        /// actions in GetFileMetadataBatchArg or actions in GetFileMetadataArg.
        public let permissions: Array<Sharing.FilePermission>?
        /// Policies governing this shared file.
        public let policy: Sharing.FolderPolicy
        /// URL for displaying a web preview of the shared file.
        public let previewUrl: String
        /// Timestamp indicating when the current user was invited to this shared file. If the user was not invited to
        /// the shared file, the timestamp will indicate when the user was invited to the parent shared folder. This
        /// value may be absent.
        public let timeInvited: Date?
        public init(id: String, name: String, policy: Sharing.FolderPolicy, previewUrl: String, accessType: Sharing.AccessLevel? = nil, expectedLinkMetadata: Sharing.ExpectedSharedContentLinkMetadata? = nil, linkMetadata: Sharing.SharedContentLinkMetadata? = nil, ownerDisplayNames: Array<String>? = nil, ownerTeam: Users.Team? = nil, parentSharedFolderId: String? = nil, pathDisplay: String? = nil, pathLower: String? = nil, permissions: Array<Sharing.FilePermission>? = nil, timeInvited: Date? = nil) {
            self.accessType = accessType
            stringValidator(minLength: 4, pattern: "id:.+")(id)
            self.id = id
            self.expectedLinkMetadata = expectedLinkMetadata
            self.linkMetadata = linkMetadata
            stringValidator()(name)
            self.name = name
            nullableValidator(arrayValidator(itemValidator: stringValidator()))(ownerDisplayNames)
            self.ownerDisplayNames = ownerDisplayNames
            self.ownerTeam = ownerTeam
            nullableValidator(stringValidator(pattern: "[-_0-9a-zA-Z:]+"))(parentSharedFolderId)
            self.parentSharedFolderId = parentSharedFolderId
            nullableValidator(stringValidator())(pathDisplay)
            self.pathDisplay = pathDisplay
            nullableValidator(stringValidator())(pathLower)
            self.pathLower = pathLower
            self.permissions = permissions
            self.policy = policy
            stringValidator()(previewUrl)
            self.previewUrl = previewUrl
            self.timeInvited = timeInvited
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedFileMetadataSerializer().serialize(self)))"
        }
    }
    open class SharedFileMetadataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedFileMetadata) -> JSON {
            let output = [ 
            "id": Serialization._StringSerializer.serialize(value.id),
            "name": Serialization._StringSerializer.serialize(value.name),
            "policy": Sharing.FolderPolicySerializer().serialize(value.policy),
            "preview_url": Serialization._StringSerializer.serialize(value.previewUrl),
            "access_type": NullableSerializer(Sharing.AccessLevelSerializer()).serialize(value.accessType),
            "expected_link_metadata": NullableSerializer(Sharing.ExpectedSharedContentLinkMetadataSerializer()).serialize(value.expectedLinkMetadata),
            "link_metadata": NullableSerializer(Sharing.SharedContentLinkMetadataSerializer()).serialize(value.linkMetadata),
            "owner_display_names": NullableSerializer(ArraySerializer(Serialization._StringSerializer)).serialize(value.ownerDisplayNames),
            "owner_team": NullableSerializer(Users.TeamSerializer()).serialize(value.ownerTeam),
            "parent_shared_folder_id": NullableSerializer(Serialization._StringSerializer).serialize(value.parentSharedFolderId),
            "path_display": NullableSerializer(Serialization._StringSerializer).serialize(value.pathDisplay),
            "path_lower": NullableSerializer(Serialization._StringSerializer).serialize(value.pathLower),
            "permissions": NullableSerializer(ArraySerializer(Sharing.FilePermissionSerializer())).serialize(value.permissions),
            "time_invited": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.timeInvited),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedFileMetadata {
            switch json {
                case .dictionary(let dict):
                    let id = Serialization._StringSerializer.deserialize(dict["id"] ?? .null)
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                    let policy = Sharing.FolderPolicySerializer().deserialize(dict["policy"] ?? .null)
                    let previewUrl = Serialization._StringSerializer.deserialize(dict["preview_url"] ?? .null)
                    let accessType = NullableSerializer(Sharing.AccessLevelSerializer()).deserialize(dict["access_type"] ?? .null)
                    let expectedLinkMetadata = NullableSerializer(Sharing.ExpectedSharedContentLinkMetadataSerializer()).deserialize(dict["expected_link_metadata"] ?? .null)
                    let linkMetadata = NullableSerializer(Sharing.SharedContentLinkMetadataSerializer()).deserialize(dict["link_metadata"] ?? .null)
                    let ownerDisplayNames = NullableSerializer(ArraySerializer(Serialization._StringSerializer)).deserialize(dict["owner_display_names"] ?? .null)
                    let ownerTeam = NullableSerializer(Users.TeamSerializer()).deserialize(dict["owner_team"] ?? .null)
                    let parentSharedFolderId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["parent_shared_folder_id"] ?? .null)
                    let pathDisplay = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_display"] ?? .null)
                    let pathLower = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_lower"] ?? .null)
                    let permissions = NullableSerializer(ArraySerializer(Sharing.FilePermissionSerializer())).deserialize(dict["permissions"] ?? .null)
                    let timeInvited = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["time_invited"] ?? .null)
                    return SharedFileMetadata(id: id, name: name, policy: policy, previewUrl: previewUrl, accessType: accessType, expectedLinkMetadata: expectedLinkMetadata, linkMetadata: linkMetadata, ownerDisplayNames: ownerDisplayNames, ownerTeam: ownerTeam, parentSharedFolderId: parentSharedFolderId, pathDisplay: pathDisplay, pathLower: pathLower, permissions: permissions, timeInvited: timeInvited)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// There is an error accessing the shared folder.
    public enum SharedFolderAccessError: CustomStringConvertible {
        /// This shared folder ID is invalid.
        case invalidId
        /// The user is not a member of the shared folder thus cannot access it.
        case notAMember
        /// Never set.
        case emailUnverified
        /// The shared folder is unmounted.
        case unmounted
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedFolderAccessErrorSerializer().serialize(self)))"
        }
    }
    open class SharedFolderAccessErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedFolderAccessError) -> JSON {
            switch value {
                case .invalidId:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_id")
                    return .dictionary(d)
                case .notAMember:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_a_member")
                    return .dictionary(d)
                case .emailUnverified:
                    var d = [String: JSON]()
                    d[".tag"] = .str("email_unverified")
                    return .dictionary(d)
                case .unmounted:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unmounted")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SharedFolderAccessError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "invalid_id":
                            return SharedFolderAccessError.invalidId
                        case "not_a_member":
                            return SharedFolderAccessError.notAMember
                        case "email_unverified":
                            return SharedFolderAccessError.emailUnverified
                        case "unmounted":
                            return SharedFolderAccessError.unmounted
                        case "other":
                            return SharedFolderAccessError.other
                        default:
                            return SharedFolderAccessError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The SharedFolderMemberError union
    public enum SharedFolderMemberError: CustomStringConvertible {
        /// The target dropbox_id is invalid.
        case invalidDropboxId
        /// The target dropbox_id is not a member of the shared folder.
        case notAMember
        /// The target member only has inherited access to the shared folder.
        case noExplicitAccess(Sharing.MemberAccessLevelResult)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedFolderMemberErrorSerializer().serialize(self)))"
        }
    }
    open class SharedFolderMemberErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedFolderMemberError) -> JSON {
            switch value {
                case .invalidDropboxId:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_dropbox_id")
                    return .dictionary(d)
                case .notAMember:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_a_member")
                    return .dictionary(d)
                case .noExplicitAccess(let arg):
                    var d = Serialization.getFields(Sharing.MemberAccessLevelResultSerializer().serialize(arg))
                    d[".tag"] = .str("no_explicit_access")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SharedFolderMemberError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "invalid_dropbox_id":
                            return SharedFolderMemberError.invalidDropboxId
                        case "not_a_member":
                            return SharedFolderMemberError.notAMember
                        case "no_explicit_access":
                            let v = Sharing.MemberAccessLevelResultSerializer().deserialize(json)
                            return SharedFolderMemberError.noExplicitAccess(v)
                        case "other":
                            return SharedFolderMemberError.other
                        default:
                            return SharedFolderMemberError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Shared folder user and group membership.
    open class SharedFolderMembers: CustomStringConvertible {
        /// The list of user members of the shared folder.
        public let users: Array<Sharing.UserMembershipInfo>
        /// The list of group members of the shared folder.
        public let groups: Array<Sharing.GroupMembershipInfo>
        /// The list of invitees to the shared folder.
        public let invitees: Array<Sharing.InviteeMembershipInfo>
        /// Present if there are additional shared folder members that have not been returned yet. Pass the cursor into
        /// listFolderMembersContinue to list additional members.
        public let cursor: String?
        public init(users: Array<Sharing.UserMembershipInfo>, groups: Array<Sharing.GroupMembershipInfo>, invitees: Array<Sharing.InviteeMembershipInfo>, cursor: String? = nil) {
            self.users = users
            self.groups = groups
            self.invitees = invitees
            nullableValidator(stringValidator())(cursor)
            self.cursor = cursor
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedFolderMembersSerializer().serialize(self)))"
        }
    }
    open class SharedFolderMembersSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedFolderMembers) -> JSON {
            let output = [ 
            "users": ArraySerializer(Sharing.UserMembershipInfoSerializer()).serialize(value.users),
            "groups": ArraySerializer(Sharing.GroupMembershipInfoSerializer()).serialize(value.groups),
            "invitees": ArraySerializer(Sharing.InviteeMembershipInfoSerializer()).serialize(value.invitees),
            "cursor": NullableSerializer(Serialization._StringSerializer).serialize(value.cursor),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedFolderMembers {
            switch json {
                case .dictionary(let dict):
                    let users = ArraySerializer(Sharing.UserMembershipInfoSerializer()).deserialize(dict["users"] ?? .null)
                    let groups = ArraySerializer(Sharing.GroupMembershipInfoSerializer()).deserialize(dict["groups"] ?? .null)
                    let invitees = ArraySerializer(Sharing.InviteeMembershipInfoSerializer()).deserialize(dict["invitees"] ?? .null)
                    let cursor = NullableSerializer(Serialization._StringSerializer).deserialize(dict["cursor"] ?? .null)
                    return SharedFolderMembers(users: users, groups: groups, invitees: invitees, cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Properties of the shared folder.
    open class SharedFolderMetadataBase: CustomStringConvertible {
        /// The current user's access level for this shared folder.
        public let accessType: Sharing.AccessLevel
        /// Whether this folder is inside of a team folder.
        public let isInsideTeamFolder: Bool
        /// Whether this folder is a team folder https://www.dropbox.com/en/help/986.
        public let isTeamFolder: Bool
        /// The display names of the users that own the folder. If the folder is part of a team folder, the display
        /// names of the team admins are also included. Absent if the owner display names cannot be fetched.
        public let ownerDisplayNames: Array<String>?
        /// The team that owns the folder. This field is not present if the folder is not owned by a team.
        public let ownerTeam: Users.Team?
        /// The ID of the parent shared folder. This field is present only if the folder is contained within another
        /// shared folder.
        public let parentSharedFolderId: String?
        /// The lower-cased full path of this shared folder. Absent for unmounted folders.
        public let pathLower: String?
        public init(accessType: Sharing.AccessLevel, isInsideTeamFolder: Bool, isTeamFolder: Bool, ownerDisplayNames: Array<String>? = nil, ownerTeam: Users.Team? = nil, parentSharedFolderId: String? = nil, pathLower: String? = nil) {
            self.accessType = accessType
            self.isInsideTeamFolder = isInsideTeamFolder
            self.isTeamFolder = isTeamFolder
            nullableValidator(arrayValidator(itemValidator: stringValidator()))(ownerDisplayNames)
            self.ownerDisplayNames = ownerDisplayNames
            self.ownerTeam = ownerTeam
            nullableValidator(stringValidator(pattern: "[-_0-9a-zA-Z:]+"))(parentSharedFolderId)
            self.parentSharedFolderId = parentSharedFolderId
            nullableValidator(stringValidator())(pathLower)
            self.pathLower = pathLower
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedFolderMetadataBaseSerializer().serialize(self)))"
        }
    }
    open class SharedFolderMetadataBaseSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedFolderMetadataBase) -> JSON {
            let output = [ 
            "access_type": Sharing.AccessLevelSerializer().serialize(value.accessType),
            "is_inside_team_folder": Serialization._BoolSerializer.serialize(value.isInsideTeamFolder),
            "is_team_folder": Serialization._BoolSerializer.serialize(value.isTeamFolder),
            "owner_display_names": NullableSerializer(ArraySerializer(Serialization._StringSerializer)).serialize(value.ownerDisplayNames),
            "owner_team": NullableSerializer(Users.TeamSerializer()).serialize(value.ownerTeam),
            "parent_shared_folder_id": NullableSerializer(Serialization._StringSerializer).serialize(value.parentSharedFolderId),
            "path_lower": NullableSerializer(Serialization._StringSerializer).serialize(value.pathLower),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedFolderMetadataBase {
            switch json {
                case .dictionary(let dict):
                    let accessType = Sharing.AccessLevelSerializer().deserialize(dict["access_type"] ?? .null)
                    let isInsideTeamFolder = Serialization._BoolSerializer.deserialize(dict["is_inside_team_folder"] ?? .null)
                    let isTeamFolder = Serialization._BoolSerializer.deserialize(dict["is_team_folder"] ?? .null)
                    let ownerDisplayNames = NullableSerializer(ArraySerializer(Serialization._StringSerializer)).deserialize(dict["owner_display_names"] ?? .null)
                    let ownerTeam = NullableSerializer(Users.TeamSerializer()).deserialize(dict["owner_team"] ?? .null)
                    let parentSharedFolderId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["parent_shared_folder_id"] ?? .null)
                    let pathLower = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_lower"] ?? .null)
                    return SharedFolderMetadataBase(accessType: accessType, isInsideTeamFolder: isInsideTeamFolder, isTeamFolder: isTeamFolder, ownerDisplayNames: ownerDisplayNames, ownerTeam: ownerTeam, parentSharedFolderId: parentSharedFolderId, pathLower: pathLower)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The metadata which includes basic information about the shared folder.
    open class SharedFolderMetadata: Sharing.SharedFolderMetadataBase {
        /// The metadata of the shared content link to this shared folder. Absent if there is no link on the folder.
        /// This is for an unreleased feature so it may not be returned yet.
        public let linkMetadata: Sharing.SharedContentLinkMetadata?
        /// The name of the this shared folder.
        public let name: String
        /// Actions the current user may perform on the folder and its contents. The set of permissions corresponds to
        /// the FolderActions in the request.
        public let permissions: Array<Sharing.FolderPermission>?
        /// Policies governing this shared folder.
        public let policy: Sharing.FolderPolicy
        /// URL for displaying a web preview of the shared folder.
        public let previewUrl: String
        /// The ID of the shared folder.
        public let sharedFolderId: String
        /// Timestamp indicating when the current user was invited to this shared folder.
        public let timeInvited: Date
        /// Whether the folder inherits its members from its parent.
        public let accessInheritance: Sharing.AccessInheritance
        public init(accessType: Sharing.AccessLevel, isInsideTeamFolder: Bool, isTeamFolder: Bool, name: String, policy: Sharing.FolderPolicy, previewUrl: String, sharedFolderId: String, timeInvited: Date, ownerDisplayNames: Array<String>? = nil, ownerTeam: Users.Team? = nil, parentSharedFolderId: String? = nil, pathLower: String? = nil, linkMetadata: Sharing.SharedContentLinkMetadata? = nil, permissions: Array<Sharing.FolderPermission>? = nil, accessInheritance: Sharing.AccessInheritance = .inherit) {
            self.linkMetadata = linkMetadata
            stringValidator()(name)
            self.name = name
            self.permissions = permissions
            self.policy = policy
            stringValidator()(previewUrl)
            self.previewUrl = previewUrl
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.timeInvited = timeInvited
            self.accessInheritance = accessInheritance
            super.init(accessType: accessType, isInsideTeamFolder: isInsideTeamFolder, isTeamFolder: isTeamFolder, ownerDisplayNames: ownerDisplayNames, ownerTeam: ownerTeam, parentSharedFolderId: parentSharedFolderId, pathLower: pathLower)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedFolderMetadataSerializer().serialize(self)))"
        }
    }
    open class SharedFolderMetadataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedFolderMetadata) -> JSON {
            let output = [ 
            "access_type": Sharing.AccessLevelSerializer().serialize(value.accessType),
            "is_inside_team_folder": Serialization._BoolSerializer.serialize(value.isInsideTeamFolder),
            "is_team_folder": Serialization._BoolSerializer.serialize(value.isTeamFolder),
            "name": Serialization._StringSerializer.serialize(value.name),
            "policy": Sharing.FolderPolicySerializer().serialize(value.policy),
            "preview_url": Serialization._StringSerializer.serialize(value.previewUrl),
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            "time_invited": NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.timeInvited),
            "owner_display_names": NullableSerializer(ArraySerializer(Serialization._StringSerializer)).serialize(value.ownerDisplayNames),
            "owner_team": NullableSerializer(Users.TeamSerializer()).serialize(value.ownerTeam),
            "parent_shared_folder_id": NullableSerializer(Serialization._StringSerializer).serialize(value.parentSharedFolderId),
            "path_lower": NullableSerializer(Serialization._StringSerializer).serialize(value.pathLower),
            "link_metadata": NullableSerializer(Sharing.SharedContentLinkMetadataSerializer()).serialize(value.linkMetadata),
            "permissions": NullableSerializer(ArraySerializer(Sharing.FolderPermissionSerializer())).serialize(value.permissions),
            "access_inheritance": Sharing.AccessInheritanceSerializer().serialize(value.accessInheritance),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedFolderMetadata {
            switch json {
                case .dictionary(let dict):
                    let accessType = Sharing.AccessLevelSerializer().deserialize(dict["access_type"] ?? .null)
                    let isInsideTeamFolder = Serialization._BoolSerializer.deserialize(dict["is_inside_team_folder"] ?? .null)
                    let isTeamFolder = Serialization._BoolSerializer.deserialize(dict["is_team_folder"] ?? .null)
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                    let policy = Sharing.FolderPolicySerializer().deserialize(dict["policy"] ?? .null)
                    let previewUrl = Serialization._StringSerializer.deserialize(dict["preview_url"] ?? .null)
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                    let timeInvited = NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["time_invited"] ?? .null)
                    let ownerDisplayNames = NullableSerializer(ArraySerializer(Serialization._StringSerializer)).deserialize(dict["owner_display_names"] ?? .null)
                    let ownerTeam = NullableSerializer(Users.TeamSerializer()).deserialize(dict["owner_team"] ?? .null)
                    let parentSharedFolderId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["parent_shared_folder_id"] ?? .null)
                    let pathLower = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_lower"] ?? .null)
                    let linkMetadata = NullableSerializer(Sharing.SharedContentLinkMetadataSerializer()).deserialize(dict["link_metadata"] ?? .null)
                    let permissions = NullableSerializer(ArraySerializer(Sharing.FolderPermissionSerializer())).deserialize(dict["permissions"] ?? .null)
                    let accessInheritance = Sharing.AccessInheritanceSerializer().deserialize(dict["access_inheritance"] ?? Sharing.AccessInheritanceSerializer().serialize(.inherit))
                    return SharedFolderMetadata(accessType: accessType, isInsideTeamFolder: isInsideTeamFolder, isTeamFolder: isTeamFolder, name: name, policy: policy, previewUrl: previewUrl, sharedFolderId: sharedFolderId, timeInvited: timeInvited, ownerDisplayNames: ownerDisplayNames, ownerTeam: ownerTeam, parentSharedFolderId: parentSharedFolderId, pathLower: pathLower, linkMetadata: linkMetadata, permissions: permissions, accessInheritance: accessInheritance)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedLinkAccessFailureReason union
    public enum SharedLinkAccessFailureReason: CustomStringConvertible {
        /// User is not logged in.
        case loginRequired
        /// User's email is not verified.
        case emailVerifyRequired
        /// The link is password protected.
        case passwordRequired
        /// Access is allowed for team members only.
        case teamOnly
        /// Access is allowed for the shared link's owner only.
        case ownerOnly
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedLinkAccessFailureReasonSerializer().serialize(self)))"
        }
    }
    open class SharedLinkAccessFailureReasonSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedLinkAccessFailureReason) -> JSON {
            switch value {
                case .loginRequired:
                    var d = [String: JSON]()
                    d[".tag"] = .str("login_required")
                    return .dictionary(d)
                case .emailVerifyRequired:
                    var d = [String: JSON]()
                    d[".tag"] = .str("email_verify_required")
                    return .dictionary(d)
                case .passwordRequired:
                    var d = [String: JSON]()
                    d[".tag"] = .str("password_required")
                    return .dictionary(d)
                case .teamOnly:
                    var d = [String: JSON]()
                    d[".tag"] = .str("team_only")
                    return .dictionary(d)
                case .ownerOnly:
                    var d = [String: JSON]()
                    d[".tag"] = .str("owner_only")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SharedLinkAccessFailureReason {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "login_required":
                            return SharedLinkAccessFailureReason.loginRequired
                        case "email_verify_required":
                            return SharedLinkAccessFailureReason.emailVerifyRequired
                        case "password_required":
                            return SharedLinkAccessFailureReason.passwordRequired
                        case "team_only":
                            return SharedLinkAccessFailureReason.teamOnly
                        case "owner_only":
                            return SharedLinkAccessFailureReason.ownerOnly
                        case "other":
                            return SharedLinkAccessFailureReason.other
                        default:
                            return SharedLinkAccessFailureReason.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Who can view shared links in this folder.
    public enum SharedLinkPolicy: CustomStringConvertible {
        /// Links can be shared with anyone.
        case anyone
        /// Links can be shared with anyone on the same team as the owner.
        case team
        /// Links can only be shared among members of the shared folder.
        case members
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedLinkPolicySerializer().serialize(self)))"
        }
    }
    open class SharedLinkPolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedLinkPolicy) -> JSON {
            switch value {
                case .anyone:
                    var d = [String: JSON]()
                    d[".tag"] = .str("anyone")
                    return .dictionary(d)
                case .team:
                    var d = [String: JSON]()
                    d[".tag"] = .str("team")
                    return .dictionary(d)
                case .members:
                    var d = [String: JSON]()
                    d[".tag"] = .str("members")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SharedLinkPolicy {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "anyone":
                            return SharedLinkPolicy.anyone
                        case "team":
                            return SharedLinkPolicy.team
                        case "members":
                            return SharedLinkPolicy.members
                        case "other":
                            return SharedLinkPolicy.other
                        default:
                            return SharedLinkPolicy.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The SharedLinkSettings struct
    open class SharedLinkSettings: CustomStringConvertible {
        /// The requested access for this shared link.
        public let requestedVisibility: Sharing.RequestedVisibility?
        /// If requestedVisibility is password in RequestedVisibility this is needed to specify the password to access
        /// the link.
        public let linkPassword: String?
        /// Expiration time of the shared link. By default the link won't expire.
        public let expires: Date?
        public init(requestedVisibility: Sharing.RequestedVisibility? = nil, linkPassword: String? = nil, expires: Date? = nil) {
            self.requestedVisibility = requestedVisibility
            nullableValidator(stringValidator())(linkPassword)
            self.linkPassword = linkPassword
            self.expires = expires
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedLinkSettingsSerializer().serialize(self)))"
        }
    }
    open class SharedLinkSettingsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedLinkSettings) -> JSON {
            let output = [ 
            "requested_visibility": NullableSerializer(Sharing.RequestedVisibilitySerializer()).serialize(value.requestedVisibility),
            "link_password": NullableSerializer(Serialization._StringSerializer).serialize(value.linkPassword),
            "expires": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.expires),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedLinkSettings {
            switch json {
                case .dictionary(let dict):
                    let requestedVisibility = NullableSerializer(Sharing.RequestedVisibilitySerializer()).deserialize(dict["requested_visibility"] ?? .null)
                    let linkPassword = NullableSerializer(Serialization._StringSerializer).deserialize(dict["link_password"] ?? .null)
                    let expires = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["expires"] ?? .null)
                    return SharedLinkSettings(requestedVisibility: requestedVisibility, linkPassword: linkPassword, expires: expires)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedLinkSettingsError union
    public enum SharedLinkSettingsError: CustomStringConvertible {
        /// The given settings are invalid (for example, all attributes of the SharedLinkSettings are empty, the
        /// requested visibility is password in RequestedVisibility but the linkPassword in SharedLinkSettings is
        /// missing, expires in SharedLinkSettings is set to the past, etc.).
        case invalidSettings
        /// User is not allowed to modify the settings of this link. Note that basic users can only set public_ in
        /// RequestedVisibility as the requestedVisibility in SharedLinkSettings and cannot set expires in
        /// SharedLinkSettings.
        case notAuthorized

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedLinkSettingsErrorSerializer().serialize(self)))"
        }
    }
    open class SharedLinkSettingsErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedLinkSettingsError) -> JSON {
            switch value {
                case .invalidSettings:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_settings")
                    return .dictionary(d)
                case .notAuthorized:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_authorized")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SharedLinkSettingsError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "invalid_settings":
                            return SharedLinkSettingsError.invalidSettings
                        case "not_authorized":
                            return SharedLinkSettingsError.notAuthorized
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// User could not access this file.
    public enum SharingFileAccessError: CustomStringConvertible {
        /// Current user does not have sufficient privileges to perform the desired action.
        case noPermission
        /// File specified was not found.
        case invalidFile
        /// A folder can't be shared this way. Use folder sharing or a shared link instead.
        case isFolder
        /// A file inside a public folder can't be shared this way. Use a public link instead.
        case insidePublicFolder
        /// A Mac OS X package can't be shared this way. Use a shared link instead.
        case insideOsxPackage
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharingFileAccessErrorSerializer().serialize(self)))"
        }
    }
    open class SharingFileAccessErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharingFileAccessError) -> JSON {
            switch value {
                case .noPermission:
                    var d = [String: JSON]()
                    d[".tag"] = .str("no_permission")
                    return .dictionary(d)
                case .invalidFile:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_file")
                    return .dictionary(d)
                case .isFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("is_folder")
                    return .dictionary(d)
                case .insidePublicFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("inside_public_folder")
                    return .dictionary(d)
                case .insideOsxPackage:
                    var d = [String: JSON]()
                    d[".tag"] = .str("inside_osx_package")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SharingFileAccessError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "no_permission":
                            return SharingFileAccessError.noPermission
                        case "invalid_file":
                            return SharingFileAccessError.invalidFile
                        case "is_folder":
                            return SharingFileAccessError.isFolder
                        case "inside_public_folder":
                            return SharingFileAccessError.insidePublicFolder
                        case "inside_osx_package":
                            return SharingFileAccessError.insideOsxPackage
                        case "other":
                            return SharingFileAccessError.other
                        default:
                            return SharingFileAccessError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// User account had a problem preventing this action.
    public enum SharingUserError: CustomStringConvertible {
        /// The current user must verify the account e-mail address before performing this action.
        case emailUnverified
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharingUserErrorSerializer().serialize(self)))"
        }
    }
    open class SharingUserErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharingUserError) -> JSON {
            switch value {
                case .emailUnverified:
                    var d = [String: JSON]()
                    d[".tag"] = .str("email_unverified")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SharingUserError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "email_unverified":
                            return SharingUserError.emailUnverified
                        case "other":
                            return SharingUserError.other
                        default:
                            return SharingUserError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Information about a team member.
    open class TeamMemberInfo: CustomStringConvertible {
        /// Information about the member's team.
        public let teamInfo: Users.Team
        /// The display name of the user.
        public let displayName: String
        /// ID of user as a member of a team. This field will only be present if the member is in the same team as
        /// current user.
        public let memberId: String?
        public init(teamInfo: Users.Team, displayName: String, memberId: String? = nil) {
            self.teamInfo = teamInfo
            stringValidator()(displayName)
            self.displayName = displayName
            nullableValidator(stringValidator())(memberId)
            self.memberId = memberId
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamMemberInfoSerializer().serialize(self)))"
        }
    }
    open class TeamMemberInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamMemberInfo) -> JSON {
            let output = [ 
            "team_info": Users.TeamSerializer().serialize(value.teamInfo),
            "display_name": Serialization._StringSerializer.serialize(value.displayName),
            "member_id": NullableSerializer(Serialization._StringSerializer).serialize(value.memberId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TeamMemberInfo {
            switch json {
                case .dictionary(let dict):
                    let teamInfo = Users.TeamSerializer().deserialize(dict["team_info"] ?? .null)
                    let displayName = Serialization._StringSerializer.deserialize(dict["display_name"] ?? .null)
                    let memberId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["member_id"] ?? .null)
                    return TeamMemberInfo(teamInfo: teamInfo, displayName: displayName, memberId: memberId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The TransferFolderArg struct
    open class TransferFolderArg: CustomStringConvertible {
        /// The ID for the shared folder.
        public let sharedFolderId: String
        /// A account or team member ID to transfer ownership to.
        public let toDropboxId: String
        public init(sharedFolderId: String, toDropboxId: String) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            stringValidator(minLength: 1)(toDropboxId)
            self.toDropboxId = toDropboxId
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TransferFolderArgSerializer().serialize(self)))"
        }
    }
    open class TransferFolderArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TransferFolderArg) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            "to_dropbox_id": Serialization._StringSerializer.serialize(value.toDropboxId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TransferFolderArg {
            switch json {
                case .dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                    let toDropboxId = Serialization._StringSerializer.deserialize(dict["to_dropbox_id"] ?? .null)
                    return TransferFolderArg(sharedFolderId: sharedFolderId, toDropboxId: toDropboxId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The TransferFolderError union
    public enum TransferFolderError: CustomStringConvertible {
        /// An unspecified error.
        case accessError(Sharing.SharedFolderAccessError)
        /// toDropboxId in TransferFolderArg is invalid.
        case invalidDropboxId
        /// The new designated owner is not currently a member of the shared folder.
        case newOwnerNotAMember
        /// The new designated owner has not added the folder to their Dropbox.
        case newOwnerUnmounted
        /// The new designated owner's e-mail address is unverified.
        case newOwnerEmailUnverified
        /// This action cannot be performed on a team shared folder.
        case teamFolder
        /// The current user does not have permission to perform this action.
        case noPermission
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TransferFolderErrorSerializer().serialize(self)))"
        }
    }
    open class TransferFolderErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TransferFolderError) -> JSON {
            switch value {
                case .accessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("access_error")
                    return .dictionary(d)
                case .invalidDropboxId:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_dropbox_id")
                    return .dictionary(d)
                case .newOwnerNotAMember:
                    var d = [String: JSON]()
                    d[".tag"] = .str("new_owner_not_a_member")
                    return .dictionary(d)
                case .newOwnerUnmounted:
                    var d = [String: JSON]()
                    d[".tag"] = .str("new_owner_unmounted")
                    return .dictionary(d)
                case .newOwnerEmailUnverified:
                    var d = [String: JSON]()
                    d[".tag"] = .str("new_owner_email_unverified")
                    return .dictionary(d)
                case .teamFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("team_folder")
                    return .dictionary(d)
                case .noPermission:
                    var d = [String: JSON]()
                    d[".tag"] = .str("no_permission")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> TransferFolderError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                            return TransferFolderError.accessError(v)
                        case "invalid_dropbox_id":
                            return TransferFolderError.invalidDropboxId
                        case "new_owner_not_a_member":
                            return TransferFolderError.newOwnerNotAMember
                        case "new_owner_unmounted":
                            return TransferFolderError.newOwnerUnmounted
                        case "new_owner_email_unverified":
                            return TransferFolderError.newOwnerEmailUnverified
                        case "team_folder":
                            return TransferFolderError.teamFolder
                        case "no_permission":
                            return TransferFolderError.noPermission
                        case "other":
                            return TransferFolderError.other
                        default:
                            return TransferFolderError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The UnmountFolderArg struct
    open class UnmountFolderArg: CustomStringConvertible {
        /// The ID for the shared folder.
        public let sharedFolderId: String
        public init(sharedFolderId: String) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UnmountFolderArgSerializer().serialize(self)))"
        }
    }
    open class UnmountFolderArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UnmountFolderArg) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UnmountFolderArg {
            switch json {
                case .dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                    return UnmountFolderArg(sharedFolderId: sharedFolderId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UnmountFolderError union
    public enum UnmountFolderError: CustomStringConvertible {
        /// An unspecified error.
        case accessError(Sharing.SharedFolderAccessError)
        /// The current user does not have permission to perform this action.
        case noPermission
        /// The shared folder can't be unmounted. One example where this can occur is when the shared folder's parent
        /// folder is also a shared folder that resides in the current user's Dropbox.
        case notUnmountable
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UnmountFolderErrorSerializer().serialize(self)))"
        }
    }
    open class UnmountFolderErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UnmountFolderError) -> JSON {
            switch value {
                case .accessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("access_error")
                    return .dictionary(d)
                case .noPermission:
                    var d = [String: JSON]()
                    d[".tag"] = .str("no_permission")
                    return .dictionary(d)
                case .notUnmountable:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_unmountable")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> UnmountFolderError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                            return UnmountFolderError.accessError(v)
                        case "no_permission":
                            return UnmountFolderError.noPermission
                        case "not_unmountable":
                            return UnmountFolderError.notUnmountable
                        case "other":
                            return UnmountFolderError.other
                        default:
                            return UnmountFolderError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Arguments for unshareFile.
    open class UnshareFileArg: CustomStringConvertible {
        /// The file to unshare.
        public let file: String
        public init(file: String) {
            stringValidator(minLength: 1, pattern: "((/|id:).*|nspath:[0-9]+:.*)|ns:[0-9]+(/.*)?")(file)
            self.file = file
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UnshareFileArgSerializer().serialize(self)))"
        }
    }
    open class UnshareFileArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UnshareFileArg) -> JSON {
            let output = [ 
            "file": Serialization._StringSerializer.serialize(value.file),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UnshareFileArg {
            switch json {
                case .dictionary(let dict):
                    let file = Serialization._StringSerializer.deserialize(dict["file"] ?? .null)
                    return UnshareFileArg(file: file)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Error result for unshareFile.
    public enum UnshareFileError: CustomStringConvertible {
        /// An unspecified error.
        case userError(Sharing.SharingUserError)
        /// An unspecified error.
        case accessError(Sharing.SharingFileAccessError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UnshareFileErrorSerializer().serialize(self)))"
        }
    }
    open class UnshareFileErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UnshareFileError) -> JSON {
            switch value {
                case .userError(let arg):
                    var d = ["user_error": Sharing.SharingUserErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("user_error")
                    return .dictionary(d)
                case .accessError(let arg):
                    var d = ["access_error": Sharing.SharingFileAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("access_error")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> UnshareFileError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "user_error":
                            let v = Sharing.SharingUserErrorSerializer().deserialize(d["user_error"] ?? .null)
                            return UnshareFileError.userError(v)
                        case "access_error":
                            let v = Sharing.SharingFileAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                            return UnshareFileError.accessError(v)
                        case "other":
                            return UnshareFileError.other
                        default:
                            return UnshareFileError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The UnshareFolderArg struct
    open class UnshareFolderArg: CustomStringConvertible {
        /// The ID for the shared folder.
        public let sharedFolderId: String
        /// If true, members of this shared folder will get a copy of this folder after it's unshared. Otherwise, it
        /// will be removed from their Dropbox. The current user, who is an owner, will always retain their copy.
        public let leaveACopy: Bool
        public init(sharedFolderId: String, leaveACopy: Bool = false) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.leaveACopy = leaveACopy
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UnshareFolderArgSerializer().serialize(self)))"
        }
    }
    open class UnshareFolderArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UnshareFolderArg) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            "leave_a_copy": Serialization._BoolSerializer.serialize(value.leaveACopy),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UnshareFolderArg {
            switch json {
                case .dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                    let leaveACopy = Serialization._BoolSerializer.deserialize(dict["leave_a_copy"] ?? .number(0))
                    return UnshareFolderArg(sharedFolderId: sharedFolderId, leaveACopy: leaveACopy)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UnshareFolderError union
    public enum UnshareFolderError: CustomStringConvertible {
        /// An unspecified error.
        case accessError(Sharing.SharedFolderAccessError)
        /// This action cannot be performed on a team shared folder.
        case teamFolder
        /// The current user does not have permission to perform this action.
        case noPermission
        /// This shared folder has too many files to be unshared.
        case tooManyFiles
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UnshareFolderErrorSerializer().serialize(self)))"
        }
    }
    open class UnshareFolderErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UnshareFolderError) -> JSON {
            switch value {
                case .accessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("access_error")
                    return .dictionary(d)
                case .teamFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("team_folder")
                    return .dictionary(d)
                case .noPermission:
                    var d = [String: JSON]()
                    d[".tag"] = .str("no_permission")
                    return .dictionary(d)
                case .tooManyFiles:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_files")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> UnshareFolderError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                            return UnshareFolderError.accessError(v)
                        case "team_folder":
                            return UnshareFolderError.teamFolder
                        case "no_permission":
                            return UnshareFolderError.noPermission
                        case "too_many_files":
                            return UnshareFolderError.tooManyFiles
                        case "other":
                            return UnshareFolderError.other
                        default:
                            return UnshareFolderError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Arguments for updateFileMember.
    open class UpdateFileMemberArgs: Sharing.ChangeFileMemberAccessArgs {
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UpdateFileMemberArgsSerializer().serialize(self)))"
        }
    }
    open class UpdateFileMemberArgsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UpdateFileMemberArgs) -> JSON {
            let output = [ 
            "file": Serialization._StringSerializer.serialize(value.file),
            "member": Sharing.MemberSelectorSerializer().serialize(value.member),
            "access_level": Sharing.AccessLevelSerializer().serialize(value.accessLevel),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UpdateFileMemberArgs {
            switch json {
                case .dictionary(let dict):
                    let file = Serialization._StringSerializer.deserialize(dict["file"] ?? .null)
                    let member = Sharing.MemberSelectorSerializer().deserialize(dict["member"] ?? .null)
                    let accessLevel = Sharing.AccessLevelSerializer().deserialize(dict["access_level"] ?? .null)
                    return UpdateFileMemberArgs(file: file, member: member, accessLevel: accessLevel)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UpdateFolderMemberArg struct
    open class UpdateFolderMemberArg: CustomStringConvertible {
        /// The ID for the shared folder.
        public let sharedFolderId: String
        /// The member of the shared folder to update.  Only the dropboxId in MemberSelector may be set at this time.
        public let member: Sharing.MemberSelector
        /// The new access level for member. owner in AccessLevel is disallowed.
        public let accessLevel: Sharing.AccessLevel
        public init(sharedFolderId: String, member: Sharing.MemberSelector, accessLevel: Sharing.AccessLevel) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.member = member
            self.accessLevel = accessLevel
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UpdateFolderMemberArgSerializer().serialize(self)))"
        }
    }
    open class UpdateFolderMemberArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UpdateFolderMemberArg) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            "member": Sharing.MemberSelectorSerializer().serialize(value.member),
            "access_level": Sharing.AccessLevelSerializer().serialize(value.accessLevel),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UpdateFolderMemberArg {
            switch json {
                case .dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                    let member = Sharing.MemberSelectorSerializer().deserialize(dict["member"] ?? .null)
                    let accessLevel = Sharing.AccessLevelSerializer().deserialize(dict["access_level"] ?? .null)
                    return UpdateFolderMemberArg(sharedFolderId: sharedFolderId, member: member, accessLevel: accessLevel)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UpdateFolderMemberError union
    public enum UpdateFolderMemberError: CustomStringConvertible {
        /// An unspecified error.
        case accessError(Sharing.SharedFolderAccessError)
        /// An unspecified error.
        case memberError(Sharing.SharedFolderMemberError)
        /// If updating the access type required the member to be added to the shared folder and there was an error when
        /// adding the member.
        case noExplicitAccess(Sharing.AddFolderMemberError)
        /// The current user's account doesn't support this action. An example of this is when downgrading a member from
        /// editor to viewer. This action can only be performed by users that have upgraded to a Pro or Business plan.
        case insufficientPlan
        /// The current user does not have permission to perform this action.
        case noPermission
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UpdateFolderMemberErrorSerializer().serialize(self)))"
        }
    }
    open class UpdateFolderMemberErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UpdateFolderMemberError) -> JSON {
            switch value {
                case .accessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("access_error")
                    return .dictionary(d)
                case .memberError(let arg):
                    var d = ["member_error": Sharing.SharedFolderMemberErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("member_error")
                    return .dictionary(d)
                case .noExplicitAccess(let arg):
                    var d = ["no_explicit_access": Sharing.AddFolderMemberErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("no_explicit_access")
                    return .dictionary(d)
                case .insufficientPlan:
                    var d = [String: JSON]()
                    d[".tag"] = .str("insufficient_plan")
                    return .dictionary(d)
                case .noPermission:
                    var d = [String: JSON]()
                    d[".tag"] = .str("no_permission")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> UpdateFolderMemberError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                            return UpdateFolderMemberError.accessError(v)
                        case "member_error":
                            let v = Sharing.SharedFolderMemberErrorSerializer().deserialize(d["member_error"] ?? .null)
                            return UpdateFolderMemberError.memberError(v)
                        case "no_explicit_access":
                            let v = Sharing.AddFolderMemberErrorSerializer().deserialize(d["no_explicit_access"] ?? .null)
                            return UpdateFolderMemberError.noExplicitAccess(v)
                        case "insufficient_plan":
                            return UpdateFolderMemberError.insufficientPlan
                        case "no_permission":
                            return UpdateFolderMemberError.noPermission
                        case "other":
                            return UpdateFolderMemberError.other
                        default:
                            return UpdateFolderMemberError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// If any of the policies are unset, then they retain their current setting.
    open class UpdateFolderPolicyArg: CustomStringConvertible {
        /// The ID for the shared folder.
        public let sharedFolderId: String
        /// Who can be a member of this shared folder. Only applicable if the current user is on a team.
        public let memberPolicy: Sharing.MemberPolicy?
        /// Who can add and remove members of this shared folder.
        public let aclUpdatePolicy: Sharing.AclUpdatePolicy?
        /// Who can enable/disable viewer info for this shared folder.
        public let viewerInfoPolicy: Sharing.ViewerInfoPolicy?
        /// The policy to apply to shared links created for content inside this shared folder. The current user must be
        /// on a team to set this policy to members in SharedLinkPolicy.
        public let sharedLinkPolicy: Sharing.SharedLinkPolicy?
        /// Settings on the link for this folder.
        public let linkSettings: Sharing.LinkSettings?
        /// A list of `FolderAction`s corresponding to `FolderPermission`s that should appear in the  response's
        /// permissions in SharedFolderMetadata field describing the actions the  authenticated user can perform on the
        /// folder.
        public let actions: Array<Sharing.FolderAction>?
        public init(sharedFolderId: String, memberPolicy: Sharing.MemberPolicy? = nil, aclUpdatePolicy: Sharing.AclUpdatePolicy? = nil, viewerInfoPolicy: Sharing.ViewerInfoPolicy? = nil, sharedLinkPolicy: Sharing.SharedLinkPolicy? = nil, linkSettings: Sharing.LinkSettings? = nil, actions: Array<Sharing.FolderAction>? = nil) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.memberPolicy = memberPolicy
            self.aclUpdatePolicy = aclUpdatePolicy
            self.viewerInfoPolicy = viewerInfoPolicy
            self.sharedLinkPolicy = sharedLinkPolicy
            self.linkSettings = linkSettings
            self.actions = actions
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UpdateFolderPolicyArgSerializer().serialize(self)))"
        }
    }
    open class UpdateFolderPolicyArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UpdateFolderPolicyArg) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            "member_policy": NullableSerializer(Sharing.MemberPolicySerializer()).serialize(value.memberPolicy),
            "acl_update_policy": NullableSerializer(Sharing.AclUpdatePolicySerializer()).serialize(value.aclUpdatePolicy),
            "viewer_info_policy": NullableSerializer(Sharing.ViewerInfoPolicySerializer()).serialize(value.viewerInfoPolicy),
            "shared_link_policy": NullableSerializer(Sharing.SharedLinkPolicySerializer()).serialize(value.sharedLinkPolicy),
            "link_settings": NullableSerializer(Sharing.LinkSettingsSerializer()).serialize(value.linkSettings),
            "actions": NullableSerializer(ArraySerializer(Sharing.FolderActionSerializer())).serialize(value.actions),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UpdateFolderPolicyArg {
            switch json {
                case .dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                    let memberPolicy = NullableSerializer(Sharing.MemberPolicySerializer()).deserialize(dict["member_policy"] ?? .null)
                    let aclUpdatePolicy = NullableSerializer(Sharing.AclUpdatePolicySerializer()).deserialize(dict["acl_update_policy"] ?? .null)
                    let viewerInfoPolicy = NullableSerializer(Sharing.ViewerInfoPolicySerializer()).deserialize(dict["viewer_info_policy"] ?? .null)
                    let sharedLinkPolicy = NullableSerializer(Sharing.SharedLinkPolicySerializer()).deserialize(dict["shared_link_policy"] ?? .null)
                    let linkSettings = NullableSerializer(Sharing.LinkSettingsSerializer()).deserialize(dict["link_settings"] ?? .null)
                    let actions = NullableSerializer(ArraySerializer(Sharing.FolderActionSerializer())).deserialize(dict["actions"] ?? .null)
                    return UpdateFolderPolicyArg(sharedFolderId: sharedFolderId, memberPolicy: memberPolicy, aclUpdatePolicy: aclUpdatePolicy, viewerInfoPolicy: viewerInfoPolicy, sharedLinkPolicy: sharedLinkPolicy, linkSettings: linkSettings, actions: actions)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UpdateFolderPolicyError union
    public enum UpdateFolderPolicyError: CustomStringConvertible {
        /// An unspecified error.
        case accessError(Sharing.SharedFolderAccessError)
        /// memberPolicy in UpdateFolderPolicyArg was set even though user is not on a team.
        case notOnTeam
        /// Team policy is more restrictive than memberPolicy in ShareFolderArg.
        case teamPolicyDisallowsMemberPolicy
        /// The current account is not allowed to select the specified sharedLinkPolicy in ShareFolderArg.
        case disallowedSharedLinkPolicy
        /// The current user does not have permission to perform this action.
        case noPermission
        /// This action cannot be performed on a team shared folder.
        case teamFolder
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UpdateFolderPolicyErrorSerializer().serialize(self)))"
        }
    }
    open class UpdateFolderPolicyErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UpdateFolderPolicyError) -> JSON {
            switch value {
                case .accessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("access_error")
                    return .dictionary(d)
                case .notOnTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_on_team")
                    return .dictionary(d)
                case .teamPolicyDisallowsMemberPolicy:
                    var d = [String: JSON]()
                    d[".tag"] = .str("team_policy_disallows_member_policy")
                    return .dictionary(d)
                case .disallowedSharedLinkPolicy:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disallowed_shared_link_policy")
                    return .dictionary(d)
                case .noPermission:
                    var d = [String: JSON]()
                    d[".tag"] = .str("no_permission")
                    return .dictionary(d)
                case .teamFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("team_folder")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> UpdateFolderPolicyError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                            return UpdateFolderPolicyError.accessError(v)
                        case "not_on_team":
                            return UpdateFolderPolicyError.notOnTeam
                        case "team_policy_disallows_member_policy":
                            return UpdateFolderPolicyError.teamPolicyDisallowsMemberPolicy
                        case "disallowed_shared_link_policy":
                            return UpdateFolderPolicyError.disallowedSharedLinkPolicy
                        case "no_permission":
                            return UpdateFolderPolicyError.noPermission
                        case "team_folder":
                            return UpdateFolderPolicyError.teamFolder
                        case "other":
                            return UpdateFolderPolicyError.other
                        default:
                            return UpdateFolderPolicyError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The information about a user member of the shared content.
    open class UserMembershipInfo: Sharing.MembershipInfo {
        /// The account information for the membership user.
        public let user: Sharing.UserInfo
        public init(accessType: Sharing.AccessLevel, user: Sharing.UserInfo, permissions: Array<Sharing.MemberPermission>? = nil, initials: String? = nil, isInherited: Bool = false) {
            self.user = user
            super.init(accessType: accessType, permissions: permissions, initials: initials, isInherited: isInherited)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UserMembershipInfoSerializer().serialize(self)))"
        }
    }
    open class UserMembershipInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UserMembershipInfo) -> JSON {
            let output = [ 
            "access_type": Sharing.AccessLevelSerializer().serialize(value.accessType),
            "user": Sharing.UserInfoSerializer().serialize(value.user),
            "permissions": NullableSerializer(ArraySerializer(Sharing.MemberPermissionSerializer())).serialize(value.permissions),
            "initials": NullableSerializer(Serialization._StringSerializer).serialize(value.initials),
            "is_inherited": Serialization._BoolSerializer.serialize(value.isInherited),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UserMembershipInfo {
            switch json {
                case .dictionary(let dict):
                    let accessType = Sharing.AccessLevelSerializer().deserialize(dict["access_type"] ?? .null)
                    let user = Sharing.UserInfoSerializer().deserialize(dict["user"] ?? .null)
                    let permissions = NullableSerializer(ArraySerializer(Sharing.MemberPermissionSerializer())).deserialize(dict["permissions"] ?? .null)
                    let initials = NullableSerializer(Serialization._StringSerializer).deserialize(dict["initials"] ?? .null)
                    let isInherited = Serialization._BoolSerializer.deserialize(dict["is_inherited"] ?? .number(0))
                    return UserMembershipInfo(accessType: accessType, user: user, permissions: permissions, initials: initials, isInherited: isInherited)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The information about a user member of the shared content with an appended last seen timestamp.
    open class UserFileMembershipInfo: Sharing.UserMembershipInfo {
        /// The UTC timestamp of when the user has last seen the content, if they have.
        public let timeLastSeen: Date?
        /// The platform on which the user has last seen the content, or unknown.
        public let platformType: SeenState.PlatformType?
        public init(accessType: Sharing.AccessLevel, user: Sharing.UserInfo, permissions: Array<Sharing.MemberPermission>? = nil, initials: String? = nil, isInherited: Bool = false, timeLastSeen: Date? = nil, platformType: SeenState.PlatformType? = nil) {
            self.timeLastSeen = timeLastSeen
            self.platformType = platformType
            super.init(accessType: accessType, user: user, permissions: permissions, initials: initials, isInherited: isInherited)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UserFileMembershipInfoSerializer().serialize(self)))"
        }
    }
    open class UserFileMembershipInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UserFileMembershipInfo) -> JSON {
            let output = [ 
            "access_type": Sharing.AccessLevelSerializer().serialize(value.accessType),
            "user": Sharing.UserInfoSerializer().serialize(value.user),
            "permissions": NullableSerializer(ArraySerializer(Sharing.MemberPermissionSerializer())).serialize(value.permissions),
            "initials": NullableSerializer(Serialization._StringSerializer).serialize(value.initials),
            "is_inherited": Serialization._BoolSerializer.serialize(value.isInherited),
            "time_last_seen": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.timeLastSeen),
            "platform_type": NullableSerializer(SeenState.PlatformTypeSerializer()).serialize(value.platformType),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UserFileMembershipInfo {
            switch json {
                case .dictionary(let dict):
                    let accessType = Sharing.AccessLevelSerializer().deserialize(dict["access_type"] ?? .null)
                    let user = Sharing.UserInfoSerializer().deserialize(dict["user"] ?? .null)
                    let permissions = NullableSerializer(ArraySerializer(Sharing.MemberPermissionSerializer())).deserialize(dict["permissions"] ?? .null)
                    let initials = NullableSerializer(Serialization._StringSerializer).deserialize(dict["initials"] ?? .null)
                    let isInherited = Serialization._BoolSerializer.deserialize(dict["is_inherited"] ?? .number(0))
                    let timeLastSeen = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["time_last_seen"] ?? .null)
                    let platformType = NullableSerializer(SeenState.PlatformTypeSerializer()).deserialize(dict["platform_type"] ?? .null)
                    return UserFileMembershipInfo(accessType: accessType, user: user, permissions: permissions, initials: initials, isInherited: isInherited, timeLastSeen: timeLastSeen, platformType: platformType)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Basic information about a user. Use usersAccount and usersAccountBatch to obtain more detailed information.
    open class UserInfo: CustomStringConvertible {
        /// The account ID of the user.
        public let accountId: String
        /// Email address of user.
        public let email: String
        /// The display name of the user.
        public let displayName: String
        /// If the user is in the same team as current user.
        public let sameTeam: Bool
        /// The team member ID of the shared folder member. Only present if sameTeam is true.
        public let teamMemberId: String?
        public init(accountId: String, email: String, displayName: String, sameTeam: Bool, teamMemberId: String? = nil) {
            stringValidator(minLength: 40, maxLength: 40)(accountId)
            self.accountId = accountId
            stringValidator()(email)
            self.email = email
            stringValidator()(displayName)
            self.displayName = displayName
            self.sameTeam = sameTeam
            nullableValidator(stringValidator())(teamMemberId)
            self.teamMemberId = teamMemberId
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UserInfoSerializer().serialize(self)))"
        }
    }
    open class UserInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UserInfo) -> JSON {
            let output = [ 
            "account_id": Serialization._StringSerializer.serialize(value.accountId),
            "email": Serialization._StringSerializer.serialize(value.email),
            "display_name": Serialization._StringSerializer.serialize(value.displayName),
            "same_team": Serialization._BoolSerializer.serialize(value.sameTeam),
            "team_member_id": NullableSerializer(Serialization._StringSerializer).serialize(value.teamMemberId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UserInfo {
            switch json {
                case .dictionary(let dict):
                    let accountId = Serialization._StringSerializer.deserialize(dict["account_id"] ?? .null)
                    let email = Serialization._StringSerializer.deserialize(dict["email"] ?? .null)
                    let displayName = Serialization._StringSerializer.deserialize(dict["display_name"] ?? .null)
                    let sameTeam = Serialization._BoolSerializer.deserialize(dict["same_team"] ?? .null)
                    let teamMemberId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["team_member_id"] ?? .null)
                    return UserInfo(accountId: accountId, email: email, displayName: displayName, sameTeam: sameTeam, teamMemberId: teamMemberId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ViewerInfoPolicy union
    public enum ViewerInfoPolicy: CustomStringConvertible {
        /// Viewer information is available on this file.
        case enabled
        /// Viewer information is disabled on this file.
        case disabled
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ViewerInfoPolicySerializer().serialize(self)))"
        }
    }
    open class ViewerInfoPolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ViewerInfoPolicy) -> JSON {
            switch value {
                case .enabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("enabled")
                    return .dictionary(d)
                case .disabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disabled")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ViewerInfoPolicy {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "enabled":
                            return ViewerInfoPolicy.enabled
                        case "disabled":
                            return ViewerInfoPolicy.disabled
                        case "other":
                            return ViewerInfoPolicy.other
                        default:
                            return ViewerInfoPolicy.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Who can access a shared link. The most open visibility is public_. The default depends on many aspects, such as
    /// team and user preferences and shared folder settings.
    public enum Visibility: CustomStringConvertible {
        /// Anyone who has received the link can access it. No login required.
        case public_
        /// Only members of the same team can access the link. Login is required.
        case teamOnly
        /// A link-specific password is required to access the link. Login is not required.
        case password
        /// Only members of the same team who have the link-specific password can access the link.
        case teamAndPassword
        /// Only members of the shared folder containing the linked file can access the link. Login is required.
        case sharedFolderOnly
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(VisibilitySerializer().serialize(self)))"
        }
    }
    open class VisibilitySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: Visibility) -> JSON {
            switch value {
                case .public_:
                    var d = [String: JSON]()
                    d[".tag"] = .str("public")
                    return .dictionary(d)
                case .teamOnly:
                    var d = [String: JSON]()
                    d[".tag"] = .str("team_only")
                    return .dictionary(d)
                case .password:
                    var d = [String: JSON]()
                    d[".tag"] = .str("password")
                    return .dictionary(d)
                case .teamAndPassword:
                    var d = [String: JSON]()
                    d[".tag"] = .str("team_and_password")
                    return .dictionary(d)
                case .sharedFolderOnly:
                    var d = [String: JSON]()
                    d[".tag"] = .str("shared_folder_only")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> Visibility {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "public":
                            return Visibility.public_
                        case "team_only":
                            return Visibility.teamOnly
                        case "password":
                            return Visibility.password
                        case "team_and_password":
                            return Visibility.teamAndPassword
                        case "shared_folder_only":
                            return Visibility.sharedFolderOnly
                        case "other":
                            return Visibility.other
                        default:
                            return Visibility.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }


    /// Stone Route Objects

    static let addFileMember = Route(
        name: "add_file_member",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.AddFileMemberArgsSerializer(),
        responseSerializer: ArraySerializer(Sharing.FileMemberActionResultSerializer()),
        errorSerializer: Sharing.AddFileMemberErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let addFolderMember = Route(
        name: "add_folder_member",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.AddFolderMemberArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Sharing.AddFolderMemberErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let changeFileMemberAccess = Route(
        name: "change_file_member_access",
        version: 1,
        namespace: "sharing",
        deprecated: true,
        argSerializer: Sharing.ChangeFileMemberAccessArgsSerializer(),
        responseSerializer: Sharing.FileMemberActionResultSerializer(),
        errorSerializer: Sharing.FileMemberActionErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let checkJobStatus = Route(
        name: "check_job_status",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Async.PollArgSerializer(),
        responseSerializer: Sharing.JobStatusSerializer(),
        errorSerializer: Async.PollErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let checkRemoveMemberJobStatus = Route(
        name: "check_remove_member_job_status",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Async.PollArgSerializer(),
        responseSerializer: Sharing.RemoveMemberJobStatusSerializer(),
        errorSerializer: Async.PollErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let checkShareJobStatus = Route(
        name: "check_share_job_status",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Async.PollArgSerializer(),
        responseSerializer: Sharing.ShareFolderJobStatusSerializer(),
        errorSerializer: Async.PollErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let createSharedLink = Route(
        name: "create_shared_link",
        version: 1,
        namespace: "sharing",
        deprecated: true,
        argSerializer: Sharing.CreateSharedLinkArgSerializer(),
        responseSerializer: Sharing.PathLinkMetadataSerializer(),
        errorSerializer: Sharing.CreateSharedLinkErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let createSharedLinkWithSettings = Route(
        name: "create_shared_link_with_settings",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.CreateSharedLinkWithSettingsArgSerializer(),
        responseSerializer: Sharing.SharedLinkMetadataSerializer(),
        errorSerializer: Sharing.CreateSharedLinkWithSettingsErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let getFileMetadata = Route(
        name: "get_file_metadata",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.GetFileMetadataArgSerializer(),
        responseSerializer: Sharing.SharedFileMetadataSerializer(),
        errorSerializer: Sharing.GetFileMetadataErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let getFileMetadataBatch = Route(
        name: "get_file_metadata/batch",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.GetFileMetadataBatchArgSerializer(),
        responseSerializer: ArraySerializer(Sharing.GetFileMetadataBatchResultSerializer()),
        errorSerializer: Sharing.SharingUserErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let getFolderMetadata = Route(
        name: "get_folder_metadata",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.GetMetadataArgsSerializer(),
        responseSerializer: Sharing.SharedFolderMetadataSerializer(),
        errorSerializer: Sharing.SharedFolderAccessErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let getSharedLinkFile = Route(
        name: "get_shared_link_file",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.GetSharedLinkMetadataArgSerializer(),
        responseSerializer: Sharing.SharedLinkMetadataSerializer(),
        errorSerializer: Sharing.GetSharedLinkFileErrorSerializer(),
        attrs: ["host": "content",
                "style": "download"]
    )
    static let getSharedLinkMetadata = Route(
        name: "get_shared_link_metadata",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.GetSharedLinkMetadataArgSerializer(),
        responseSerializer: Sharing.SharedLinkMetadataSerializer(),
        errorSerializer: Sharing.SharedLinkErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let getSharedLinks = Route(
        name: "get_shared_links",
        version: 1,
        namespace: "sharing",
        deprecated: true,
        argSerializer: Sharing.GetSharedLinksArgSerializer(),
        responseSerializer: Sharing.GetSharedLinksResultSerializer(),
        errorSerializer: Sharing.GetSharedLinksErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let listFileMembers = Route(
        name: "list_file_members",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ListFileMembersArgSerializer(),
        responseSerializer: Sharing.SharedFileMembersSerializer(),
        errorSerializer: Sharing.ListFileMembersErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let listFileMembersBatch = Route(
        name: "list_file_members/batch",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ListFileMembersBatchArgSerializer(),
        responseSerializer: ArraySerializer(Sharing.ListFileMembersBatchResultSerializer()),
        errorSerializer: Sharing.SharingUserErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let listFileMembersContinue = Route(
        name: "list_file_members/continue",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ListFileMembersContinueArgSerializer(),
        responseSerializer: Sharing.SharedFileMembersSerializer(),
        errorSerializer: Sharing.ListFileMembersContinueErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let listFolderMembers = Route(
        name: "list_folder_members",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ListFolderMembersArgsSerializer(),
        responseSerializer: Sharing.SharedFolderMembersSerializer(),
        errorSerializer: Sharing.SharedFolderAccessErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let listFolderMembersContinue = Route(
        name: "list_folder_members/continue",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ListFolderMembersContinueArgSerializer(),
        responseSerializer: Sharing.SharedFolderMembersSerializer(),
        errorSerializer: Sharing.ListFolderMembersContinueErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let listFolders = Route(
        name: "list_folders",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ListFoldersArgsSerializer(),
        responseSerializer: Sharing.ListFoldersResultSerializer(),
        errorSerializer: Serialization._VoidSerializer,
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let listFoldersContinue = Route(
        name: "list_folders/continue",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ListFoldersContinueArgSerializer(),
        responseSerializer: Sharing.ListFoldersResultSerializer(),
        errorSerializer: Sharing.ListFoldersContinueErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let listMountableFolders = Route(
        name: "list_mountable_folders",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ListFoldersArgsSerializer(),
        responseSerializer: Sharing.ListFoldersResultSerializer(),
        errorSerializer: Serialization._VoidSerializer,
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let listMountableFoldersContinue = Route(
        name: "list_mountable_folders/continue",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ListFoldersContinueArgSerializer(),
        responseSerializer: Sharing.ListFoldersResultSerializer(),
        errorSerializer: Sharing.ListFoldersContinueErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let listReceivedFiles = Route(
        name: "list_received_files",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ListFilesArgSerializer(),
        responseSerializer: Sharing.ListFilesResultSerializer(),
        errorSerializer: Sharing.SharingUserErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let listReceivedFilesContinue = Route(
        name: "list_received_files/continue",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ListFilesContinueArgSerializer(),
        responseSerializer: Sharing.ListFilesResultSerializer(),
        errorSerializer: Sharing.ListFilesContinueErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let listSharedLinks = Route(
        name: "list_shared_links",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ListSharedLinksArgSerializer(),
        responseSerializer: Sharing.ListSharedLinksResultSerializer(),
        errorSerializer: Sharing.ListSharedLinksErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let modifySharedLinkSettings = Route(
        name: "modify_shared_link_settings",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ModifySharedLinkSettingsArgsSerializer(),
        responseSerializer: Sharing.SharedLinkMetadataSerializer(),
        errorSerializer: Sharing.ModifySharedLinkSettingsErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let mountFolder = Route(
        name: "mount_folder",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.MountFolderArgSerializer(),
        responseSerializer: Sharing.SharedFolderMetadataSerializer(),
        errorSerializer: Sharing.MountFolderErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let relinquishFileMembership = Route(
        name: "relinquish_file_membership",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.RelinquishFileMembershipArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Sharing.RelinquishFileMembershipErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let relinquishFolderMembership = Route(
        name: "relinquish_folder_membership",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.RelinquishFolderMembershipArgSerializer(),
        responseSerializer: Async.LaunchEmptyResultSerializer(),
        errorSerializer: Sharing.RelinquishFolderMembershipErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let removeFileMember = Route(
        name: "remove_file_member",
        version: 1,
        namespace: "sharing",
        deprecated: true,
        argSerializer: Sharing.RemoveFileMemberArgSerializer(),
        responseSerializer: Sharing.FileMemberActionIndividualResultSerializer(),
        errorSerializer: Sharing.RemoveFileMemberErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let removeFileMember2 = Route(
        name: "remove_file_member_2",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.RemoveFileMemberArgSerializer(),
        responseSerializer: Sharing.FileMemberRemoveActionResultSerializer(),
        errorSerializer: Sharing.RemoveFileMemberErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let removeFolderMember = Route(
        name: "remove_folder_member",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.RemoveFolderMemberArgSerializer(),
        responseSerializer: Async.LaunchResultBaseSerializer(),
        errorSerializer: Sharing.RemoveFolderMemberErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let revokeSharedLink = Route(
        name: "revoke_shared_link",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.RevokeSharedLinkArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Sharing.RevokeSharedLinkErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let setAccessInheritance = Route(
        name: "set_access_inheritance",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.SetAccessInheritanceArgSerializer(),
        responseSerializer: Sharing.ShareFolderLaunchSerializer(),
        errorSerializer: Sharing.SetAccessInheritanceErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let shareFolder = Route(
        name: "share_folder",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ShareFolderArgSerializer(),
        responseSerializer: Sharing.ShareFolderLaunchSerializer(),
        errorSerializer: Sharing.ShareFolderErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let transferFolder = Route(
        name: "transfer_folder",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.TransferFolderArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Sharing.TransferFolderErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let unmountFolder = Route(
        name: "unmount_folder",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.UnmountFolderArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Sharing.UnmountFolderErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let unshareFile = Route(
        name: "unshare_file",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.UnshareFileArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Sharing.UnshareFileErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let unshareFolder = Route(
        name: "unshare_folder",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.UnshareFolderArgSerializer(),
        responseSerializer: Async.LaunchEmptyResultSerializer(),
        errorSerializer: Sharing.UnshareFolderErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let updateFileMember = Route(
        name: "update_file_member",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.UpdateFileMemberArgsSerializer(),
        responseSerializer: Sharing.MemberAccessLevelResultSerializer(),
        errorSerializer: Sharing.FileMemberActionErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let updateFolderMember = Route(
        name: "update_folder_member",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.UpdateFolderMemberArgSerializer(),
        responseSerializer: Sharing.MemberAccessLevelResultSerializer(),
        errorSerializer: Sharing.UpdateFolderMemberErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let updateFolderPolicy = Route(
        name: "update_folder_policy",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.UpdateFolderPolicyArgSerializer(),
        responseSerializer: Sharing.SharedFolderMetadataSerializer(),
        errorSerializer: Sharing.UpdateFolderPolicyErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
}
