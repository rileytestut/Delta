///
/// Copyright (c) 2016 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

/// Routes for the sharing namespace
open class SharingRoutes {
    public let client: DropboxTransportClient
    init(client: DropboxTransportClient) {
        self.client = client
    }

    /// Adds specified members to a file.
    ///
    /// - parameter file: File to which to add members.
    /// - parameter members: Members to add. Note that even an email address is given, this may result in a user being
    /// directy added to the membership if that email is the user's main account email.
    /// - parameter customMessage: Message to send to added members in their invitation.
    /// - parameter quiet: Whether added members should be notified via device notifications of their invitation.
    /// - parameter accessLevel: AccessLevel union object, describing what access level we want to give new members.
    /// - parameter addMessageAsComment: If the custom message should be added as a comment on the file.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Array<Sharing.FileMemberActionResult>`
    /// object on success or a `Sharing.AddFileMemberError` object on failure.
    @discardableResult open func addFileMember(file: String, members: Array<Sharing.MemberSelector>, customMessage: String? = nil, quiet: Bool = false, accessLevel: Sharing.AccessLevel = .viewer, addMessageAsComment: Bool = false) -> RpcRequest<ArraySerializer<Sharing.FileMemberActionResultSerializer>, Sharing.AddFileMemberErrorSerializer> {
        let route = Sharing.addFileMember
        let serverArgs = Sharing.AddFileMemberArgs(file: file, members: members, customMessage: customMessage, quiet: quiet, accessLevel: accessLevel, addMessageAsComment: addMessageAsComment)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Allows an owner or editor (if the ACL update policy allows) of a shared folder to add another member. For the
    /// new member to get access to all the functionality for this folder, you will need to call mountFolder on their
    /// behalf.
    ///
    /// - parameter sharedFolderId: The ID for the shared folder.
    /// - parameter members: The intended list of members to add.  Added members will receive invites to join the shared
    /// folder.
    /// - parameter quiet: Whether added members should be notified via email and device notifications of their invite.
    /// - parameter customMessage: Optional message to display to added members in their invitation.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Sharing.AddFolderMemberError` object on failure.
    @discardableResult open func addFolderMember(sharedFolderId: String, members: Array<Sharing.AddMember>, quiet: Bool = false, customMessage: String? = nil) -> RpcRequest<VoidSerializer, Sharing.AddFolderMemberErrorSerializer> {
        let route = Sharing.addFolderMember
        let serverArgs = Sharing.AddFolderMemberArg(sharedFolderId: sharedFolderId, members: members, quiet: quiet, customMessage: customMessage)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Identical to update_file_member but with less information returned.
    ///
    /// - parameter file: File for which we are changing a member's access.
    /// - parameter member: The member whose access we are changing.
    /// - parameter accessLevel: The new access level for the member.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Sharing.FileMemberActionResult` object on
    /// success or a `Sharing.FileMemberActionError` object on failure.
    @available(*, unavailable, message:"changeFileMemberAccess is deprecated. Use updateFileMember.")
    @discardableResult open func changeFileMemberAccess(file: String, member: Sharing.MemberSelector, accessLevel: Sharing.AccessLevel) -> RpcRequest<Sharing.FileMemberActionResultSerializer, Sharing.FileMemberActionErrorSerializer> {
        let route = Sharing.changeFileMemberAccess
        let serverArgs = Sharing.ChangeFileMemberAccessArgs(file: file, member: member, accessLevel: accessLevel)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Returns the status of an asynchronous job.
    ///
    /// - parameter asyncJobId: Id of the asynchronous job. This is the value of a response returned from the method
    /// that launched the job.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Sharing.JobStatus` object on success or a
    /// `Async.PollError` object on failure.
    @discardableResult open func checkJobStatus(asyncJobId: String) -> RpcRequest<Sharing.JobStatusSerializer, Async.PollErrorSerializer> {
        let route = Sharing.checkJobStatus
        let serverArgs = Async.PollArg(asyncJobId: asyncJobId)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Returns the status of an asynchronous job for sharing a folder.
    ///
    /// - parameter asyncJobId: Id of the asynchronous job. This is the value of a response returned from the method
    /// that launched the job.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Sharing.RemoveMemberJobStatus` object on
    /// success or a `Async.PollError` object on failure.
    @discardableResult open func checkRemoveMemberJobStatus(asyncJobId: String) -> RpcRequest<Sharing.RemoveMemberJobStatusSerializer, Async.PollErrorSerializer> {
        let route = Sharing.checkRemoveMemberJobStatus
        let serverArgs = Async.PollArg(asyncJobId: asyncJobId)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Returns the status of an asynchronous job for sharing a folder.
    ///
    /// - parameter asyncJobId: Id of the asynchronous job. This is the value of a response returned from the method
    /// that launched the job.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Sharing.ShareFolderJobStatus` object on
    /// success or a `Async.PollError` object on failure.
    @discardableResult open func checkShareJobStatus(asyncJobId: String) -> RpcRequest<Sharing.ShareFolderJobStatusSerializer, Async.PollErrorSerializer> {
        let route = Sharing.checkShareJobStatus
        let serverArgs = Async.PollArg(asyncJobId: asyncJobId)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Create a shared link. If a shared link already exists for the given path, that link is returned. Note that in
    /// the returned PathLinkMetadata, the url in PathLinkMetadata field is the shortened URL if shortUrl in
    /// CreateSharedLinkArg argument is set to true. Previously, it was technically possible to break a shared link by
    /// moving or renaming the corresponding file or folder. In the future, this will no longer be the case, so your app
    /// shouldn't rely on this behavior. Instead, if your app needs to revoke a shared link, use revokeSharedLink.
    ///
    /// - parameter path: The path to share.
    /// - parameter shortUrl: Whether to return a shortened URL.
    /// - parameter pendingUpload: If it's okay to share a path that does not yet exist, set this to either file in
    /// PendingUploadMode or folder in PendingUploadMode to indicate whether to assume it's a file or folder.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Sharing.PathLinkMetadata` object on
    /// success or a `Sharing.CreateSharedLinkError` object on failure.
    @available(*, unavailable, message:"createSharedLink is deprecated. Use createSharedLinkWithSettings.")
    @discardableResult open func createSharedLink(path: String, shortUrl: Bool = false, pendingUpload: Sharing.PendingUploadMode? = nil) -> RpcRequest<Sharing.PathLinkMetadataSerializer, Sharing.CreateSharedLinkErrorSerializer> {
        let route = Sharing.createSharedLink
        let serverArgs = Sharing.CreateSharedLinkArg(path: path, shortUrl: shortUrl, pendingUpload: pendingUpload)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Create a shared link with custom settings. If no settings are given then the default visibility is public_ in
    /// RequestedVisibility (The resolved visibility, though, may depend on other aspects such as team and shared folder
    /// settings).
    ///
    /// - parameter path: The path to be shared by the shared link.
    /// - parameter settings: The requested settings for the newly created shared link.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Sharing.SharedLinkMetadata` object on
    /// success or a `Sharing.CreateSharedLinkWithSettingsError` object on failure.
    @discardableResult open func createSharedLinkWithSettings(path: String, settings: Sharing.SharedLinkSettings? = nil) -> RpcRequest<Sharing.SharedLinkMetadataSerializer, Sharing.CreateSharedLinkWithSettingsErrorSerializer> {
        let route = Sharing.createSharedLinkWithSettings
        let serverArgs = Sharing.CreateSharedLinkWithSettingsArg(path: path, settings: settings)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Returns shared file metadata.
    ///
    /// - parameter file: The file to query.
    /// - parameter actions: A list of `FileAction`s corresponding to `FilePermission`s that should appear in the
    /// response's permissions in SharedFileMetadata field describing the actions the  authenticated user can perform on
    /// the file.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Sharing.SharedFileMetadata` object on
    /// success or a `Sharing.GetFileMetadataError` object on failure.
    @discardableResult open func getFileMetadata(file: String, actions: Array<Sharing.FileAction>? = nil) -> RpcRequest<Sharing.SharedFileMetadataSerializer, Sharing.GetFileMetadataErrorSerializer> {
        let route = Sharing.getFileMetadata
        let serverArgs = Sharing.GetFileMetadataArg(file: file, actions: actions)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Returns shared file metadata.
    ///
    /// - parameter files: The files to query.
    /// - parameter actions: A list of `FileAction`s corresponding to `FilePermission`s that should appear in the
    /// response's permissions in SharedFileMetadata field describing the actions the  authenticated user can perform on
    /// the file.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Array<Sharing.GetFileMetadataBatchResult>`
    /// object on success or a `Sharing.SharingUserError` object on failure.
    @discardableResult open func getFileMetadataBatch(files: Array<String>, actions: Array<Sharing.FileAction>? = nil) -> RpcRequest<ArraySerializer<Sharing.GetFileMetadataBatchResultSerializer>, Sharing.SharingUserErrorSerializer> {
        let route = Sharing.getFileMetadataBatch
        let serverArgs = Sharing.GetFileMetadataBatchArg(files: files, actions: actions)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Returns shared folder metadata by its folder ID.
    ///
    /// - parameter sharedFolderId: The ID for the shared folder.
    /// - parameter actions: A list of `FolderAction`s corresponding to `FolderPermission`s that should appear in the
    /// response's permissions in SharedFolderMetadata field describing the actions the  authenticated user can perform
    /// on the folder.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Sharing.SharedFolderMetadata` object on
    /// success or a `Sharing.SharedFolderAccessError` object on failure.
    @discardableResult open func getFolderMetadata(sharedFolderId: String, actions: Array<Sharing.FolderAction>? = nil) -> RpcRequest<Sharing.SharedFolderMetadataSerializer, Sharing.SharedFolderAccessErrorSerializer> {
        let route = Sharing.getFolderMetadata
        let serverArgs = Sharing.GetMetadataArgs(sharedFolderId: sharedFolderId, actions: actions)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Download the shared link's file from a user's Dropbox.
    ///
    /// - parameter url: URL of the shared link.
    /// - parameter path: If the shared link is to a folder, this parameter can be used to retrieve the metadata for a
    /// specific file or sub-folder in this folder. A relative path should be used.
    /// - parameter linkPassword: If the shared link has a password, this parameter can be used.
    /// - parameter overwrite: A boolean to set behavior in the event of a naming conflict. `True` will overwrite
    /// conflicting file at destination. `False` will take no action (but if left unhandled in destination closure, an
    /// NSError will be thrown).
    /// - parameter destination: A closure used to compute the destination, given the temporary file location and the
    /// response.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Sharing.SharedLinkMetadata` object on
    /// success or a `Sharing.GetSharedLinkFileError` object on failure.
    @discardableResult open func getSharedLinkFile(url: String, path: String? = nil, linkPassword: String? = nil, overwrite: Bool = false, destination: @escaping (URL, HTTPURLResponse) -> URL) -> DownloadRequestFile<Sharing.SharedLinkMetadataSerializer, Sharing.GetSharedLinkFileErrorSerializer> {
        let route = Sharing.getSharedLinkFile
        let serverArgs = Sharing.GetSharedLinkMetadataArg(url: url, path: path, linkPassword: linkPassword)
        return client.request(route, serverArgs: serverArgs, overwrite: overwrite, destination: destination)
    }

    /// Download the shared link's file from a user's Dropbox.
    ///
    /// - parameter url: URL of the shared link.
    /// - parameter path: If the shared link is to a folder, this parameter can be used to retrieve the metadata for a
    /// specific file or sub-folder in this folder. A relative path should be used.
    /// - parameter linkPassword: If the shared link has a password, this parameter can be used.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Sharing.SharedLinkMetadata` object on
    /// success or a `Sharing.GetSharedLinkFileError` object on failure.
    @discardableResult open func getSharedLinkFile(url: String, path: String? = nil, linkPassword: String? = nil) -> DownloadRequestMemory<Sharing.SharedLinkMetadataSerializer, Sharing.GetSharedLinkFileErrorSerializer> {
        let route = Sharing.getSharedLinkFile
        let serverArgs = Sharing.GetSharedLinkMetadataArg(url: url, path: path, linkPassword: linkPassword)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Get the shared link's metadata.
    ///
    /// - parameter url: URL of the shared link.
    /// - parameter path: If the shared link is to a folder, this parameter can be used to retrieve the metadata for a
    /// specific file or sub-folder in this folder. A relative path should be used.
    /// - parameter linkPassword: If the shared link has a password, this parameter can be used.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Sharing.SharedLinkMetadata` object on
    /// success or a `Sharing.SharedLinkError` object on failure.
    @discardableResult open func getSharedLinkMetadata(url: String, path: String? = nil, linkPassword: String? = nil) -> RpcRequest<Sharing.SharedLinkMetadataSerializer, Sharing.SharedLinkErrorSerializer> {
        let route = Sharing.getSharedLinkMetadata
        let serverArgs = Sharing.GetSharedLinkMetadataArg(url: url, path: path, linkPassword: linkPassword)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Returns a list of LinkMetadata objects for this user, including collection links. If no path is given, returns a
    /// list of all shared links for the current user, including collection links, up to a maximum of 1000 links. If a
    /// non-empty path is given, returns a list of all shared links that allow access to the given path.  Collection
    /// links are never returned in this case. Note that the url field in the response is never the shortened URL.
    ///
    /// - parameter path: See getSharedLinks description.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Sharing.GetSharedLinksResult` object on
    /// success or a `Sharing.GetSharedLinksError` object on failure.
    @available(*, unavailable, message:"getSharedLinks is deprecated. Use listSharedLinks.")
    @discardableResult open func getSharedLinks(path: String? = nil) -> RpcRequest<Sharing.GetSharedLinksResultSerializer, Sharing.GetSharedLinksErrorSerializer> {
        let route = Sharing.getSharedLinks
        let serverArgs = Sharing.GetSharedLinksArg(path: path)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Use to obtain the members who have been invited to a file, both inherited and uninherited members.
    ///
    /// - parameter file: The file for which you want to see members.
    /// - parameter actions: The actions for which to return permissions on a member.
    /// - parameter includeInherited: Whether to include members who only have access from a parent shared folder.
    /// - parameter limit: Number of members to return max per query. Defaults to 100 if no limit is specified.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Sharing.SharedFileMembers` object on
    /// success or a `Sharing.ListFileMembersError` object on failure.
    @discardableResult open func listFileMembers(file: String, actions: Array<Sharing.MemberAction>? = nil, includeInherited: Bool = true, limit: UInt32 = 100) -> RpcRequest<Sharing.SharedFileMembersSerializer, Sharing.ListFileMembersErrorSerializer> {
        let route = Sharing.listFileMembers
        let serverArgs = Sharing.ListFileMembersArg(file: file, actions: actions, includeInherited: includeInherited, limit: limit)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Get members of multiple files at once. The arguments to this route are more limited, and the limit on query
    /// result size per file is more strict. To customize the results more, use the individual file endpoint. Inherited
    /// users and groups are not included in the result, and permissions are not returned for this endpoint.
    ///
    /// - parameter files: Files for which to return members.
    /// - parameter limit: Number of members to return max per query. Defaults to 10 if no limit is specified.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Array<Sharing.ListFileMembersBatchResult>`
    /// object on success or a `Sharing.SharingUserError` object on failure.
    @discardableResult open func listFileMembersBatch(files: Array<String>, limit: UInt32 = 10) -> RpcRequest<ArraySerializer<Sharing.ListFileMembersBatchResultSerializer>, Sharing.SharingUserErrorSerializer> {
        let route = Sharing.listFileMembersBatch
        let serverArgs = Sharing.ListFileMembersBatchArg(files: files, limit: limit)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Once a cursor has been retrieved from listFileMembers or listFileMembersBatch, use this to paginate through all
    /// shared file members.
    ///
    /// - parameter cursor: The cursor returned by your last call to listFileMembers, listFileMembersContinue, or
    /// listFileMembersBatch.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Sharing.SharedFileMembers` object on
    /// success or a `Sharing.ListFileMembersContinueError` object on failure.
    @discardableResult open func listFileMembersContinue(cursor: String) -> RpcRequest<Sharing.SharedFileMembersSerializer, Sharing.ListFileMembersContinueErrorSerializer> {
        let route = Sharing.listFileMembersContinue
        let serverArgs = Sharing.ListFileMembersContinueArg(cursor: cursor)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Returns shared folder membership by its folder ID.
    ///
    /// - parameter sharedFolderId: The ID for the shared folder.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Sharing.SharedFolderMembers` object on
    /// success or a `Sharing.SharedFolderAccessError` object on failure.
    @discardableResult open func listFolderMembers(sharedFolderId: String, actions: Array<Sharing.MemberAction>? = nil, limit: UInt32 = 1000) -> RpcRequest<Sharing.SharedFolderMembersSerializer, Sharing.SharedFolderAccessErrorSerializer> {
        let route = Sharing.listFolderMembers
        let serverArgs = Sharing.ListFolderMembersArgs(sharedFolderId: sharedFolderId, actions: actions, limit: limit)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Once a cursor has been retrieved from listFolderMembers, use this to paginate through all shared folder members.
    ///
    /// - parameter cursor: The cursor returned by your last call to listFolderMembers or listFolderMembersContinue.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Sharing.SharedFolderMembers` object on
    /// success or a `Sharing.ListFolderMembersContinueError` object on failure.
    @discardableResult open func listFolderMembersContinue(cursor: String) -> RpcRequest<Sharing.SharedFolderMembersSerializer, Sharing.ListFolderMembersContinueErrorSerializer> {
        let route = Sharing.listFolderMembersContinue
        let serverArgs = Sharing.ListFolderMembersContinueArg(cursor: cursor)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Return the list of all shared folders the current user has access to.
    ///
    /// - parameter limit: The maximum number of results to return per request.
    /// - parameter actions: A list of `FolderAction`s corresponding to `FolderPermission`s that should appear in the
    /// response's permissions in SharedFolderMetadata field describing the actions the  authenticated user can perform
    /// on the folder.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Sharing.ListFoldersResult` object on
    /// success or a `Void` object on failure.
    @discardableResult open func listFolders(limit: UInt32 = 1000, actions: Array<Sharing.FolderAction>? = nil) -> RpcRequest<Sharing.ListFoldersResultSerializer, VoidSerializer> {
        let route = Sharing.listFolders
        let serverArgs = Sharing.ListFoldersArgs(limit: limit, actions: actions)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Once a cursor has been retrieved from listFolders, use this to paginate through all shared folders. The cursor
    /// must come from a previous call to listFolders or listFoldersContinue.
    ///
    /// - parameter cursor: The cursor returned by the previous API call specified in the endpoint description.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Sharing.ListFoldersResult` object on
    /// success or a `Sharing.ListFoldersContinueError` object on failure.
    @discardableResult open func listFoldersContinue(cursor: String) -> RpcRequest<Sharing.ListFoldersResultSerializer, Sharing.ListFoldersContinueErrorSerializer> {
        let route = Sharing.listFoldersContinue
        let serverArgs = Sharing.ListFoldersContinueArg(cursor: cursor)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Return the list of all shared folders the current user can mount or unmount.
    ///
    /// - parameter limit: The maximum number of results to return per request.
    /// - parameter actions: A list of `FolderAction`s corresponding to `FolderPermission`s that should appear in the
    /// response's permissions in SharedFolderMetadata field describing the actions the  authenticated user can perform
    /// on the folder.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Sharing.ListFoldersResult` object on
    /// success or a `Void` object on failure.
    @discardableResult open func listMountableFolders(limit: UInt32 = 1000, actions: Array<Sharing.FolderAction>? = nil) -> RpcRequest<Sharing.ListFoldersResultSerializer, VoidSerializer> {
        let route = Sharing.listMountableFolders
        let serverArgs = Sharing.ListFoldersArgs(limit: limit, actions: actions)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Once a cursor has been retrieved from listMountableFolders, use this to paginate through all mountable shared
    /// folders. The cursor must come from a previous call to listMountableFolders or listMountableFoldersContinue.
    ///
    /// - parameter cursor: The cursor returned by the previous API call specified in the endpoint description.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Sharing.ListFoldersResult` object on
    /// success or a `Sharing.ListFoldersContinueError` object on failure.
    @discardableResult open func listMountableFoldersContinue(cursor: String) -> RpcRequest<Sharing.ListFoldersResultSerializer, Sharing.ListFoldersContinueErrorSerializer> {
        let route = Sharing.listMountableFoldersContinue
        let serverArgs = Sharing.ListFoldersContinueArg(cursor: cursor)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Returns a list of all files shared with current user.  Does not include files the user has received via shared
    /// folders, and does  not include unclaimed invitations.
    ///
    /// - parameter limit: Number of files to return max per query. Defaults to 100 if no limit is specified.
    /// - parameter actions: A list of `FileAction`s corresponding to `FilePermission`s that should appear in the
    /// response's permissions in SharedFileMetadata field describing the actions the  authenticated user can perform on
    /// the file.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Sharing.ListFilesResult` object on success
    /// or a `Sharing.SharingUserError` object on failure.
    @discardableResult open func listReceivedFiles(limit: UInt32 = 100, actions: Array<Sharing.FileAction>? = nil) -> RpcRequest<Sharing.ListFilesResultSerializer, Sharing.SharingUserErrorSerializer> {
        let route = Sharing.listReceivedFiles
        let serverArgs = Sharing.ListFilesArg(limit: limit, actions: actions)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Get more results with a cursor from listReceivedFiles.
    ///
    /// - parameter cursor: Cursor in cursor in ListFilesResult.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Sharing.ListFilesResult` object on success
    /// or a `Sharing.ListFilesContinueError` object on failure.
    @discardableResult open func listReceivedFilesContinue(cursor: String) -> RpcRequest<Sharing.ListFilesResultSerializer, Sharing.ListFilesContinueErrorSerializer> {
        let route = Sharing.listReceivedFilesContinue
        let serverArgs = Sharing.ListFilesContinueArg(cursor: cursor)
        return client.request(route, serverArgs: serverArgs)
    }

    /// List shared links of this user. If no path is given, returns a list of all shared links for the current user. If
    /// a non-empty path is given, returns a list of all shared links that allow access to the given path - direct links
    /// to the given path and links to parent folders of the given path. Links to parent folders can be suppressed by
    /// setting direct_only to true.
    ///
    /// - parameter path: See listSharedLinks description.
    /// - parameter cursor: The cursor returned by your last call to listSharedLinks.
    /// - parameter directOnly: See listSharedLinks description.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Sharing.ListSharedLinksResult` object on
    /// success or a `Sharing.ListSharedLinksError` object on failure.
    @discardableResult open func listSharedLinks(path: String? = nil, cursor: String? = nil, directOnly: Bool? = nil) -> RpcRequest<Sharing.ListSharedLinksResultSerializer, Sharing.ListSharedLinksErrorSerializer> {
        let route = Sharing.listSharedLinks
        let serverArgs = Sharing.ListSharedLinksArg(path: path, cursor: cursor, directOnly: directOnly)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Modify the shared link's settings. If the requested visibility conflict with the shared links policy of the team
    /// or the shared folder (in case the linked file is part of a shared folder) then the resolvedVisibility in
    /// LinkPermissions of the returned SharedLinkMetadata will reflect the actual visibility of the shared link and the
    /// requestedVisibility in LinkPermissions will reflect the requested visibility.
    ///
    /// - parameter url: URL of the shared link to change its settings.
    /// - parameter settings: Set of settings for the shared link.
    /// - parameter removeExpiration: If set to true, removes the expiration of the shared link.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Sharing.SharedLinkMetadata` object on
    /// success or a `Sharing.ModifySharedLinkSettingsError` object on failure.
    @discardableResult open func modifySharedLinkSettings(url: String, settings: Sharing.SharedLinkSettings, removeExpiration: Bool = false) -> RpcRequest<Sharing.SharedLinkMetadataSerializer, Sharing.ModifySharedLinkSettingsErrorSerializer> {
        let route = Sharing.modifySharedLinkSettings
        let serverArgs = Sharing.ModifySharedLinkSettingsArgs(url: url, settings: settings, removeExpiration: removeExpiration)
        return client.request(route, serverArgs: serverArgs)
    }

    /// The current user mounts the designated folder. Mount a shared folder for a user after they have been added as a
    /// member. Once mounted, the shared folder will appear in their Dropbox.
    ///
    /// - parameter sharedFolderId: The ID of the shared folder to mount.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Sharing.SharedFolderMetadata` object on
    /// success or a `Sharing.MountFolderError` object on failure.
    @discardableResult open func mountFolder(sharedFolderId: String) -> RpcRequest<Sharing.SharedFolderMetadataSerializer, Sharing.MountFolderErrorSerializer> {
        let route = Sharing.mountFolder
        let serverArgs = Sharing.MountFolderArg(sharedFolderId: sharedFolderId)
        return client.request(route, serverArgs: serverArgs)
    }

    /// The current user relinquishes their membership in the designated file. Note that the current user may still have
    /// inherited access to this file through the parent folder.
    ///
    /// - parameter file: The path or id for the file.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Sharing.RelinquishFileMembershipError` object on failure.
    @discardableResult open func relinquishFileMembership(file: String) -> RpcRequest<VoidSerializer, Sharing.RelinquishFileMembershipErrorSerializer> {
        let route = Sharing.relinquishFileMembership
        let serverArgs = Sharing.RelinquishFileMembershipArg(file: file)
        return client.request(route, serverArgs: serverArgs)
    }

    /// The current user relinquishes their membership in the designated shared folder and will no longer have access to
    /// the folder.  A folder owner cannot relinquish membership in their own folder. This will run synchronously if
    /// leave_a_copy is false, and asynchronously if leave_a_copy is true.
    ///
    /// - parameter sharedFolderId: The ID for the shared folder.
    /// - parameter leaveACopy: Keep a copy of the folder's contents upon relinquishing membership.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Async.LaunchEmptyResult` object on success
    /// or a `Sharing.RelinquishFolderMembershipError` object on failure.
    @discardableResult open func relinquishFolderMembership(sharedFolderId: String, leaveACopy: Bool = false) -> RpcRequest<Async.LaunchEmptyResultSerializer, Sharing.RelinquishFolderMembershipErrorSerializer> {
        let route = Sharing.relinquishFolderMembership
        let serverArgs = Sharing.RelinquishFolderMembershipArg(sharedFolderId: sharedFolderId, leaveACopy: leaveACopy)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Identical to remove_file_member_2 but with less information returned.
    ///
    /// - parameter file: File from which to remove members.
    /// - parameter member: Member to remove from this file. Note that even if an email is specified, it may result in
    /// the removal of a user (not an invitee) if the user's main account corresponds to that email address.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Sharing.FileMemberActionIndividualResult`
    /// object on success or a `Sharing.RemoveFileMemberError` object on failure.
    @available(*, unavailable, message:"removeFileMember is deprecated. Use removeFileMember2.")
    @discardableResult open func removeFileMember(file: String, member: Sharing.MemberSelector) -> RpcRequest<Sharing.FileMemberActionIndividualResultSerializer, Sharing.RemoveFileMemberErrorSerializer> {
        let route = Sharing.removeFileMember
        let serverArgs = Sharing.RemoveFileMemberArg(file: file, member: member)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Removes a specified member from the file.
    ///
    /// - parameter file: File from which to remove members.
    /// - parameter member: Member to remove from this file. Note that even if an email is specified, it may result in
    /// the removal of a user (not an invitee) if the user's main account corresponds to that email address.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Sharing.FileMemberRemoveActionResult`
    /// object on success or a `Sharing.RemoveFileMemberError` object on failure.
    @discardableResult open func removeFileMember2(file: String, member: Sharing.MemberSelector) -> RpcRequest<Sharing.FileMemberRemoveActionResultSerializer, Sharing.RemoveFileMemberErrorSerializer> {
        let route = Sharing.removeFileMember2
        let serverArgs = Sharing.RemoveFileMemberArg(file: file, member: member)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Allows an owner or editor (if the ACL update policy allows) of a shared folder to remove another member.
    ///
    /// - parameter sharedFolderId: The ID for the shared folder.
    /// - parameter member: The member to remove from the folder.
    /// - parameter leaveACopy: If true, the removed user will keep their copy of the folder after it's unshared,
    /// assuming it was mounted. Otherwise, it will be removed from their Dropbox. Also, this must be set to false when
    /// kicking a group.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Async.LaunchResultBase` object on success
    /// or a `Sharing.RemoveFolderMemberError` object on failure.
    @discardableResult open func removeFolderMember(sharedFolderId: String, member: Sharing.MemberSelector, leaveACopy: Bool) -> RpcRequest<Async.LaunchResultBaseSerializer, Sharing.RemoveFolderMemberErrorSerializer> {
        let route = Sharing.removeFolderMember
        let serverArgs = Sharing.RemoveFolderMemberArg(sharedFolderId: sharedFolderId, member: member, leaveACopy: leaveACopy)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Revoke a shared link. Note that even after revoking a shared link to a file, the file may be accessible if there
    /// are shared links leading to any of the file parent folders. To list all shared links that enable access to a
    /// specific file, you can use the listSharedLinks with the file as the path in ListSharedLinksArg argument.
    ///
    /// - parameter url: URL of the shared link.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Sharing.RevokeSharedLinkError` object on failure.
    @discardableResult open func revokeSharedLink(url: String) -> RpcRequest<VoidSerializer, Sharing.RevokeSharedLinkErrorSerializer> {
        let route = Sharing.revokeSharedLink
        let serverArgs = Sharing.RevokeSharedLinkArg(url: url)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Change the inheritance policy of an existing Shared Folder. Only permitted for shared folders in a shared team
    /// root. If a asyncJobId in ShareFolderLaunch is returned, you'll need to call checkShareJobStatus until the action
    /// completes to get the metadata for the folder.
    ///
    /// - parameter accessInheritance: The access inheritance settings for the folder.
    /// - parameter sharedFolderId: The ID for the shared folder.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Sharing.ShareFolderLaunch` object on
    /// success or a `Sharing.SetAccessInheritanceError` object on failure.
    @discardableResult open func setAccessInheritance(sharedFolderId: String, accessInheritance: Sharing.AccessInheritance = .inherit) -> RpcRequest<Sharing.ShareFolderLaunchSerializer, Sharing.SetAccessInheritanceErrorSerializer> {
        let route = Sharing.setAccessInheritance
        let serverArgs = Sharing.SetAccessInheritanceArg(sharedFolderId: sharedFolderId, accessInheritance: accessInheritance)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Share a folder with collaborators. Most sharing will be completed synchronously. Large folders will be completed
    /// asynchronously. To make testing the async case repeatable, set `ShareFolderArg.force_async`. If a asyncJobId in
    /// ShareFolderLaunch is returned, you'll need to call checkShareJobStatus until the action completes to get the
    /// metadata for the folder.
    ///
    /// - parameter actions: A list of `FolderAction`s corresponding to `FolderPermission`s that should appear in the
    /// response's permissions in SharedFolderMetadata field describing the actions the  authenticated user can perform
    /// on the folder.
    /// - parameter linkSettings: Settings on the link for this folder.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Sharing.ShareFolderLaunch` object on
    /// success or a `Sharing.ShareFolderError` object on failure.
    @discardableResult open func shareFolder(path: String, aclUpdatePolicy: Sharing.AclUpdatePolicy? = nil, forceAsync: Bool = false, memberPolicy: Sharing.MemberPolicy? = nil, sharedLinkPolicy: Sharing.SharedLinkPolicy? = nil, viewerInfoPolicy: Sharing.ViewerInfoPolicy? = nil, accessInheritance: Sharing.AccessInheritance = .inherit, actions: Array<Sharing.FolderAction>? = nil, linkSettings: Sharing.LinkSettings? = nil) -> RpcRequest<Sharing.ShareFolderLaunchSerializer, Sharing.ShareFolderErrorSerializer> {
        let route = Sharing.shareFolder
        let serverArgs = Sharing.ShareFolderArg(path: path, aclUpdatePolicy: aclUpdatePolicy, forceAsync: forceAsync, memberPolicy: memberPolicy, sharedLinkPolicy: sharedLinkPolicy, viewerInfoPolicy: viewerInfoPolicy, accessInheritance: accessInheritance, actions: actions, linkSettings: linkSettings)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Transfer ownership of a shared folder to a member of the shared folder. User must have owner in AccessLevel
    /// access to the shared folder to perform a transfer.
    ///
    /// - parameter sharedFolderId: The ID for the shared folder.
    /// - parameter toDropboxId: A account or team member ID to transfer ownership to.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Sharing.TransferFolderError` object on failure.
    @discardableResult open func transferFolder(sharedFolderId: String, toDropboxId: String) -> RpcRequest<VoidSerializer, Sharing.TransferFolderErrorSerializer> {
        let route = Sharing.transferFolder
        let serverArgs = Sharing.TransferFolderArg(sharedFolderId: sharedFolderId, toDropboxId: toDropboxId)
        return client.request(route, serverArgs: serverArgs)
    }

    /// The current user unmounts the designated folder. They can re-mount the folder at a later time using mountFolder.
    ///
    /// - parameter sharedFolderId: The ID for the shared folder.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Sharing.UnmountFolderError` object on failure.
    @discardableResult open func unmountFolder(sharedFolderId: String) -> RpcRequest<VoidSerializer, Sharing.UnmountFolderErrorSerializer> {
        let route = Sharing.unmountFolder
        let serverArgs = Sharing.UnmountFolderArg(sharedFolderId: sharedFolderId)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Remove all members from this file. Does not remove inherited members.
    ///
    /// - parameter file: The file to unshare.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Sharing.UnshareFileError` object on failure.
    @discardableResult open func unshareFile(file: String) -> RpcRequest<VoidSerializer, Sharing.UnshareFileErrorSerializer> {
        let route = Sharing.unshareFile
        let serverArgs = Sharing.UnshareFileArg(file: file)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Allows a shared folder owner to unshare the folder. You'll need to call checkJobStatus to determine if the
    /// action has completed successfully.
    ///
    /// - parameter sharedFolderId: The ID for the shared folder.
    /// - parameter leaveACopy: If true, members of this shared folder will get a copy of this folder after it's
    /// unshared. Otherwise, it will be removed from their Dropbox. The current user, who is an owner, will always
    /// retain their copy.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Async.LaunchEmptyResult` object on success
    /// or a `Sharing.UnshareFolderError` object on failure.
    @discardableResult open func unshareFolder(sharedFolderId: String, leaveACopy: Bool = false) -> RpcRequest<Async.LaunchEmptyResultSerializer, Sharing.UnshareFolderErrorSerializer> {
        let route = Sharing.unshareFolder
        let serverArgs = Sharing.UnshareFolderArg(sharedFolderId: sharedFolderId, leaveACopy: leaveACopy)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Changes a member's access on a shared file.
    ///
    ///
    ///  - returns: Through the response callback, the caller will receive a `Sharing.MemberAccessLevelResult` object on
    /// success or a `Sharing.FileMemberActionError` object on failure.
    @discardableResult open func updateFileMember(file: String, member: Sharing.MemberSelector, accessLevel: Sharing.AccessLevel) -> RpcRequest<Sharing.MemberAccessLevelResultSerializer, Sharing.FileMemberActionErrorSerializer> {
        let route = Sharing.updateFileMember
        let serverArgs = Sharing.UpdateFileMemberArgs(file: file, member: member, accessLevel: accessLevel)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Allows an owner or editor of a shared folder to update another member's permissions.
    ///
    /// - parameter sharedFolderId: The ID for the shared folder.
    /// - parameter member: The member of the shared folder to update.  Only the dropboxId in MemberSelector may be set
    /// at this time.
    /// - parameter accessLevel: The new access level for member. owner in AccessLevel is disallowed.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Sharing.MemberAccessLevelResult` object on
    /// success or a `Sharing.UpdateFolderMemberError` object on failure.
    @discardableResult open func updateFolderMember(sharedFolderId: String, member: Sharing.MemberSelector, accessLevel: Sharing.AccessLevel) -> RpcRequest<Sharing.MemberAccessLevelResultSerializer, Sharing.UpdateFolderMemberErrorSerializer> {
        let route = Sharing.updateFolderMember
        let serverArgs = Sharing.UpdateFolderMemberArg(sharedFolderId: sharedFolderId, member: member, accessLevel: accessLevel)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Update the sharing policies for a shared folder. User must have owner in AccessLevel access to the shared folder
    /// to update its policies.
    ///
    /// - parameter sharedFolderId: The ID for the shared folder.
    /// - parameter memberPolicy: Who can be a member of this shared folder. Only applicable if the current user is on a
    /// team.
    /// - parameter aclUpdatePolicy: Who can add and remove members of this shared folder.
    /// - parameter viewerInfoPolicy: Who can enable/disable viewer info for this shared folder.
    /// - parameter sharedLinkPolicy: The policy to apply to shared links created for content inside this shared folder.
    /// The current user must be on a team to set this policy to members in SharedLinkPolicy.
    /// - parameter linkSettings: Settings on the link for this folder.
    /// - parameter actions: A list of `FolderAction`s corresponding to `FolderPermission`s that should appear in the
    /// response's permissions in SharedFolderMetadata field describing the actions the  authenticated user can perform
    /// on the folder.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Sharing.SharedFolderMetadata` object on
    /// success or a `Sharing.UpdateFolderPolicyError` object on failure.
    @discardableResult open func updateFolderPolicy(sharedFolderId: String, memberPolicy: Sharing.MemberPolicy? = nil, aclUpdatePolicy: Sharing.AclUpdatePolicy? = nil, viewerInfoPolicy: Sharing.ViewerInfoPolicy? = nil, sharedLinkPolicy: Sharing.SharedLinkPolicy? = nil, linkSettings: Sharing.LinkSettings? = nil, actions: Array<Sharing.FolderAction>? = nil) -> RpcRequest<Sharing.SharedFolderMetadataSerializer, Sharing.UpdateFolderPolicyErrorSerializer> {
        let route = Sharing.updateFolderPolicy
        let serverArgs = Sharing.UpdateFolderPolicyArg(sharedFolderId: sharedFolderId, memberPolicy: memberPolicy, aclUpdatePolicy: aclUpdatePolicy, viewerInfoPolicy: viewerInfoPolicy, sharedLinkPolicy: sharedLinkPolicy, linkSettings: linkSettings, actions: actions)
        return client.request(route, serverArgs: serverArgs)
    }

}
