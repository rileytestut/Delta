///
/// Copyright (c) 2016 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

import Foundation

/// Datatypes and serializers for the files namespace
open class Files {
    /// The GetMetadataArg struct
    open class GetMetadataArg: CustomStringConvertible {
        /// The path of a file or folder on Dropbox.
        public let path: String
        /// If true, mediaInfo in FileMetadata is set for photo and video.
        public let includeMediaInfo: Bool
        /// If true, DeletedMetadata will be returned for deleted file or folder, otherwise notFound in LookupError will
        /// be returned.
        public let includeDeleted: Bool
        /// If true, the results will include a flag for each file indicating whether or not  that file has any explicit
        /// members.
        public let includeHasExplicitSharedMembers: Bool
        /// If set to a valid list of template IDs, propertyGroups in FileMetadata is set if there exists property data
        /// associated with the file and each of the listed templates.
        public let includePropertyGroups: FileProperties.TemplateFilterBase?
        public init(path: String, includeMediaInfo: Bool = false, includeDeleted: Bool = false, includeHasExplicitSharedMembers: Bool = false, includePropertyGroups: FileProperties.TemplateFilterBase? = nil) {
            stringValidator(pattern: "(/(.|[\\r\\n])*|id:.*)|(rev:[0-9a-f]{9,})|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            self.includeMediaInfo = includeMediaInfo
            self.includeDeleted = includeDeleted
            self.includeHasExplicitSharedMembers = includeHasExplicitSharedMembers
            self.includePropertyGroups = includePropertyGroups
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetMetadataArgSerializer().serialize(self)))"
        }
    }
    open class GetMetadataArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetMetadataArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "include_media_info": Serialization._BoolSerializer.serialize(value.includeMediaInfo),
            "include_deleted": Serialization._BoolSerializer.serialize(value.includeDeleted),
            "include_has_explicit_shared_members": Serialization._BoolSerializer.serialize(value.includeHasExplicitSharedMembers),
            "include_property_groups": NullableSerializer(FileProperties.TemplateFilterBaseSerializer()).serialize(value.includePropertyGroups),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetMetadataArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let includeMediaInfo = Serialization._BoolSerializer.deserialize(dict["include_media_info"] ?? .number(0))
                    let includeDeleted = Serialization._BoolSerializer.deserialize(dict["include_deleted"] ?? .number(0))
                    let includeHasExplicitSharedMembers = Serialization._BoolSerializer.deserialize(dict["include_has_explicit_shared_members"] ?? .number(0))
                    let includePropertyGroups = NullableSerializer(FileProperties.TemplateFilterBaseSerializer()).deserialize(dict["include_property_groups"] ?? .null)
                    return GetMetadataArg(path: path, includeMediaInfo: includeMediaInfo, includeDeleted: includeDeleted, includeHasExplicitSharedMembers: includeHasExplicitSharedMembers, includePropertyGroups: includePropertyGroups)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The AlphaGetMetadataArg struct
    open class AlphaGetMetadataArg: Files.GetMetadataArg {
        /// If set to a valid list of template IDs, propertyGroups in FileMetadata is set for files with custom
        /// properties.
        public let includePropertyTemplates: Array<String>?
        public init(path: String, includeMediaInfo: Bool = false, includeDeleted: Bool = false, includeHasExplicitSharedMembers: Bool = false, includePropertyGroups: FileProperties.TemplateFilterBase? = nil, includePropertyTemplates: Array<String>? = nil) {
            nullableValidator(arrayValidator(itemValidator: stringValidator(minLength: 1, pattern: "(/|ptid:).*")))(includePropertyTemplates)
            self.includePropertyTemplates = includePropertyTemplates
            super.init(path: path, includeMediaInfo: includeMediaInfo, includeDeleted: includeDeleted, includeHasExplicitSharedMembers: includeHasExplicitSharedMembers, includePropertyGroups: includePropertyGroups)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AlphaGetMetadataArgSerializer().serialize(self)))"
        }
    }
    open class AlphaGetMetadataArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AlphaGetMetadataArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "include_media_info": Serialization._BoolSerializer.serialize(value.includeMediaInfo),
            "include_deleted": Serialization._BoolSerializer.serialize(value.includeDeleted),
            "include_has_explicit_shared_members": Serialization._BoolSerializer.serialize(value.includeHasExplicitSharedMembers),
            "include_property_groups": NullableSerializer(FileProperties.TemplateFilterBaseSerializer()).serialize(value.includePropertyGroups),
            "include_property_templates": NullableSerializer(ArraySerializer(Serialization._StringSerializer)).serialize(value.includePropertyTemplates),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> AlphaGetMetadataArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let includeMediaInfo = Serialization._BoolSerializer.deserialize(dict["include_media_info"] ?? .number(0))
                    let includeDeleted = Serialization._BoolSerializer.deserialize(dict["include_deleted"] ?? .number(0))
                    let includeHasExplicitSharedMembers = Serialization._BoolSerializer.deserialize(dict["include_has_explicit_shared_members"] ?? .number(0))
                    let includePropertyGroups = NullableSerializer(FileProperties.TemplateFilterBaseSerializer()).deserialize(dict["include_property_groups"] ?? .null)
                    let includePropertyTemplates = NullableSerializer(ArraySerializer(Serialization._StringSerializer)).deserialize(dict["include_property_templates"] ?? .null)
                    return AlphaGetMetadataArg(path: path, includeMediaInfo: includeMediaInfo, includeDeleted: includeDeleted, includeHasExplicitSharedMembers: includeHasExplicitSharedMembers, includePropertyGroups: includePropertyGroups, includePropertyTemplates: includePropertyTemplates)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetMetadataError union
    public enum GetMetadataError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.LookupError)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetMetadataErrorSerializer().serialize(self)))"
        }
    }
    open class GetMetadataErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetMetadataError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GetMetadataError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return GetMetadataError.path(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The AlphaGetMetadataError union
    public enum AlphaGetMetadataError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.LookupError)
        /// An unspecified error.
        case propertiesError(FileProperties.LookUpPropertiesError)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AlphaGetMetadataErrorSerializer().serialize(self)))"
        }
    }
    open class AlphaGetMetadataErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AlphaGetMetadataError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .propertiesError(let arg):
                    var d = ["properties_error": FileProperties.LookUpPropertiesErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("properties_error")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> AlphaGetMetadataError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return AlphaGetMetadataError.path(v)
                        case "properties_error":
                            let v = FileProperties.LookUpPropertiesErrorSerializer().deserialize(d["properties_error"] ?? .null)
                            return AlphaGetMetadataError.propertiesError(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The CommitInfo struct
    open class CommitInfo: CustomStringConvertible {
        /// Path in the user's Dropbox to save the file.
        public let path: String
        /// Selects what to do if the file already exists.
        public let mode: Files.WriteMode
        /// If there's a conflict, as determined by mode, have the Dropbox server try to autorename the file to avoid
        /// conflict.
        public let autorename: Bool
        /// The value to store as the clientModified timestamp. Dropbox automatically records the time at which the file
        /// was written to the Dropbox servers. It can also record an additional timestamp, provided by Dropbox desktop
        /// clients, mobile clients, and API apps of when the file was actually created or modified.
        public let clientModified: Date?
        /// Normally, users are made aware of any file modifications in their Dropbox account via notifications in the
        /// client software. If true, this tells the clients that this modification shouldn't result in a user
        /// notification.
        public let mute: Bool
        /// List of custom properties to add to file.
        public let propertyGroups: Array<FileProperties.PropertyGroup>?
        /// Be more strict about how each WriteMode detects conflict. For example, always return a conflict error when
        /// mode = update in WriteMode and the given "rev" doesn't match the existing file's "rev", even if the existing
        /// file has been deleted.
        public let strictConflict: Bool
        public init(path: String, mode: Files.WriteMode = .add, autorename: Bool = false, clientModified: Date? = nil, mute: Bool = false, propertyGroups: Array<FileProperties.PropertyGroup>? = nil, strictConflict: Bool = false) {
            stringValidator(pattern: "(/(.|[\\r\\n])*)|(ns:[0-9]+(/.*)?)|(id:.*)")(path)
            self.path = path
            self.mode = mode
            self.autorename = autorename
            self.clientModified = clientModified
            self.mute = mute
            self.propertyGroups = propertyGroups
            self.strictConflict = strictConflict
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CommitInfoSerializer().serialize(self)))"
        }
    }
    open class CommitInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CommitInfo) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "mode": Files.WriteModeSerializer().serialize(value.mode),
            "autorename": Serialization._BoolSerializer.serialize(value.autorename),
            "client_modified": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.clientModified),
            "mute": Serialization._BoolSerializer.serialize(value.mute),
            "property_groups": NullableSerializer(ArraySerializer(FileProperties.PropertyGroupSerializer())).serialize(value.propertyGroups),
            "strict_conflict": Serialization._BoolSerializer.serialize(value.strictConflict),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> CommitInfo {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let mode = Files.WriteModeSerializer().deserialize(dict["mode"] ?? Files.WriteModeSerializer().serialize(.add))
                    let autorename = Serialization._BoolSerializer.deserialize(dict["autorename"] ?? .number(0))
                    let clientModified = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["client_modified"] ?? .null)
                    let mute = Serialization._BoolSerializer.deserialize(dict["mute"] ?? .number(0))
                    let propertyGroups = NullableSerializer(ArraySerializer(FileProperties.PropertyGroupSerializer())).deserialize(dict["property_groups"] ?? .null)
                    let strictConflict = Serialization._BoolSerializer.deserialize(dict["strict_conflict"] ?? .number(0))
                    return CommitInfo(path: path, mode: mode, autorename: autorename, clientModified: clientModified, mute: mute, propertyGroups: propertyGroups, strictConflict: strictConflict)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The CommitInfoWithProperties struct
    open class CommitInfoWithProperties: Files.CommitInfo {
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CommitInfoWithPropertiesSerializer().serialize(self)))"
        }
    }
    open class CommitInfoWithPropertiesSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CommitInfoWithProperties) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "mode": Files.WriteModeSerializer().serialize(value.mode),
            "autorename": Serialization._BoolSerializer.serialize(value.autorename),
            "client_modified": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.clientModified),
            "mute": Serialization._BoolSerializer.serialize(value.mute),
            "property_groups": NullableSerializer(ArraySerializer(FileProperties.PropertyGroupSerializer())).serialize(value.propertyGroups),
            "strict_conflict": Serialization._BoolSerializer.serialize(value.strictConflict),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> CommitInfoWithProperties {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let mode = Files.WriteModeSerializer().deserialize(dict["mode"] ?? Files.WriteModeSerializer().serialize(.add))
                    let autorename = Serialization._BoolSerializer.deserialize(dict["autorename"] ?? .number(0))
                    let clientModified = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["client_modified"] ?? .null)
                    let mute = Serialization._BoolSerializer.deserialize(dict["mute"] ?? .number(0))
                    let propertyGroups = NullableSerializer(ArraySerializer(FileProperties.PropertyGroupSerializer())).deserialize(dict["property_groups"] ?? .null)
                    let strictConflict = Serialization._BoolSerializer.deserialize(dict["strict_conflict"] ?? .number(0))
                    return CommitInfoWithProperties(path: path, mode: mode, autorename: autorename, clientModified: clientModified, mute: mute, propertyGroups: propertyGroups, strictConflict: strictConflict)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ContentSyncSetting struct
    open class ContentSyncSetting: CustomStringConvertible {
        /// Id of the item this setting is applied to.
        public let id: String
        /// Setting for this item.
        public let syncSetting: Files.SyncSetting
        public init(id: String, syncSetting: Files.SyncSetting) {
            stringValidator(minLength: 4, pattern: "id:.+")(id)
            self.id = id
            self.syncSetting = syncSetting
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ContentSyncSettingSerializer().serialize(self)))"
        }
    }
    open class ContentSyncSettingSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ContentSyncSetting) -> JSON {
            let output = [ 
            "id": Serialization._StringSerializer.serialize(value.id),
            "sync_setting": Files.SyncSettingSerializer().serialize(value.syncSetting),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ContentSyncSetting {
            switch json {
                case .dictionary(let dict):
                    let id = Serialization._StringSerializer.deserialize(dict["id"] ?? .null)
                    let syncSetting = Files.SyncSettingSerializer().deserialize(dict["sync_setting"] ?? .null)
                    return ContentSyncSetting(id: id, syncSetting: syncSetting)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ContentSyncSettingArg struct
    open class ContentSyncSettingArg: CustomStringConvertible {
        /// Id of the item this setting is applied to.
        public let id: String
        /// Setting for this item.
        public let syncSetting: Files.SyncSettingArg
        public init(id: String, syncSetting: Files.SyncSettingArg) {
            stringValidator(minLength: 4, pattern: "id:.+")(id)
            self.id = id
            self.syncSetting = syncSetting
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ContentSyncSettingArgSerializer().serialize(self)))"
        }
    }
    open class ContentSyncSettingArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ContentSyncSettingArg) -> JSON {
            let output = [ 
            "id": Serialization._StringSerializer.serialize(value.id),
            "sync_setting": Files.SyncSettingArgSerializer().serialize(value.syncSetting),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ContentSyncSettingArg {
            switch json {
                case .dictionary(let dict):
                    let id = Serialization._StringSerializer.deserialize(dict["id"] ?? .null)
                    let syncSetting = Files.SyncSettingArgSerializer().deserialize(dict["sync_setting"] ?? .null)
                    return ContentSyncSettingArg(id: id, syncSetting: syncSetting)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The CreateFolderArg struct
    open class CreateFolderArg: CustomStringConvertible {
        /// Path in the user's Dropbox to create.
        public let path: String
        /// If there's a conflict, have the Dropbox server try to autorename the folder to avoid the conflict.
        public let autorename: Bool
        public init(path: String, autorename: Bool = false) {
            stringValidator(pattern: "(/(.|[\\r\\n])*)|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            self.autorename = autorename
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CreateFolderArgSerializer().serialize(self)))"
        }
    }
    open class CreateFolderArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CreateFolderArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "autorename": Serialization._BoolSerializer.serialize(value.autorename),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> CreateFolderArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let autorename = Serialization._BoolSerializer.deserialize(dict["autorename"] ?? .number(0))
                    return CreateFolderArg(path: path, autorename: autorename)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The CreateFolderBatchArg struct
    open class CreateFolderBatchArg: CustomStringConvertible {
        /// List of paths to be created in the user's Dropbox. Duplicate path arguments in the batch are considered only
        /// once.
        public let paths: Array<String>
        /// If there's a conflict, have the Dropbox server try to autorename the folder to avoid the conflict.
        public let autorename: Bool
        /// Whether to force the create to happen asynchronously.
        public let forceAsync: Bool
        public init(paths: Array<String>, autorename: Bool = false, forceAsync: Bool = false) {
            arrayValidator(itemValidator: stringValidator(pattern: "(/(.|[\\r\\n])*)|(ns:[0-9]+(/.*)?)"))(paths)
            self.paths = paths
            self.autorename = autorename
            self.forceAsync = forceAsync
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CreateFolderBatchArgSerializer().serialize(self)))"
        }
    }
    open class CreateFolderBatchArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CreateFolderBatchArg) -> JSON {
            let output = [ 
            "paths": ArraySerializer(Serialization._StringSerializer).serialize(value.paths),
            "autorename": Serialization._BoolSerializer.serialize(value.autorename),
            "force_async": Serialization._BoolSerializer.serialize(value.forceAsync),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> CreateFolderBatchArg {
            switch json {
                case .dictionary(let dict):
                    let paths = ArraySerializer(Serialization._StringSerializer).deserialize(dict["paths"] ?? .null)
                    let autorename = Serialization._BoolSerializer.deserialize(dict["autorename"] ?? .number(0))
                    let forceAsync = Serialization._BoolSerializer.deserialize(dict["force_async"] ?? .number(0))
                    return CreateFolderBatchArg(paths: paths, autorename: autorename, forceAsync: forceAsync)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The CreateFolderBatchError union
    public enum CreateFolderBatchError: CustomStringConvertible {
        /// The operation would involve too many files or folders.
        case tooManyFiles
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CreateFolderBatchErrorSerializer().serialize(self)))"
        }
    }
    open class CreateFolderBatchErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CreateFolderBatchError) -> JSON {
            switch value {
                case .tooManyFiles:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_files")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> CreateFolderBatchError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "too_many_files":
                            return CreateFolderBatchError.tooManyFiles
                        case "other":
                            return CreateFolderBatchError.other
                        default:
                            return CreateFolderBatchError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The CreateFolderBatchJobStatus union
    public enum CreateFolderBatchJobStatus: CustomStringConvertible {
        /// The asynchronous job is still in progress.
        case inProgress
        /// The batch create folder has finished.
        case complete(Files.CreateFolderBatchResult)
        /// The batch create folder has failed.
        case failed(Files.CreateFolderBatchError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CreateFolderBatchJobStatusSerializer().serialize(self)))"
        }
    }
    open class CreateFolderBatchJobStatusSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CreateFolderBatchJobStatus) -> JSON {
            switch value {
                case .inProgress:
                    var d = [String: JSON]()
                    d[".tag"] = .str("in_progress")
                    return .dictionary(d)
                case .complete(let arg):
                    var d = Serialization.getFields(Files.CreateFolderBatchResultSerializer().serialize(arg))
                    d[".tag"] = .str("complete")
                    return .dictionary(d)
                case .failed(let arg):
                    var d = ["failed": Files.CreateFolderBatchErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("failed")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> CreateFolderBatchJobStatus {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "in_progress":
                            return CreateFolderBatchJobStatus.inProgress
                        case "complete":
                            let v = Files.CreateFolderBatchResultSerializer().deserialize(json)
                            return CreateFolderBatchJobStatus.complete(v)
                        case "failed":
                            let v = Files.CreateFolderBatchErrorSerializer().deserialize(d["failed"] ?? .null)
                            return CreateFolderBatchJobStatus.failed(v)
                        case "other":
                            return CreateFolderBatchJobStatus.other
                        default:
                            return CreateFolderBatchJobStatus.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Result returned by createFolderBatch that may either launch an asynchronous job or complete synchronously.
    public enum CreateFolderBatchLaunch: CustomStringConvertible {
        /// This response indicates that the processing is asynchronous. The string is an id that can be used to obtain
        /// the status of the asynchronous job.
        case asyncJobId(String)
        /// An unspecified error.
        case complete(Files.CreateFolderBatchResult)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CreateFolderBatchLaunchSerializer().serialize(self)))"
        }
    }
    open class CreateFolderBatchLaunchSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CreateFolderBatchLaunch) -> JSON {
            switch value {
                case .asyncJobId(let arg):
                    var d = ["async_job_id": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("async_job_id")
                    return .dictionary(d)
                case .complete(let arg):
                    var d = Serialization.getFields(Files.CreateFolderBatchResultSerializer().serialize(arg))
                    d[".tag"] = .str("complete")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> CreateFolderBatchLaunch {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "async_job_id":
                            let v = Serialization._StringSerializer.deserialize(d["async_job_id"] ?? .null)
                            return CreateFolderBatchLaunch.asyncJobId(v)
                        case "complete":
                            let v = Files.CreateFolderBatchResultSerializer().deserialize(json)
                            return CreateFolderBatchLaunch.complete(v)
                        case "other":
                            return CreateFolderBatchLaunch.other
                        default:
                            return CreateFolderBatchLaunch.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The FileOpsResult struct
    open class FileOpsResult: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileOpsResultSerializer().serialize(self)))"
        }
    }
    open class FileOpsResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileOpsResult) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileOpsResult {
            switch json {
                case .dictionary(_):
                    return FileOpsResult()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The CreateFolderBatchResult struct
    open class CreateFolderBatchResult: Files.FileOpsResult {
        /// Each entry in paths in CreateFolderBatchArg will appear at the same position inside entries in
        /// CreateFolderBatchResult.
        public let entries: Array<Files.CreateFolderBatchResultEntry>
        public init(entries: Array<Files.CreateFolderBatchResultEntry>) {
            self.entries = entries
            super.init()
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CreateFolderBatchResultSerializer().serialize(self)))"
        }
    }
    open class CreateFolderBatchResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CreateFolderBatchResult) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Files.CreateFolderBatchResultEntrySerializer()).serialize(value.entries),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> CreateFolderBatchResult {
            switch json {
                case .dictionary(let dict):
                    let entries = ArraySerializer(Files.CreateFolderBatchResultEntrySerializer()).deserialize(dict["entries"] ?? .null)
                    return CreateFolderBatchResult(entries: entries)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The CreateFolderBatchResultEntry union
    public enum CreateFolderBatchResultEntry: CustomStringConvertible {
        /// An unspecified error.
        case success(Files.CreateFolderEntryResult)
        /// An unspecified error.
        case failure(Files.CreateFolderEntryError)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CreateFolderBatchResultEntrySerializer().serialize(self)))"
        }
    }
    open class CreateFolderBatchResultEntrySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CreateFolderBatchResultEntry) -> JSON {
            switch value {
                case .success(let arg):
                    var d = Serialization.getFields(Files.CreateFolderEntryResultSerializer().serialize(arg))
                    d[".tag"] = .str("success")
                    return .dictionary(d)
                case .failure(let arg):
                    var d = ["failure": Files.CreateFolderEntryErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("failure")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> CreateFolderBatchResultEntry {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "success":
                            let v = Files.CreateFolderEntryResultSerializer().deserialize(json)
                            return CreateFolderBatchResultEntry.success(v)
                        case "failure":
                            let v = Files.CreateFolderEntryErrorSerializer().deserialize(d["failure"] ?? .null)
                            return CreateFolderBatchResultEntry.failure(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The CreateFolderEntryError union
    public enum CreateFolderEntryError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.WriteError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CreateFolderEntryErrorSerializer().serialize(self)))"
        }
    }
    open class CreateFolderEntryErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CreateFolderEntryError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> CreateFolderEntryError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.WriteErrorSerializer().deserialize(d["path"] ?? .null)
                            return CreateFolderEntryError.path(v)
                        case "other":
                            return CreateFolderEntryError.other
                        default:
                            return CreateFolderEntryError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The CreateFolderEntryResult struct
    open class CreateFolderEntryResult: CustomStringConvertible {
        /// Metadata of the created folder.
        public let metadata: Files.FolderMetadata
        public init(metadata: Files.FolderMetadata) {
            self.metadata = metadata
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CreateFolderEntryResultSerializer().serialize(self)))"
        }
    }
    open class CreateFolderEntryResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CreateFolderEntryResult) -> JSON {
            let output = [ 
            "metadata": Files.FolderMetadataSerializer().serialize(value.metadata),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> CreateFolderEntryResult {
            switch json {
                case .dictionary(let dict):
                    let metadata = Files.FolderMetadataSerializer().deserialize(dict["metadata"] ?? .null)
                    return CreateFolderEntryResult(metadata: metadata)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The CreateFolderError union
    public enum CreateFolderError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.WriteError)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CreateFolderErrorSerializer().serialize(self)))"
        }
    }
    open class CreateFolderErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CreateFolderError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> CreateFolderError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.WriteErrorSerializer().deserialize(d["path"] ?? .null)
                            return CreateFolderError.path(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The CreateFolderResult struct
    open class CreateFolderResult: Files.FileOpsResult {
        /// Metadata of the created folder.
        public let metadata: Files.FolderMetadata
        public init(metadata: Files.FolderMetadata) {
            self.metadata = metadata
            super.init()
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CreateFolderResultSerializer().serialize(self)))"
        }
    }
    open class CreateFolderResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CreateFolderResult) -> JSON {
            let output = [ 
            "metadata": Files.FolderMetadataSerializer().serialize(value.metadata),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> CreateFolderResult {
            switch json {
                case .dictionary(let dict):
                    let metadata = Files.FolderMetadataSerializer().deserialize(dict["metadata"] ?? .null)
                    return CreateFolderResult(metadata: metadata)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DeleteArg struct
    open class DeleteArg: CustomStringConvertible {
        /// Path in the user's Dropbox to delete.
        public let path: String
        /// Perform delete if given "rev" matches the existing file's latest "rev". This field does not support deleting
        /// a folder.
        public let parentRev: String?
        public init(path: String, parentRev: String? = nil) {
            stringValidator(pattern: "(/(.|[\\r\\n])*)|(ns:[0-9]+(/.*)?)|(id:.*)")(path)
            self.path = path
            nullableValidator(stringValidator(minLength: 9, pattern: "[0-9a-f]+"))(parentRev)
            self.parentRev = parentRev
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeleteArgSerializer().serialize(self)))"
        }
    }
    open class DeleteArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeleteArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "parent_rev": NullableSerializer(Serialization._StringSerializer).serialize(value.parentRev),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeleteArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let parentRev = NullableSerializer(Serialization._StringSerializer).deserialize(dict["parent_rev"] ?? .null)
                    return DeleteArg(path: path, parentRev: parentRev)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DeleteBatchArg struct
    open class DeleteBatchArg: CustomStringConvertible {
        /// (no description)
        public let entries: Array<Files.DeleteArg>
        public init(entries: Array<Files.DeleteArg>) {
            self.entries = entries
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeleteBatchArgSerializer().serialize(self)))"
        }
    }
    open class DeleteBatchArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeleteBatchArg) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Files.DeleteArgSerializer()).serialize(value.entries),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeleteBatchArg {
            switch json {
                case .dictionary(let dict):
                    let entries = ArraySerializer(Files.DeleteArgSerializer()).deserialize(dict["entries"] ?? .null)
                    return DeleteBatchArg(entries: entries)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DeleteBatchError union
    public enum DeleteBatchError: CustomStringConvertible {
        /// Use tooManyWriteOperations in DeleteError. deleteBatch now provides smaller granularity about which entry
        /// has failed because of this.
        case tooManyWriteOperations
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeleteBatchErrorSerializer().serialize(self)))"
        }
    }
    open class DeleteBatchErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeleteBatchError) -> JSON {
            switch value {
                case .tooManyWriteOperations:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_write_operations")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> DeleteBatchError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "too_many_write_operations":
                            return DeleteBatchError.tooManyWriteOperations
                        case "other":
                            return DeleteBatchError.other
                        default:
                            return DeleteBatchError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The DeleteBatchJobStatus union
    public enum DeleteBatchJobStatus: CustomStringConvertible {
        /// The asynchronous job is still in progress.
        case inProgress
        /// The batch delete has finished.
        case complete(Files.DeleteBatchResult)
        /// The batch delete has failed.
        case failed(Files.DeleteBatchError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeleteBatchJobStatusSerializer().serialize(self)))"
        }
    }
    open class DeleteBatchJobStatusSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeleteBatchJobStatus) -> JSON {
            switch value {
                case .inProgress:
                    var d = [String: JSON]()
                    d[".tag"] = .str("in_progress")
                    return .dictionary(d)
                case .complete(let arg):
                    var d = Serialization.getFields(Files.DeleteBatchResultSerializer().serialize(arg))
                    d[".tag"] = .str("complete")
                    return .dictionary(d)
                case .failed(let arg):
                    var d = ["failed": Files.DeleteBatchErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("failed")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> DeleteBatchJobStatus {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "in_progress":
                            return DeleteBatchJobStatus.inProgress
                        case "complete":
                            let v = Files.DeleteBatchResultSerializer().deserialize(json)
                            return DeleteBatchJobStatus.complete(v)
                        case "failed":
                            let v = Files.DeleteBatchErrorSerializer().deserialize(d["failed"] ?? .null)
                            return DeleteBatchJobStatus.failed(v)
                        case "other":
                            return DeleteBatchJobStatus.other
                        default:
                            return DeleteBatchJobStatus.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Result returned by deleteBatch that may either launch an asynchronous job or complete synchronously.
    public enum DeleteBatchLaunch: CustomStringConvertible {
        /// This response indicates that the processing is asynchronous. The string is an id that can be used to obtain
        /// the status of the asynchronous job.
        case asyncJobId(String)
        /// An unspecified error.
        case complete(Files.DeleteBatchResult)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeleteBatchLaunchSerializer().serialize(self)))"
        }
    }
    open class DeleteBatchLaunchSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeleteBatchLaunch) -> JSON {
            switch value {
                case .asyncJobId(let arg):
                    var d = ["async_job_id": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("async_job_id")
                    return .dictionary(d)
                case .complete(let arg):
                    var d = Serialization.getFields(Files.DeleteBatchResultSerializer().serialize(arg))
                    d[".tag"] = .str("complete")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> DeleteBatchLaunch {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "async_job_id":
                            let v = Serialization._StringSerializer.deserialize(d["async_job_id"] ?? .null)
                            return DeleteBatchLaunch.asyncJobId(v)
                        case "complete":
                            let v = Files.DeleteBatchResultSerializer().deserialize(json)
                            return DeleteBatchLaunch.complete(v)
                        case "other":
                            return DeleteBatchLaunch.other
                        default:
                            return DeleteBatchLaunch.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The DeleteBatchResult struct
    open class DeleteBatchResult: Files.FileOpsResult {
        /// Each entry in entries in DeleteBatchArg will appear at the same position inside entries in
        /// DeleteBatchResult.
        public let entries: Array<Files.DeleteBatchResultEntry>
        public init(entries: Array<Files.DeleteBatchResultEntry>) {
            self.entries = entries
            super.init()
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeleteBatchResultSerializer().serialize(self)))"
        }
    }
    open class DeleteBatchResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeleteBatchResult) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Files.DeleteBatchResultEntrySerializer()).serialize(value.entries),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeleteBatchResult {
            switch json {
                case .dictionary(let dict):
                    let entries = ArraySerializer(Files.DeleteBatchResultEntrySerializer()).deserialize(dict["entries"] ?? .null)
                    return DeleteBatchResult(entries: entries)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DeleteBatchResultData struct
    open class DeleteBatchResultData: CustomStringConvertible {
        /// Metadata of the deleted object.
        public let metadata: Files.Metadata
        public init(metadata: Files.Metadata) {
            self.metadata = metadata
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeleteBatchResultDataSerializer().serialize(self)))"
        }
    }
    open class DeleteBatchResultDataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeleteBatchResultData) -> JSON {
            let output = [ 
            "metadata": Files.MetadataSerializer().serialize(value.metadata),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeleteBatchResultData {
            switch json {
                case .dictionary(let dict):
                    let metadata = Files.MetadataSerializer().deserialize(dict["metadata"] ?? .null)
                    return DeleteBatchResultData(metadata: metadata)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DeleteBatchResultEntry union
    public enum DeleteBatchResultEntry: CustomStringConvertible {
        /// An unspecified error.
        case success(Files.DeleteBatchResultData)
        /// An unspecified error.
        case failure(Files.DeleteError)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeleteBatchResultEntrySerializer().serialize(self)))"
        }
    }
    open class DeleteBatchResultEntrySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeleteBatchResultEntry) -> JSON {
            switch value {
                case .success(let arg):
                    var d = Serialization.getFields(Files.DeleteBatchResultDataSerializer().serialize(arg))
                    d[".tag"] = .str("success")
                    return .dictionary(d)
                case .failure(let arg):
                    var d = ["failure": Files.DeleteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("failure")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> DeleteBatchResultEntry {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "success":
                            let v = Files.DeleteBatchResultDataSerializer().deserialize(json)
                            return DeleteBatchResultEntry.success(v)
                        case "failure":
                            let v = Files.DeleteErrorSerializer().deserialize(d["failure"] ?? .null)
                            return DeleteBatchResultEntry.failure(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The DeleteError union
    public enum DeleteError: CustomStringConvertible {
        /// An unspecified error.
        case pathLookup(Files.LookupError)
        /// An unspecified error.
        case pathWrite(Files.WriteError)
        /// There are too many write operations in user's Dropbox. Please retry this request.
        case tooManyWriteOperations
        /// There are too many files in one request. Please retry with fewer files.
        case tooManyFiles
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeleteErrorSerializer().serialize(self)))"
        }
    }
    open class DeleteErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeleteError) -> JSON {
            switch value {
                case .pathLookup(let arg):
                    var d = ["path_lookup": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path_lookup")
                    return .dictionary(d)
                case .pathWrite(let arg):
                    var d = ["path_write": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path_write")
                    return .dictionary(d)
                case .tooManyWriteOperations:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_write_operations")
                    return .dictionary(d)
                case .tooManyFiles:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_files")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> DeleteError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path_lookup":
                            let v = Files.LookupErrorSerializer().deserialize(d["path_lookup"] ?? .null)
                            return DeleteError.pathLookup(v)
                        case "path_write":
                            let v = Files.WriteErrorSerializer().deserialize(d["path_write"] ?? .null)
                            return DeleteError.pathWrite(v)
                        case "too_many_write_operations":
                            return DeleteError.tooManyWriteOperations
                        case "too_many_files":
                            return DeleteError.tooManyFiles
                        case "other":
                            return DeleteError.other
                        default:
                            return DeleteError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The DeleteResult struct
    open class DeleteResult: Files.FileOpsResult {
        /// Metadata of the deleted object.
        public let metadata: Files.Metadata
        public init(metadata: Files.Metadata) {
            self.metadata = metadata
            super.init()
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeleteResultSerializer().serialize(self)))"
        }
    }
    open class DeleteResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeleteResult) -> JSON {
            let output = [ 
            "metadata": Files.MetadataSerializer().serialize(value.metadata),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeleteResult {
            switch json {
                case .dictionary(let dict):
                    let metadata = Files.MetadataSerializer().deserialize(dict["metadata"] ?? .null)
                    return DeleteResult(metadata: metadata)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Metadata for a file or folder.
    open class Metadata: CustomStringConvertible {
        /// The last component of the path (including extension). This never contains a slash.
        public let name: String
        /// The lowercased full path in the user's Dropbox. This always starts with a slash. This field will be null if
        /// the file or folder is not mounted.
        public let pathLower: String?
        /// The cased path to be used for display purposes only. In rare instances the casing will not correctly match
        /// the user's filesystem, but this behavior will match the path provided in the Core API v1, and at least the
        /// last path component will have the correct casing. Changes to only the casing of paths won't be returned by
        /// listFolderContinue. This field will be null if the file or folder is not mounted.
        public let pathDisplay: String?
        /// Please use parentSharedFolderId in FileSharingInfo or parentSharedFolderId in FolderSharingInfo instead.
        public let parentSharedFolderId: String?
        public init(name: String, pathLower: String? = nil, pathDisplay: String? = nil, parentSharedFolderId: String? = nil) {
            stringValidator()(name)
            self.name = name
            nullableValidator(stringValidator())(pathLower)
            self.pathLower = pathLower
            nullableValidator(stringValidator())(pathDisplay)
            self.pathDisplay = pathDisplay
            nullableValidator(stringValidator(pattern: "[-_0-9a-zA-Z:]+"))(parentSharedFolderId)
            self.parentSharedFolderId = parentSharedFolderId
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MetadataSerializer().serialize(self)))"
        }
    }
    open class MetadataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: Metadata) -> JSON {
            var output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "path_lower": NullableSerializer(Serialization._StringSerializer).serialize(value.pathLower),
            "path_display": NullableSerializer(Serialization._StringSerializer).serialize(value.pathDisplay),
            "parent_shared_folder_id": NullableSerializer(Serialization._StringSerializer).serialize(value.parentSharedFolderId),
            ]
            switch value {
                case let file as Files.FileMetadata:
                    for (k, v) in Serialization.getFields(Files.FileMetadataSerializer().serialize(file)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("file")
                case let folder as Files.FolderMetadata:
                    for (k, v) in Serialization.getFields(Files.FolderMetadataSerializer().serialize(folder)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("folder")
                case let deleted as Files.DeletedMetadata:
                    for (k, v) in Serialization.getFields(Files.DeletedMetadataSerializer().serialize(deleted)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("deleted")
                default: fatalError("Tried to serialize unexpected subtype")
            }
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> Metadata {
            switch json {
                case .dictionary(let dict):
                    let tag = Serialization.getTag(dict)
                    switch tag {
                        case "file":
                            return Files.FileMetadataSerializer().deserialize(json)
                        case "folder":
                            return Files.FolderMetadataSerializer().deserialize(json)
                        case "deleted":
                            return Files.DeletedMetadataSerializer().deserialize(json)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Indicates that there used to be a file or folder at this path, but it no longer exists.
    open class DeletedMetadata: Files.Metadata {
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeletedMetadataSerializer().serialize(self)))"
        }
    }
    open class DeletedMetadataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeletedMetadata) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "path_lower": NullableSerializer(Serialization._StringSerializer).serialize(value.pathLower),
            "path_display": NullableSerializer(Serialization._StringSerializer).serialize(value.pathDisplay),
            "parent_shared_folder_id": NullableSerializer(Serialization._StringSerializer).serialize(value.parentSharedFolderId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeletedMetadata {
            switch json {
                case .dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                    let pathLower = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_lower"] ?? .null)
                    let pathDisplay = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_display"] ?? .null)
                    let parentSharedFolderId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["parent_shared_folder_id"] ?? .null)
                    return DeletedMetadata(name: name, pathLower: pathLower, pathDisplay: pathDisplay, parentSharedFolderId: parentSharedFolderId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Dimensions for a photo or video.
    open class Dimensions: CustomStringConvertible {
        /// Height of the photo/video.
        public let height: UInt64
        /// Width of the photo/video.
        public let width: UInt64
        public init(height: UInt64, width: UInt64) {
            comparableValidator()(height)
            self.height = height
            comparableValidator()(width)
            self.width = width
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DimensionsSerializer().serialize(self)))"
        }
    }
    open class DimensionsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: Dimensions) -> JSON {
            let output = [ 
            "height": Serialization._UInt64Serializer.serialize(value.height),
            "width": Serialization._UInt64Serializer.serialize(value.width),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> Dimensions {
            switch json {
                case .dictionary(let dict):
                    let height = Serialization._UInt64Serializer.deserialize(dict["height"] ?? .null)
                    let width = Serialization._UInt64Serializer.deserialize(dict["width"] ?? .null)
                    return Dimensions(height: height, width: width)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DownloadArg struct
    open class DownloadArg: CustomStringConvertible {
        /// The path of the file to download.
        public let path: String
        /// Please specify revision in path instead.
        public let rev: String?
        public init(path: String, rev: String? = nil) {
            stringValidator(pattern: "(/(.|[\\r\\n])*|id:.*)|(rev:[0-9a-f]{9,})|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            nullableValidator(stringValidator(minLength: 9, pattern: "[0-9a-f]+"))(rev)
            self.rev = rev
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DownloadArgSerializer().serialize(self)))"
        }
    }
    open class DownloadArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DownloadArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "rev": NullableSerializer(Serialization._StringSerializer).serialize(value.rev),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DownloadArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let rev = NullableSerializer(Serialization._StringSerializer).deserialize(dict["rev"] ?? .null)
                    return DownloadArg(path: path, rev: rev)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DownloadError union
    public enum DownloadError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.LookupError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DownloadErrorSerializer().serialize(self)))"
        }
    }
    open class DownloadErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DownloadError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> DownloadError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return DownloadError.path(v)
                        case "other":
                            return DownloadError.other
                        default:
                            return DownloadError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The DownloadZipArg struct
    open class DownloadZipArg: CustomStringConvertible {
        /// The path of the folder to download.
        public let path: String
        public init(path: String) {
            stringValidator(pattern: "(/(.|[\\r\\n])*|id:.*)|(rev:[0-9a-f]{9,})|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DownloadZipArgSerializer().serialize(self)))"
        }
    }
    open class DownloadZipArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DownloadZipArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DownloadZipArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    return DownloadZipArg(path: path)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DownloadZipError union
    public enum DownloadZipError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.LookupError)
        /// The folder or a file is too large to download.
        case tooLarge
        /// The folder has too many files to download.
        case tooManyFiles
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DownloadZipErrorSerializer().serialize(self)))"
        }
    }
    open class DownloadZipErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DownloadZipError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .tooLarge:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_large")
                    return .dictionary(d)
                case .tooManyFiles:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_files")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> DownloadZipError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return DownloadZipError.path(v)
                        case "too_large":
                            return DownloadZipError.tooLarge
                        case "too_many_files":
                            return DownloadZipError.tooManyFiles
                        case "other":
                            return DownloadZipError.other
                        default:
                            return DownloadZipError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The DownloadZipResult struct
    open class DownloadZipResult: CustomStringConvertible {
        /// (no description)
        public let metadata: Files.FolderMetadata
        public init(metadata: Files.FolderMetadata) {
            self.metadata = metadata
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DownloadZipResultSerializer().serialize(self)))"
        }
    }
    open class DownloadZipResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DownloadZipResult) -> JSON {
            let output = [ 
            "metadata": Files.FolderMetadataSerializer().serialize(value.metadata),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DownloadZipResult {
            switch json {
                case .dictionary(let dict):
                    let metadata = Files.FolderMetadataSerializer().deserialize(dict["metadata"] ?? .null)
                    return DownloadZipResult(metadata: metadata)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FileMetadata struct
    open class FileMetadata: Files.Metadata {
        /// A unique identifier for the file.
        public let id: String
        /// For files, this is the modification time set by the desktop client when the file was added to Dropbox. Since
        /// this time is not verified (the Dropbox server stores whatever the desktop client sends up), this should only
        /// be used for display purposes (such as sorting) and not, for example, to determine if a file has changed or
        /// not.
        public let clientModified: Date
        /// The last time the file was modified on Dropbox.
        public let serverModified: Date
        /// A unique identifier for the current revision of a file. This field is the same rev as elsewhere in the API
        /// and can be used to detect changes and avoid conflicts.
        public let rev: String
        /// The file size in bytes.
        public let size: UInt64
        /// Additional information if the file is a photo or video.
        public let mediaInfo: Files.MediaInfo?
        /// Set if this file is a symlink.
        public let symlinkInfo: Files.SymlinkInfo?
        /// Set if this file is contained in a shared folder.
        public let sharingInfo: Files.FileSharingInfo?
        /// Additional information if the file has custom properties with the property template specified.
        public let propertyGroups: Array<FileProperties.PropertyGroup>?
        /// This flag will only be present if include_has_explicit_shared_members  is true in listFolder or getMetadata.
        /// If this  flag is present, it will be true if this file has any explicit shared  members. This is different
        /// from sharing_info in that this could be true  in the case where a file has explicit members but is not
        /// contained within  a shared folder.
        public let hasExplicitSharedMembers: Bool?
        /// A hash of the file content. This field can be used to verify data integrity. For more information see our
        /// Content hash https://www.dropbox.com/developers/reference/content-hash page.
        public let contentHash: String?
        public init(name: String, id: String, clientModified: Date, serverModified: Date, rev: String, size: UInt64, pathLower: String? = nil, pathDisplay: String? = nil, parentSharedFolderId: String? = nil, mediaInfo: Files.MediaInfo? = nil, symlinkInfo: Files.SymlinkInfo? = nil, sharingInfo: Files.FileSharingInfo? = nil, propertyGroups: Array<FileProperties.PropertyGroup>? = nil, hasExplicitSharedMembers: Bool? = nil, contentHash: String? = nil) {
            stringValidator(minLength: 1)(id)
            self.id = id
            self.clientModified = clientModified
            self.serverModified = serverModified
            stringValidator(minLength: 9, pattern: "[0-9a-f]+")(rev)
            self.rev = rev
            comparableValidator()(size)
            self.size = size
            self.mediaInfo = mediaInfo
            self.symlinkInfo = symlinkInfo
            self.sharingInfo = sharingInfo
            self.propertyGroups = propertyGroups
            self.hasExplicitSharedMembers = hasExplicitSharedMembers
            nullableValidator(stringValidator(minLength: 64, maxLength: 64))(contentHash)
            self.contentHash = contentHash
            super.init(name: name, pathLower: pathLower, pathDisplay: pathDisplay, parentSharedFolderId: parentSharedFolderId)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileMetadataSerializer().serialize(self)))"
        }
    }
    open class FileMetadataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileMetadata) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "id": Serialization._StringSerializer.serialize(value.id),
            "client_modified": NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.clientModified),
            "server_modified": NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.serverModified),
            "rev": Serialization._StringSerializer.serialize(value.rev),
            "size": Serialization._UInt64Serializer.serialize(value.size),
            "path_lower": NullableSerializer(Serialization._StringSerializer).serialize(value.pathLower),
            "path_display": NullableSerializer(Serialization._StringSerializer).serialize(value.pathDisplay),
            "parent_shared_folder_id": NullableSerializer(Serialization._StringSerializer).serialize(value.parentSharedFolderId),
            "media_info": NullableSerializer(Files.MediaInfoSerializer()).serialize(value.mediaInfo),
            "symlink_info": NullableSerializer(Files.SymlinkInfoSerializer()).serialize(value.symlinkInfo),
            "sharing_info": NullableSerializer(Files.FileSharingInfoSerializer()).serialize(value.sharingInfo),
            "property_groups": NullableSerializer(ArraySerializer(FileProperties.PropertyGroupSerializer())).serialize(value.propertyGroups),
            "has_explicit_shared_members": NullableSerializer(Serialization._BoolSerializer).serialize(value.hasExplicitSharedMembers),
            "content_hash": NullableSerializer(Serialization._StringSerializer).serialize(value.contentHash),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileMetadata {
            switch json {
                case .dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                    let id = Serialization._StringSerializer.deserialize(dict["id"] ?? .null)
                    let clientModified = NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["client_modified"] ?? .null)
                    let serverModified = NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["server_modified"] ?? .null)
                    let rev = Serialization._StringSerializer.deserialize(dict["rev"] ?? .null)
                    let size = Serialization._UInt64Serializer.deserialize(dict["size"] ?? .null)
                    let pathLower = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_lower"] ?? .null)
                    let pathDisplay = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_display"] ?? .null)
                    let parentSharedFolderId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["parent_shared_folder_id"] ?? .null)
                    let mediaInfo = NullableSerializer(Files.MediaInfoSerializer()).deserialize(dict["media_info"] ?? .null)
                    let symlinkInfo = NullableSerializer(Files.SymlinkInfoSerializer()).deserialize(dict["symlink_info"] ?? .null)
                    let sharingInfo = NullableSerializer(Files.FileSharingInfoSerializer()).deserialize(dict["sharing_info"] ?? .null)
                    let propertyGroups = NullableSerializer(ArraySerializer(FileProperties.PropertyGroupSerializer())).deserialize(dict["property_groups"] ?? .null)
                    let hasExplicitSharedMembers = NullableSerializer(Serialization._BoolSerializer).deserialize(dict["has_explicit_shared_members"] ?? .null)
                    let contentHash = NullableSerializer(Serialization._StringSerializer).deserialize(dict["content_hash"] ?? .null)
                    return FileMetadata(name: name, id: id, clientModified: clientModified, serverModified: serverModified, rev: rev, size: size, pathLower: pathLower, pathDisplay: pathDisplay, parentSharedFolderId: parentSharedFolderId, mediaInfo: mediaInfo, symlinkInfo: symlinkInfo, sharingInfo: sharingInfo, propertyGroups: propertyGroups, hasExplicitSharedMembers: hasExplicitSharedMembers, contentHash: contentHash)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Sharing info for a file or folder.
    open class SharingInfo: CustomStringConvertible {
        /// True if the file or folder is inside a read-only shared folder.
        public let readOnly: Bool
        public init(readOnly: Bool) {
            self.readOnly = readOnly
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharingInfoSerializer().serialize(self)))"
        }
    }
    open class SharingInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharingInfo) -> JSON {
            let output = [ 
            "read_only": Serialization._BoolSerializer.serialize(value.readOnly),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharingInfo {
            switch json {
                case .dictionary(let dict):
                    let readOnly = Serialization._BoolSerializer.deserialize(dict["read_only"] ?? .null)
                    return SharingInfo(readOnly: readOnly)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Sharing info for a file which is contained by a shared folder.
    open class FileSharingInfo: Files.SharingInfo {
        /// ID of shared folder that holds this file.
        public let parentSharedFolderId: String
        /// The last user who modified the file. This field will be null if the user's account has been deleted.
        public let modifiedBy: String?
        public init(readOnly: Bool, parentSharedFolderId: String, modifiedBy: String? = nil) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(parentSharedFolderId)
            self.parentSharedFolderId = parentSharedFolderId
            nullableValidator(stringValidator(minLength: 40, maxLength: 40))(modifiedBy)
            self.modifiedBy = modifiedBy
            super.init(readOnly: readOnly)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileSharingInfoSerializer().serialize(self)))"
        }
    }
    open class FileSharingInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileSharingInfo) -> JSON {
            let output = [ 
            "read_only": Serialization._BoolSerializer.serialize(value.readOnly),
            "parent_shared_folder_id": Serialization._StringSerializer.serialize(value.parentSharedFolderId),
            "modified_by": NullableSerializer(Serialization._StringSerializer).serialize(value.modifiedBy),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileSharingInfo {
            switch json {
                case .dictionary(let dict):
                    let readOnly = Serialization._BoolSerializer.deserialize(dict["read_only"] ?? .null)
                    let parentSharedFolderId = Serialization._StringSerializer.deserialize(dict["parent_shared_folder_id"] ?? .null)
                    let modifiedBy = NullableSerializer(Serialization._StringSerializer).deserialize(dict["modified_by"] ?? .null)
                    return FileSharingInfo(readOnly: readOnly, parentSharedFolderId: parentSharedFolderId, modifiedBy: modifiedBy)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FolderMetadata struct
    open class FolderMetadata: Files.Metadata {
        /// A unique identifier for the folder.
        public let id: String
        /// Please use sharingInfo instead.
        public let sharedFolderId: String?
        /// Set if the folder is contained in a shared folder or is a shared folder mount point.
        public let sharingInfo: Files.FolderSharingInfo?
        /// Additional information if the file has custom properties with the property template specified. Note that
        /// only properties associated with user-owned templates, not team-owned templates, can be attached to folders.
        public let propertyGroups: Array<FileProperties.PropertyGroup>?
        public init(name: String, id: String, pathLower: String? = nil, pathDisplay: String? = nil, parentSharedFolderId: String? = nil, sharedFolderId: String? = nil, sharingInfo: Files.FolderSharingInfo? = nil, propertyGroups: Array<FileProperties.PropertyGroup>? = nil) {
            stringValidator(minLength: 1)(id)
            self.id = id
            nullableValidator(stringValidator(pattern: "[-_0-9a-zA-Z:]+"))(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.sharingInfo = sharingInfo
            self.propertyGroups = propertyGroups
            super.init(name: name, pathLower: pathLower, pathDisplay: pathDisplay, parentSharedFolderId: parentSharedFolderId)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FolderMetadataSerializer().serialize(self)))"
        }
    }
    open class FolderMetadataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FolderMetadata) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "id": Serialization._StringSerializer.serialize(value.id),
            "path_lower": NullableSerializer(Serialization._StringSerializer).serialize(value.pathLower),
            "path_display": NullableSerializer(Serialization._StringSerializer).serialize(value.pathDisplay),
            "parent_shared_folder_id": NullableSerializer(Serialization._StringSerializer).serialize(value.parentSharedFolderId),
            "shared_folder_id": NullableSerializer(Serialization._StringSerializer).serialize(value.sharedFolderId),
            "sharing_info": NullableSerializer(Files.FolderSharingInfoSerializer()).serialize(value.sharingInfo),
            "property_groups": NullableSerializer(ArraySerializer(FileProperties.PropertyGroupSerializer())).serialize(value.propertyGroups),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FolderMetadata {
            switch json {
                case .dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                    let id = Serialization._StringSerializer.deserialize(dict["id"] ?? .null)
                    let pathLower = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_lower"] ?? .null)
                    let pathDisplay = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_display"] ?? .null)
                    let parentSharedFolderId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["parent_shared_folder_id"] ?? .null)
                    let sharedFolderId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["shared_folder_id"] ?? .null)
                    let sharingInfo = NullableSerializer(Files.FolderSharingInfoSerializer()).deserialize(dict["sharing_info"] ?? .null)
                    let propertyGroups = NullableSerializer(ArraySerializer(FileProperties.PropertyGroupSerializer())).deserialize(dict["property_groups"] ?? .null)
                    return FolderMetadata(name: name, id: id, pathLower: pathLower, pathDisplay: pathDisplay, parentSharedFolderId: parentSharedFolderId, sharedFolderId: sharedFolderId, sharingInfo: sharingInfo, propertyGroups: propertyGroups)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Sharing info for a folder which is contained in a shared folder or is a shared folder mount point.
    open class FolderSharingInfo: Files.SharingInfo {
        /// Set if the folder is contained by a shared folder.
        public let parentSharedFolderId: String?
        /// If this folder is a shared folder mount point, the ID of the shared folder mounted at this location.
        public let sharedFolderId: String?
        /// Specifies that the folder can only be traversed and the user can only see a limited subset of the contents
        /// of this folder because they don't have read access to this folder. They do, however, have access to some sub
        /// folder.
        public let traverseOnly: Bool
        /// Specifies that the folder cannot be accessed by the user.
        public let noAccess: Bool
        public init(readOnly: Bool, parentSharedFolderId: String? = nil, sharedFolderId: String? = nil, traverseOnly: Bool = false, noAccess: Bool = false) {
            nullableValidator(stringValidator(pattern: "[-_0-9a-zA-Z:]+"))(parentSharedFolderId)
            self.parentSharedFolderId = parentSharedFolderId
            nullableValidator(stringValidator(pattern: "[-_0-9a-zA-Z:]+"))(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.traverseOnly = traverseOnly
            self.noAccess = noAccess
            super.init(readOnly: readOnly)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FolderSharingInfoSerializer().serialize(self)))"
        }
    }
    open class FolderSharingInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FolderSharingInfo) -> JSON {
            let output = [ 
            "read_only": Serialization._BoolSerializer.serialize(value.readOnly),
            "parent_shared_folder_id": NullableSerializer(Serialization._StringSerializer).serialize(value.parentSharedFolderId),
            "shared_folder_id": NullableSerializer(Serialization._StringSerializer).serialize(value.sharedFolderId),
            "traverse_only": Serialization._BoolSerializer.serialize(value.traverseOnly),
            "no_access": Serialization._BoolSerializer.serialize(value.noAccess),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FolderSharingInfo {
            switch json {
                case .dictionary(let dict):
                    let readOnly = Serialization._BoolSerializer.deserialize(dict["read_only"] ?? .null)
                    let parentSharedFolderId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["parent_shared_folder_id"] ?? .null)
                    let sharedFolderId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["shared_folder_id"] ?? .null)
                    let traverseOnly = Serialization._BoolSerializer.deserialize(dict["traverse_only"] ?? .number(0))
                    let noAccess = Serialization._BoolSerializer.deserialize(dict["no_access"] ?? .number(0))
                    return FolderSharingInfo(readOnly: readOnly, parentSharedFolderId: parentSharedFolderId, sharedFolderId: sharedFolderId, traverseOnly: traverseOnly, noAccess: noAccess)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetCopyReferenceArg struct
    open class GetCopyReferenceArg: CustomStringConvertible {
        /// The path to the file or folder you want to get a copy reference to.
        public let path: String
        public init(path: String) {
            stringValidator(pattern: "(/(.|[\\r\\n])*|id:.*)|(rev:[0-9a-f]{9,})|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetCopyReferenceArgSerializer().serialize(self)))"
        }
    }
    open class GetCopyReferenceArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetCopyReferenceArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetCopyReferenceArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    return GetCopyReferenceArg(path: path)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetCopyReferenceError union
    public enum GetCopyReferenceError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.LookupError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetCopyReferenceErrorSerializer().serialize(self)))"
        }
    }
    open class GetCopyReferenceErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetCopyReferenceError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GetCopyReferenceError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return GetCopyReferenceError.path(v)
                        case "other":
                            return GetCopyReferenceError.other
                        default:
                            return GetCopyReferenceError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GetCopyReferenceResult struct
    open class GetCopyReferenceResult: CustomStringConvertible {
        /// Metadata of the file or folder.
        public let metadata: Files.Metadata
        /// A copy reference to the file or folder.
        public let copyReference: String
        /// The expiration date of the copy reference. This value is currently set to be far enough in the future so
        /// that expiration is effectively not an issue.
        public let expires: Date
        public init(metadata: Files.Metadata, copyReference: String, expires: Date) {
            self.metadata = metadata
            stringValidator()(copyReference)
            self.copyReference = copyReference
            self.expires = expires
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetCopyReferenceResultSerializer().serialize(self)))"
        }
    }
    open class GetCopyReferenceResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetCopyReferenceResult) -> JSON {
            let output = [ 
            "metadata": Files.MetadataSerializer().serialize(value.metadata),
            "copy_reference": Serialization._StringSerializer.serialize(value.copyReference),
            "expires": NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.expires),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetCopyReferenceResult {
            switch json {
                case .dictionary(let dict):
                    let metadata = Files.MetadataSerializer().deserialize(dict["metadata"] ?? .null)
                    let copyReference = Serialization._StringSerializer.deserialize(dict["copy_reference"] ?? .null)
                    let expires = NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["expires"] ?? .null)
                    return GetCopyReferenceResult(metadata: metadata, copyReference: copyReference, expires: expires)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetTemporaryLinkArg struct
    open class GetTemporaryLinkArg: CustomStringConvertible {
        /// The path to the file you want a temporary link to.
        public let path: String
        public init(path: String) {
            stringValidator(pattern: "(/(.|[\\r\\n])*|id:.*)|(rev:[0-9a-f]{9,})|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetTemporaryLinkArgSerializer().serialize(self)))"
        }
    }
    open class GetTemporaryLinkArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetTemporaryLinkArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetTemporaryLinkArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    return GetTemporaryLinkArg(path: path)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetTemporaryLinkError union
    public enum GetTemporaryLinkError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.LookupError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetTemporaryLinkErrorSerializer().serialize(self)))"
        }
    }
    open class GetTemporaryLinkErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetTemporaryLinkError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GetTemporaryLinkError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return GetTemporaryLinkError.path(v)
                        case "other":
                            return GetTemporaryLinkError.other
                        default:
                            return GetTemporaryLinkError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GetTemporaryLinkResult struct
    open class GetTemporaryLinkResult: CustomStringConvertible {
        /// Metadata of the file.
        public let metadata: Files.FileMetadata
        /// The temporary link which can be used to stream content the file.
        public let link: String
        public init(metadata: Files.FileMetadata, link: String) {
            self.metadata = metadata
            stringValidator()(link)
            self.link = link
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetTemporaryLinkResultSerializer().serialize(self)))"
        }
    }
    open class GetTemporaryLinkResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetTemporaryLinkResult) -> JSON {
            let output = [ 
            "metadata": Files.FileMetadataSerializer().serialize(value.metadata),
            "link": Serialization._StringSerializer.serialize(value.link),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetTemporaryLinkResult {
            switch json {
                case .dictionary(let dict):
                    let metadata = Files.FileMetadataSerializer().deserialize(dict["metadata"] ?? .null)
                    let link = Serialization._StringSerializer.deserialize(dict["link"] ?? .null)
                    return GetTemporaryLinkResult(metadata: metadata, link: link)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetTemporaryUploadLinkArg struct
    open class GetTemporaryUploadLinkArg: CustomStringConvertible {
        /// Contains the path and other optional modifiers for the future upload commit. Equivalent to the parameters
        /// provided to upload.
        public let commitInfo: Files.CommitInfo
        /// How long before this link expires, in seconds.  Attempting to start an upload with this link longer than
        /// this period  of time after link creation will result in an error.
        public let duration: Double
        public init(commitInfo: Files.CommitInfo, duration: Double = 14400.0) {
            self.commitInfo = commitInfo
            comparableValidator(minValue: 60.0, maxValue: 14400.0)(duration)
            self.duration = duration
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetTemporaryUploadLinkArgSerializer().serialize(self)))"
        }
    }
    open class GetTemporaryUploadLinkArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetTemporaryUploadLinkArg) -> JSON {
            let output = [ 
            "commit_info": Files.CommitInfoSerializer().serialize(value.commitInfo),
            "duration": Serialization._DoubleSerializer.serialize(value.duration),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetTemporaryUploadLinkArg {
            switch json {
                case .dictionary(let dict):
                    let commitInfo = Files.CommitInfoSerializer().deserialize(dict["commit_info"] ?? .null)
                    let duration = Serialization._DoubleSerializer.deserialize(dict["duration"] ?? .number(14400.0))
                    return GetTemporaryUploadLinkArg(commitInfo: commitInfo, duration: duration)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetTemporaryUploadLinkResult struct
    open class GetTemporaryUploadLinkResult: CustomStringConvertible {
        /// The temporary link which can be used to stream a file to a Dropbox location.
        public let link: String
        public init(link: String) {
            stringValidator()(link)
            self.link = link
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetTemporaryUploadLinkResultSerializer().serialize(self)))"
        }
    }
    open class GetTemporaryUploadLinkResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetTemporaryUploadLinkResult) -> JSON {
            let output = [ 
            "link": Serialization._StringSerializer.serialize(value.link),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetTemporaryUploadLinkResult {
            switch json {
                case .dictionary(let dict):
                    let link = Serialization._StringSerializer.deserialize(dict["link"] ?? .null)
                    return GetTemporaryUploadLinkResult(link: link)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Arguments for getThumbnailBatch.
    open class GetThumbnailBatchArg: CustomStringConvertible {
        /// List of files to get thumbnails.
        public let entries: Array<Files.ThumbnailArg>
        public init(entries: Array<Files.ThumbnailArg>) {
            self.entries = entries
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetThumbnailBatchArgSerializer().serialize(self)))"
        }
    }
    open class GetThumbnailBatchArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetThumbnailBatchArg) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Files.ThumbnailArgSerializer()).serialize(value.entries),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetThumbnailBatchArg {
            switch json {
                case .dictionary(let dict):
                    let entries = ArraySerializer(Files.ThumbnailArgSerializer()).deserialize(dict["entries"] ?? .null)
                    return GetThumbnailBatchArg(entries: entries)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetThumbnailBatchError union
    public enum GetThumbnailBatchError: CustomStringConvertible {
        /// The operation involves more than 25 files.
        case tooManyFiles
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetThumbnailBatchErrorSerializer().serialize(self)))"
        }
    }
    open class GetThumbnailBatchErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetThumbnailBatchError) -> JSON {
            switch value {
                case .tooManyFiles:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_files")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GetThumbnailBatchError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "too_many_files":
                            return GetThumbnailBatchError.tooManyFiles
                        case "other":
                            return GetThumbnailBatchError.other
                        default:
                            return GetThumbnailBatchError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GetThumbnailBatchResult struct
    open class GetThumbnailBatchResult: CustomStringConvertible {
        /// List of files and their thumbnails.
        public let entries: Array<Files.GetThumbnailBatchResultEntry>
        public init(entries: Array<Files.GetThumbnailBatchResultEntry>) {
            self.entries = entries
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetThumbnailBatchResultSerializer().serialize(self)))"
        }
    }
    open class GetThumbnailBatchResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetThumbnailBatchResult) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Files.GetThumbnailBatchResultEntrySerializer()).serialize(value.entries),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetThumbnailBatchResult {
            switch json {
                case .dictionary(let dict):
                    let entries = ArraySerializer(Files.GetThumbnailBatchResultEntrySerializer()).deserialize(dict["entries"] ?? .null)
                    return GetThumbnailBatchResult(entries: entries)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetThumbnailBatchResultData struct
    open class GetThumbnailBatchResultData: CustomStringConvertible {
        /// (no description)
        public let metadata: Files.FileMetadata
        /// A string containing the base64-encoded thumbnail data for this file.
        public let thumbnail: String
        public init(metadata: Files.FileMetadata, thumbnail: String) {
            self.metadata = metadata
            stringValidator()(thumbnail)
            self.thumbnail = thumbnail
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetThumbnailBatchResultDataSerializer().serialize(self)))"
        }
    }
    open class GetThumbnailBatchResultDataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetThumbnailBatchResultData) -> JSON {
            let output = [ 
            "metadata": Files.FileMetadataSerializer().serialize(value.metadata),
            "thumbnail": Serialization._StringSerializer.serialize(value.thumbnail),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetThumbnailBatchResultData {
            switch json {
                case .dictionary(let dict):
                    let metadata = Files.FileMetadataSerializer().deserialize(dict["metadata"] ?? .null)
                    let thumbnail = Serialization._StringSerializer.deserialize(dict["thumbnail"] ?? .null)
                    return GetThumbnailBatchResultData(metadata: metadata, thumbnail: thumbnail)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetThumbnailBatchResultEntry union
    public enum GetThumbnailBatchResultEntry: CustomStringConvertible {
        /// An unspecified error.
        case success(Files.GetThumbnailBatchResultData)
        /// The result for this file if it was an error.
        case failure(Files.ThumbnailError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetThumbnailBatchResultEntrySerializer().serialize(self)))"
        }
    }
    open class GetThumbnailBatchResultEntrySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetThumbnailBatchResultEntry) -> JSON {
            switch value {
                case .success(let arg):
                    var d = Serialization.getFields(Files.GetThumbnailBatchResultDataSerializer().serialize(arg))
                    d[".tag"] = .str("success")
                    return .dictionary(d)
                case .failure(let arg):
                    var d = ["failure": Files.ThumbnailErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("failure")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GetThumbnailBatchResultEntry {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "success":
                            let v = Files.GetThumbnailBatchResultDataSerializer().deserialize(json)
                            return GetThumbnailBatchResultEntry.success(v)
                        case "failure":
                            let v = Files.ThumbnailErrorSerializer().deserialize(d["failure"] ?? .null)
                            return GetThumbnailBatchResultEntry.failure(v)
                        case "other":
                            return GetThumbnailBatchResultEntry.other
                        default:
                            return GetThumbnailBatchResultEntry.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// GPS coordinates for a photo or video.
    open class GpsCoordinates: CustomStringConvertible {
        /// Latitude of the GPS coordinates.
        public let latitude: Double
        /// Longitude of the GPS coordinates.
        public let longitude: Double
        public init(latitude: Double, longitude: Double) {
            comparableValidator()(latitude)
            self.latitude = latitude
            comparableValidator()(longitude)
            self.longitude = longitude
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GpsCoordinatesSerializer().serialize(self)))"
        }
    }
    open class GpsCoordinatesSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GpsCoordinates) -> JSON {
            let output = [ 
            "latitude": Serialization._DoubleSerializer.serialize(value.latitude),
            "longitude": Serialization._DoubleSerializer.serialize(value.longitude),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GpsCoordinates {
            switch json {
                case .dictionary(let dict):
                    let latitude = Serialization._DoubleSerializer.deserialize(dict["latitude"] ?? .null)
                    let longitude = Serialization._DoubleSerializer.deserialize(dict["longitude"] ?? .null)
                    return GpsCoordinates(latitude: latitude, longitude: longitude)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListFolderArg struct
    open class ListFolderArg: CustomStringConvertible {
        /// A unique identifier for the file.
        public let path: String
        /// If true, the list folder operation will be applied recursively to all subfolders and the response will
        /// contain contents of all subfolders.
        public let recursive: Bool
        /// If true, mediaInfo in FileMetadata is set for photo and video.
        public let includeMediaInfo: Bool
        /// If true, the results will include entries for files and folders that used to exist but were deleted.
        public let includeDeleted: Bool
        /// If true, the results will include a flag for each file indicating whether or not  that file has any explicit
        /// members.
        public let includeHasExplicitSharedMembers: Bool
        /// If true, the results will include entries under mounted folders which includes app folder, shared folder and
        /// team folder.
        public let includeMountedFolders: Bool
        /// The maximum number of results to return per request. Note: This is an approximate number and there can be
        /// slightly more entries returned in some cases.
        public let limit: UInt32?
        /// A shared link to list the contents of. If the link is password-protected, the password must be provided. If
        /// this field is present, path in ListFolderArg will be relative to root of the shared link. Only non-recursive
        /// mode is supported for shared link.
        public let sharedLink: Files.SharedLink?
        /// If set to a valid list of template IDs, propertyGroups in FileMetadata is set if there exists property data
        /// associated with the file and each of the listed templates.
        public let includePropertyGroups: FileProperties.TemplateFilterBase?
        public init(path: String, recursive: Bool = false, includeMediaInfo: Bool = false, includeDeleted: Bool = false, includeHasExplicitSharedMembers: Bool = false, includeMountedFolders: Bool = true, limit: UInt32? = nil, sharedLink: Files.SharedLink? = nil, includePropertyGroups: FileProperties.TemplateFilterBase? = nil) {
            stringValidator(pattern: "(/(.|[\\r\\n])*)?|id:.*|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            self.recursive = recursive
            self.includeMediaInfo = includeMediaInfo
            self.includeDeleted = includeDeleted
            self.includeHasExplicitSharedMembers = includeHasExplicitSharedMembers
            self.includeMountedFolders = includeMountedFolders
            nullableValidator(comparableValidator(minValue: 1, maxValue: 2000))(limit)
            self.limit = limit
            self.sharedLink = sharedLink
            self.includePropertyGroups = includePropertyGroups
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFolderArgSerializer().serialize(self)))"
        }
    }
    open class ListFolderArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFolderArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "recursive": Serialization._BoolSerializer.serialize(value.recursive),
            "include_media_info": Serialization._BoolSerializer.serialize(value.includeMediaInfo),
            "include_deleted": Serialization._BoolSerializer.serialize(value.includeDeleted),
            "include_has_explicit_shared_members": Serialization._BoolSerializer.serialize(value.includeHasExplicitSharedMembers),
            "include_mounted_folders": Serialization._BoolSerializer.serialize(value.includeMountedFolders),
            "limit": NullableSerializer(Serialization._UInt32Serializer).serialize(value.limit),
            "shared_link": NullableSerializer(Files.SharedLinkSerializer()).serialize(value.sharedLink),
            "include_property_groups": NullableSerializer(FileProperties.TemplateFilterBaseSerializer()).serialize(value.includePropertyGroups),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFolderArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let recursive = Serialization._BoolSerializer.deserialize(dict["recursive"] ?? .number(0))
                    let includeMediaInfo = Serialization._BoolSerializer.deserialize(dict["include_media_info"] ?? .number(0))
                    let includeDeleted = Serialization._BoolSerializer.deserialize(dict["include_deleted"] ?? .number(0))
                    let includeHasExplicitSharedMembers = Serialization._BoolSerializer.deserialize(dict["include_has_explicit_shared_members"] ?? .number(0))
                    let includeMountedFolders = Serialization._BoolSerializer.deserialize(dict["include_mounted_folders"] ?? .number(1))
                    let limit = NullableSerializer(Serialization._UInt32Serializer).deserialize(dict["limit"] ?? .null)
                    let sharedLink = NullableSerializer(Files.SharedLinkSerializer()).deserialize(dict["shared_link"] ?? .null)
                    let includePropertyGroups = NullableSerializer(FileProperties.TemplateFilterBaseSerializer()).deserialize(dict["include_property_groups"] ?? .null)
                    return ListFolderArg(path: path, recursive: recursive, includeMediaInfo: includeMediaInfo, includeDeleted: includeDeleted, includeHasExplicitSharedMembers: includeHasExplicitSharedMembers, includeMountedFolders: includeMountedFolders, limit: limit, sharedLink: sharedLink, includePropertyGroups: includePropertyGroups)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListFolderContinueArg struct
    open class ListFolderContinueArg: CustomStringConvertible {
        /// The cursor returned by your last call to listFolder or listFolderContinue.
        public let cursor: String
        public init(cursor: String) {
            stringValidator(minLength: 1)(cursor)
            self.cursor = cursor
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFolderContinueArgSerializer().serialize(self)))"
        }
    }
    open class ListFolderContinueArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFolderContinueArg) -> JSON {
            let output = [ 
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFolderContinueArg {
            switch json {
                case .dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                    return ListFolderContinueArg(cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListFolderContinueError union
    public enum ListFolderContinueError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.LookupError)
        /// Indicates that the cursor has been invalidated. Call listFolder to obtain a new cursor.
        case reset
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFolderContinueErrorSerializer().serialize(self)))"
        }
    }
    open class ListFolderContinueErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFolderContinueError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .reset:
                    var d = [String: JSON]()
                    d[".tag"] = .str("reset")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ListFolderContinueError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return ListFolderContinueError.path(v)
                        case "reset":
                            return ListFolderContinueError.reset
                        case "other":
                            return ListFolderContinueError.other
                        default:
                            return ListFolderContinueError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ListFolderError union
    public enum ListFolderError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.LookupError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFolderErrorSerializer().serialize(self)))"
        }
    }
    open class ListFolderErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFolderError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ListFolderError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return ListFolderError.path(v)
                        case "other":
                            return ListFolderError.other
                        default:
                            return ListFolderError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ListFolderGetLatestCursorResult struct
    open class ListFolderGetLatestCursorResult: CustomStringConvertible {
        /// Pass the cursor into listFolderContinue to see what's changed in the folder since your previous query.
        public let cursor: String
        public init(cursor: String) {
            stringValidator(minLength: 1)(cursor)
            self.cursor = cursor
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFolderGetLatestCursorResultSerializer().serialize(self)))"
        }
    }
    open class ListFolderGetLatestCursorResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFolderGetLatestCursorResult) -> JSON {
            let output = [ 
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFolderGetLatestCursorResult {
            switch json {
                case .dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                    return ListFolderGetLatestCursorResult(cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListFolderLongpollArg struct
    open class ListFolderLongpollArg: CustomStringConvertible {
        /// A cursor as returned by listFolder or listFolderContinue. Cursors retrieved by setting includeMediaInfo in
        /// ListFolderArg to true are not supported.
        public let cursor: String
        /// A timeout in seconds. The request will block for at most this length of time, plus up to 90 seconds of
        /// random jitter added to avoid the thundering herd problem. Care should be taken when using this parameter, as
        /// some network infrastructure does not support long timeouts.
        public let timeout: UInt64
        public init(cursor: String, timeout: UInt64 = 30) {
            stringValidator(minLength: 1)(cursor)
            self.cursor = cursor
            comparableValidator(minValue: 30, maxValue: 480)(timeout)
            self.timeout = timeout
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFolderLongpollArgSerializer().serialize(self)))"
        }
    }
    open class ListFolderLongpollArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFolderLongpollArg) -> JSON {
            let output = [ 
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            "timeout": Serialization._UInt64Serializer.serialize(value.timeout),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFolderLongpollArg {
            switch json {
                case .dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                    let timeout = Serialization._UInt64Serializer.deserialize(dict["timeout"] ?? .number(30))
                    return ListFolderLongpollArg(cursor: cursor, timeout: timeout)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListFolderLongpollError union
    public enum ListFolderLongpollError: CustomStringConvertible {
        /// Indicates that the cursor has been invalidated. Call listFolder to obtain a new cursor.
        case reset
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFolderLongpollErrorSerializer().serialize(self)))"
        }
    }
    open class ListFolderLongpollErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFolderLongpollError) -> JSON {
            switch value {
                case .reset:
                    var d = [String: JSON]()
                    d[".tag"] = .str("reset")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ListFolderLongpollError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "reset":
                            return ListFolderLongpollError.reset
                        case "other":
                            return ListFolderLongpollError.other
                        default:
                            return ListFolderLongpollError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ListFolderLongpollResult struct
    open class ListFolderLongpollResult: CustomStringConvertible {
        /// Indicates whether new changes are available. If true, call listFolderContinue to retrieve the changes.
        public let changes: Bool
        /// If present, backoff for at least this many seconds before calling listFolderLongpoll again.
        public let backoff: UInt64?
        public init(changes: Bool, backoff: UInt64? = nil) {
            self.changes = changes
            nullableValidator(comparableValidator())(backoff)
            self.backoff = backoff
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFolderLongpollResultSerializer().serialize(self)))"
        }
    }
    open class ListFolderLongpollResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFolderLongpollResult) -> JSON {
            let output = [ 
            "changes": Serialization._BoolSerializer.serialize(value.changes),
            "backoff": NullableSerializer(Serialization._UInt64Serializer).serialize(value.backoff),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFolderLongpollResult {
            switch json {
                case .dictionary(let dict):
                    let changes = Serialization._BoolSerializer.deserialize(dict["changes"] ?? .null)
                    let backoff = NullableSerializer(Serialization._UInt64Serializer).deserialize(dict["backoff"] ?? .null)
                    return ListFolderLongpollResult(changes: changes, backoff: backoff)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListFolderResult struct
    open class ListFolderResult: CustomStringConvertible {
        /// The files and (direct) subfolders in the folder.
        public let entries: Array<Files.Metadata>
        /// Pass the cursor into listFolderContinue to see what's changed in the folder since your previous query.
        public let cursor: String
        /// If true, then there are more entries available. Pass the cursor to listFolderContinue to retrieve the rest.
        public let hasMore: Bool
        public init(entries: Array<Files.Metadata>, cursor: String, hasMore: Bool) {
            self.entries = entries
            stringValidator(minLength: 1)(cursor)
            self.cursor = cursor
            self.hasMore = hasMore
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFolderResultSerializer().serialize(self)))"
        }
    }
    open class ListFolderResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFolderResult) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Files.MetadataSerializer()).serialize(value.entries),
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            "has_more": Serialization._BoolSerializer.serialize(value.hasMore),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFolderResult {
            switch json {
                case .dictionary(let dict):
                    let entries = ArraySerializer(Files.MetadataSerializer()).deserialize(dict["entries"] ?? .null)
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                    let hasMore = Serialization._BoolSerializer.deserialize(dict["has_more"] ?? .null)
                    return ListFolderResult(entries: entries, cursor: cursor, hasMore: hasMore)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListRevisionsArg struct
    open class ListRevisionsArg: CustomStringConvertible {
        /// The path to the file you want to see the revisions of.
        public let path: String
        /// Determines the behavior of the API in listing the revisions for a given file path or id.
        public let mode: Files.ListRevisionsMode
        /// The maximum number of revision entries returned.
        public let limit: UInt64
        public init(path: String, mode: Files.ListRevisionsMode = .path, limit: UInt64 = 10) {
            stringValidator(pattern: "/(.|[\\r\\n])*|id:.*|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            self.mode = mode
            comparableValidator(minValue: 1, maxValue: 100)(limit)
            self.limit = limit
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListRevisionsArgSerializer().serialize(self)))"
        }
    }
    open class ListRevisionsArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListRevisionsArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "mode": Files.ListRevisionsModeSerializer().serialize(value.mode),
            "limit": Serialization._UInt64Serializer.serialize(value.limit),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListRevisionsArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let mode = Files.ListRevisionsModeSerializer().deserialize(dict["mode"] ?? Files.ListRevisionsModeSerializer().serialize(.path))
                    let limit = Serialization._UInt64Serializer.deserialize(dict["limit"] ?? .number(10))
                    return ListRevisionsArg(path: path, mode: mode, limit: limit)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListRevisionsError union
    public enum ListRevisionsError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.LookupError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListRevisionsErrorSerializer().serialize(self)))"
        }
    }
    open class ListRevisionsErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListRevisionsError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ListRevisionsError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return ListRevisionsError.path(v)
                        case "other":
                            return ListRevisionsError.other
                        default:
                            return ListRevisionsError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ListRevisionsMode union
    public enum ListRevisionsMode: CustomStringConvertible {
        /// Returns revisions with the same file path as identified by the latest file entry at the given file path or
        /// id.
        case path
        /// Returns revisions with the same file id as identified by the latest file entry at the given file path or id.
        case id
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListRevisionsModeSerializer().serialize(self)))"
        }
    }
    open class ListRevisionsModeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListRevisionsMode) -> JSON {
            switch value {
                case .path:
                    var d = [String: JSON]()
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .id:
                    var d = [String: JSON]()
                    d[".tag"] = .str("id")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ListRevisionsMode {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            return ListRevisionsMode.path
                        case "id":
                            return ListRevisionsMode.id
                        case "other":
                            return ListRevisionsMode.other
                        default:
                            return ListRevisionsMode.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ListRevisionsResult struct
    open class ListRevisionsResult: CustomStringConvertible {
        /// If the file identified by the latest revision in the response is either deleted or moved.
        public let isDeleted: Bool
        /// The time of deletion if the file was deleted.
        public let serverDeleted: Date?
        /// The revisions for the file. Only revisions that are not deleted will show up here.
        public let entries: Array<Files.FileMetadata>
        public init(isDeleted: Bool, entries: Array<Files.FileMetadata>, serverDeleted: Date? = nil) {
            self.isDeleted = isDeleted
            self.serverDeleted = serverDeleted
            self.entries = entries
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListRevisionsResultSerializer().serialize(self)))"
        }
    }
    open class ListRevisionsResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListRevisionsResult) -> JSON {
            let output = [ 
            "is_deleted": Serialization._BoolSerializer.serialize(value.isDeleted),
            "entries": ArraySerializer(Files.FileMetadataSerializer()).serialize(value.entries),
            "server_deleted": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.serverDeleted),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListRevisionsResult {
            switch json {
                case .dictionary(let dict):
                    let isDeleted = Serialization._BoolSerializer.deserialize(dict["is_deleted"] ?? .null)
                    let entries = ArraySerializer(Files.FileMetadataSerializer()).deserialize(dict["entries"] ?? .null)
                    let serverDeleted = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["server_deleted"] ?? .null)
                    return ListRevisionsResult(isDeleted: isDeleted, entries: entries, serverDeleted: serverDeleted)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The LookupError union
    public enum LookupError: CustomStringConvertible {
        /// The given path does not satisfy the required path format. Please refer to the Path formats documentation
        /// https://www.dropbox.com/developers/documentation/http/documentation#path-formats for more information.
        case malformedPath(String?)
        /// There is nothing at the given path.
        case notFound
        /// We were expecting a file, but the given path refers to something that isn't a file.
        case notFile
        /// We were expecting a folder, but the given path refers to something that isn't a folder.
        case notFolder
        /// The file cannot be transferred because the content is restricted.  For example, sometimes there are legal
        /// restrictions due to copyright claims.
        case restrictedContent
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(LookupErrorSerializer().serialize(self)))"
        }
    }
    open class LookupErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: LookupError) -> JSON {
            switch value {
                case .malformedPath(let arg):
                    var d = ["malformed_path": NullableSerializer(Serialization._StringSerializer).serialize(arg)]
                    d[".tag"] = .str("malformed_path")
                    return .dictionary(d)
                case .notFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_found")
                    return .dictionary(d)
                case .notFile:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_file")
                    return .dictionary(d)
                case .notFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_folder")
                    return .dictionary(d)
                case .restrictedContent:
                    var d = [String: JSON]()
                    d[".tag"] = .str("restricted_content")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> LookupError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "malformed_path":
                            let v = NullableSerializer(Serialization._StringSerializer).deserialize(d["malformed_path"] ?? .null)
                            return LookupError.malformedPath(v)
                        case "not_found":
                            return LookupError.notFound
                        case "not_file":
                            return LookupError.notFile
                        case "not_folder":
                            return LookupError.notFolder
                        case "restricted_content":
                            return LookupError.restrictedContent
                        case "other":
                            return LookupError.other
                        default:
                            return LookupError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The MediaInfo union
    public enum MediaInfo: CustomStringConvertible {
        /// Indicate the photo/video is still under processing and metadata is not available yet.
        case pending
        /// The metadata for the photo/video.
        case metadata(Files.MediaMetadata)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MediaInfoSerializer().serialize(self)))"
        }
    }
    open class MediaInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MediaInfo) -> JSON {
            switch value {
                case .pending:
                    var d = [String: JSON]()
                    d[".tag"] = .str("pending")
                    return .dictionary(d)
                case .metadata(let arg):
                    var d = ["metadata": Files.MediaMetadataSerializer().serialize(arg)]
                    d[".tag"] = .str("metadata")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> MediaInfo {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "pending":
                            return MediaInfo.pending
                        case "metadata":
                            let v = Files.MediaMetadataSerializer().deserialize(d["metadata"] ?? .null)
                            return MediaInfo.metadata(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Metadata for a photo or video.
    open class MediaMetadata: CustomStringConvertible {
        /// Dimension of the photo/video.
        public let dimensions: Files.Dimensions?
        /// The GPS coordinate of the photo/video.
        public let location: Files.GpsCoordinates?
        /// The timestamp when the photo/video is taken.
        public let timeTaken: Date?
        public init(dimensions: Files.Dimensions? = nil, location: Files.GpsCoordinates? = nil, timeTaken: Date? = nil) {
            self.dimensions = dimensions
            self.location = location
            self.timeTaken = timeTaken
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MediaMetadataSerializer().serialize(self)))"
        }
    }
    open class MediaMetadataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MediaMetadata) -> JSON {
            var output = [ 
            "dimensions": NullableSerializer(Files.DimensionsSerializer()).serialize(value.dimensions),
            "location": NullableSerializer(Files.GpsCoordinatesSerializer()).serialize(value.location),
            "time_taken": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.timeTaken),
            ]
            switch value {
                case let photo as Files.PhotoMetadata:
                    for (k, v) in Serialization.getFields(Files.PhotoMetadataSerializer().serialize(photo)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("photo")
                case let video as Files.VideoMetadata:
                    for (k, v) in Serialization.getFields(Files.VideoMetadataSerializer().serialize(video)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("video")
                default: fatalError("Tried to serialize unexpected subtype")
            }
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MediaMetadata {
            switch json {
                case .dictionary(let dict):
                    let tag = Serialization.getTag(dict)
                    switch tag {
                        case "photo":
                            return Files.PhotoMetadataSerializer().deserialize(json)
                        case "video":
                            return Files.VideoMetadataSerializer().deserialize(json)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RelocationBatchArgBase struct
    open class RelocationBatchArgBase: CustomStringConvertible {
        /// List of entries to be moved or copied. Each entry is RelocationPath.
        public let entries: Array<Files.RelocationPath>
        /// If there's a conflict with any file, have the Dropbox server try to autorename that file to avoid the
        /// conflict.
        public let autorename: Bool
        public init(entries: Array<Files.RelocationPath>, autorename: Bool = false) {
            self.entries = entries
            self.autorename = autorename
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelocationBatchArgBaseSerializer().serialize(self)))"
        }
    }
    open class RelocationBatchArgBaseSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelocationBatchArgBase) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Files.RelocationPathSerializer()).serialize(value.entries),
            "autorename": Serialization._BoolSerializer.serialize(value.autorename),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RelocationBatchArgBase {
            switch json {
                case .dictionary(let dict):
                    let entries = ArraySerializer(Files.RelocationPathSerializer()).deserialize(dict["entries"] ?? .null)
                    let autorename = Serialization._BoolSerializer.deserialize(dict["autorename"] ?? .number(0))
                    return RelocationBatchArgBase(entries: entries, autorename: autorename)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MoveBatchArg struct
    open class MoveBatchArg: Files.RelocationBatchArgBase {
        /// Allow moves by owner even if it would result in an ownership transfer for the content being moved. This does
        /// not apply to copies.
        public let allowOwnershipTransfer: Bool
        public init(entries: Array<Files.RelocationPath>, autorename: Bool = false, allowOwnershipTransfer: Bool = false) {
            self.allowOwnershipTransfer = allowOwnershipTransfer
            super.init(entries: entries, autorename: autorename)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MoveBatchArgSerializer().serialize(self)))"
        }
    }
    open class MoveBatchArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MoveBatchArg) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Files.RelocationPathSerializer()).serialize(value.entries),
            "autorename": Serialization._BoolSerializer.serialize(value.autorename),
            "allow_ownership_transfer": Serialization._BoolSerializer.serialize(value.allowOwnershipTransfer),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MoveBatchArg {
            switch json {
                case .dictionary(let dict):
                    let entries = ArraySerializer(Files.RelocationPathSerializer()).deserialize(dict["entries"] ?? .null)
                    let autorename = Serialization._BoolSerializer.deserialize(dict["autorename"] ?? .number(0))
                    let allowOwnershipTransfer = Serialization._BoolSerializer.deserialize(dict["allow_ownership_transfer"] ?? .number(0))
                    return MoveBatchArg(entries: entries, autorename: autorename, allowOwnershipTransfer: allowOwnershipTransfer)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Metadata for a photo.
    open class PhotoMetadata: Files.MediaMetadata {
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PhotoMetadataSerializer().serialize(self)))"
        }
    }
    open class PhotoMetadataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PhotoMetadata) -> JSON {
            let output = [ 
            "dimensions": NullableSerializer(Files.DimensionsSerializer()).serialize(value.dimensions),
            "location": NullableSerializer(Files.GpsCoordinatesSerializer()).serialize(value.location),
            "time_taken": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.timeTaken),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PhotoMetadata {
            switch json {
                case .dictionary(let dict):
                    let dimensions = NullableSerializer(Files.DimensionsSerializer()).deserialize(dict["dimensions"] ?? .null)
                    let location = NullableSerializer(Files.GpsCoordinatesSerializer()).deserialize(dict["location"] ?? .null)
                    let timeTaken = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["time_taken"] ?? .null)
                    return PhotoMetadata(dimensions: dimensions, location: location, timeTaken: timeTaken)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PreviewArg struct
    open class PreviewArg: CustomStringConvertible {
        /// The path of the file to preview.
        public let path: String
        /// Please specify revision in path instead.
        public let rev: String?
        public init(path: String, rev: String? = nil) {
            stringValidator(pattern: "(/(.|[\\r\\n])*|id:.*)|(rev:[0-9a-f]{9,})|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            nullableValidator(stringValidator(minLength: 9, pattern: "[0-9a-f]+"))(rev)
            self.rev = rev
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PreviewArgSerializer().serialize(self)))"
        }
    }
    open class PreviewArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PreviewArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "rev": NullableSerializer(Serialization._StringSerializer).serialize(value.rev),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PreviewArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let rev = NullableSerializer(Serialization._StringSerializer).deserialize(dict["rev"] ?? .null)
                    return PreviewArg(path: path, rev: rev)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PreviewError union
    public enum PreviewError: CustomStringConvertible {
        /// An error occurs when downloading metadata for the file.
        case path(Files.LookupError)
        /// This preview generation is still in progress and the file is not ready  for preview yet.
        case inProgress
        /// The file extension is not supported preview generation.
        case unsupportedExtension
        /// The file content is not supported for preview generation.
        case unsupportedContent

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PreviewErrorSerializer().serialize(self)))"
        }
    }
    open class PreviewErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PreviewError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .inProgress:
                    var d = [String: JSON]()
                    d[".tag"] = .str("in_progress")
                    return .dictionary(d)
                case .unsupportedExtension:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unsupported_extension")
                    return .dictionary(d)
                case .unsupportedContent:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unsupported_content")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> PreviewError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return PreviewError.path(v)
                        case "in_progress":
                            return PreviewError.inProgress
                        case "unsupported_extension":
                            return PreviewError.unsupportedExtension
                        case "unsupported_content":
                            return PreviewError.unsupportedContent
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The RelocationPath struct
    open class RelocationPath: CustomStringConvertible {
        /// Path in the user's Dropbox to be copied or moved.
        public let fromPath: String
        /// Path in the user's Dropbox that is the destination.
        public let toPath: String
        public init(fromPath: String, toPath: String) {
            stringValidator(pattern: "(/(.|[\\r\\n])*)|(ns:[0-9]+(/.*)?)|(id:.*)")(fromPath)
            self.fromPath = fromPath
            stringValidator(pattern: "(/(.|[\\r\\n])*)|(ns:[0-9]+(/.*)?)|(id:.*)")(toPath)
            self.toPath = toPath
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelocationPathSerializer().serialize(self)))"
        }
    }
    open class RelocationPathSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelocationPath) -> JSON {
            let output = [ 
            "from_path": Serialization._StringSerializer.serialize(value.fromPath),
            "to_path": Serialization._StringSerializer.serialize(value.toPath),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RelocationPath {
            switch json {
                case .dictionary(let dict):
                    let fromPath = Serialization._StringSerializer.deserialize(dict["from_path"] ?? .null)
                    let toPath = Serialization._StringSerializer.deserialize(dict["to_path"] ?? .null)
                    return RelocationPath(fromPath: fromPath, toPath: toPath)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RelocationArg struct
    open class RelocationArg: Files.RelocationPath {
        /// If true, copy will copy contents in shared folder, otherwise cantCopySharedFolder in RelocationError will be
        /// returned if fromPath contains shared folder. This field is always true for move.
        public let allowSharedFolder: Bool
        /// If there's a conflict, have the Dropbox server try to autorename the file to avoid the conflict.
        public let autorename: Bool
        /// Allow moves by owner even if it would result in an ownership transfer for the content being moved. This does
        /// not apply to copies.
        public let allowOwnershipTransfer: Bool
        public init(fromPath: String, toPath: String, allowSharedFolder: Bool = false, autorename: Bool = false, allowOwnershipTransfer: Bool = false) {
            self.allowSharedFolder = allowSharedFolder
            self.autorename = autorename
            self.allowOwnershipTransfer = allowOwnershipTransfer
            super.init(fromPath: fromPath, toPath: toPath)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelocationArgSerializer().serialize(self)))"
        }
    }
    open class RelocationArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelocationArg) -> JSON {
            let output = [ 
            "from_path": Serialization._StringSerializer.serialize(value.fromPath),
            "to_path": Serialization._StringSerializer.serialize(value.toPath),
            "allow_shared_folder": Serialization._BoolSerializer.serialize(value.allowSharedFolder),
            "autorename": Serialization._BoolSerializer.serialize(value.autorename),
            "allow_ownership_transfer": Serialization._BoolSerializer.serialize(value.allowOwnershipTransfer),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RelocationArg {
            switch json {
                case .dictionary(let dict):
                    let fromPath = Serialization._StringSerializer.deserialize(dict["from_path"] ?? .null)
                    let toPath = Serialization._StringSerializer.deserialize(dict["to_path"] ?? .null)
                    let allowSharedFolder = Serialization._BoolSerializer.deserialize(dict["allow_shared_folder"] ?? .number(0))
                    let autorename = Serialization._BoolSerializer.deserialize(dict["autorename"] ?? .number(0))
                    let allowOwnershipTransfer = Serialization._BoolSerializer.deserialize(dict["allow_ownership_transfer"] ?? .number(0))
                    return RelocationArg(fromPath: fromPath, toPath: toPath, allowSharedFolder: allowSharedFolder, autorename: autorename, allowOwnershipTransfer: allowOwnershipTransfer)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RelocationBatchArg struct
    open class RelocationBatchArg: Files.RelocationBatchArgBase {
        /// If true, copyBatch will copy contents in shared folder, otherwise cantCopySharedFolder in RelocationError
        /// will be returned if fromPath in RelocationPath contains shared folder. This field is always true for
        /// moveBatch.
        public let allowSharedFolder: Bool
        /// Allow moves by owner even if it would result in an ownership transfer for the content being moved. This does
        /// not apply to copies.
        public let allowOwnershipTransfer: Bool
        public init(entries: Array<Files.RelocationPath>, autorename: Bool = false, allowSharedFolder: Bool = false, allowOwnershipTransfer: Bool = false) {
            self.allowSharedFolder = allowSharedFolder
            self.allowOwnershipTransfer = allowOwnershipTransfer
            super.init(entries: entries, autorename: autorename)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelocationBatchArgSerializer().serialize(self)))"
        }
    }
    open class RelocationBatchArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelocationBatchArg) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Files.RelocationPathSerializer()).serialize(value.entries),
            "autorename": Serialization._BoolSerializer.serialize(value.autorename),
            "allow_shared_folder": Serialization._BoolSerializer.serialize(value.allowSharedFolder),
            "allow_ownership_transfer": Serialization._BoolSerializer.serialize(value.allowOwnershipTransfer),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RelocationBatchArg {
            switch json {
                case .dictionary(let dict):
                    let entries = ArraySerializer(Files.RelocationPathSerializer()).deserialize(dict["entries"] ?? .null)
                    let autorename = Serialization._BoolSerializer.deserialize(dict["autorename"] ?? .number(0))
                    let allowSharedFolder = Serialization._BoolSerializer.deserialize(dict["allow_shared_folder"] ?? .number(0))
                    let allowOwnershipTransfer = Serialization._BoolSerializer.deserialize(dict["allow_ownership_transfer"] ?? .number(0))
                    return RelocationBatchArg(entries: entries, autorename: autorename, allowSharedFolder: allowSharedFolder, allowOwnershipTransfer: allowOwnershipTransfer)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RelocationError union
    public enum RelocationError: CustomStringConvertible {
        /// An unspecified error.
        case fromLookup(Files.LookupError)
        /// An unspecified error.
        case fromWrite(Files.WriteError)
        /// An unspecified error.
        case to(Files.WriteError)
        /// Shared folders can't be copied.
        case cantCopySharedFolder
        /// Your move operation would result in nested shared folders.  This is not allowed.
        case cantNestSharedFolder
        /// You cannot move a folder into itself.
        case cantMoveFolderIntoItself
        /// The operation would involve more than 10,000 files and folders.
        case tooManyFiles
        /// There are duplicated/nested paths among fromPath in RelocationArg and toPath in RelocationArg.
        case duplicatedOrNestedPaths
        /// Your move operation would result in an ownership transfer. You may reissue the request with the field
        /// allowOwnershipTransfer in RelocationArg to true.
        case cantTransferOwnership
        /// The current user does not have enough space to move or copy the files.
        case insufficientQuota
        /// Something went wrong with the job on Dropbox's end. You'll need to verify that the action you were taking
        /// succeeded, and if not, try again. This should happen very rarely.
        case internalError
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelocationErrorSerializer().serialize(self)))"
        }
    }
    open class RelocationErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelocationError) -> JSON {
            switch value {
                case .fromLookup(let arg):
                    var d = ["from_lookup": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("from_lookup")
                    return .dictionary(d)
                case .fromWrite(let arg):
                    var d = ["from_write": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("from_write")
                    return .dictionary(d)
                case .to(let arg):
                    var d = ["to": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("to")
                    return .dictionary(d)
                case .cantCopySharedFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("cant_copy_shared_folder")
                    return .dictionary(d)
                case .cantNestSharedFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("cant_nest_shared_folder")
                    return .dictionary(d)
                case .cantMoveFolderIntoItself:
                    var d = [String: JSON]()
                    d[".tag"] = .str("cant_move_folder_into_itself")
                    return .dictionary(d)
                case .tooManyFiles:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_files")
                    return .dictionary(d)
                case .duplicatedOrNestedPaths:
                    var d = [String: JSON]()
                    d[".tag"] = .str("duplicated_or_nested_paths")
                    return .dictionary(d)
                case .cantTransferOwnership:
                    var d = [String: JSON]()
                    d[".tag"] = .str("cant_transfer_ownership")
                    return .dictionary(d)
                case .insufficientQuota:
                    var d = [String: JSON]()
                    d[".tag"] = .str("insufficient_quota")
                    return .dictionary(d)
                case .internalError:
                    var d = [String: JSON]()
                    d[".tag"] = .str("internal_error")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> RelocationError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "from_lookup":
                            let v = Files.LookupErrorSerializer().deserialize(d["from_lookup"] ?? .null)
                            return RelocationError.fromLookup(v)
                        case "from_write":
                            let v = Files.WriteErrorSerializer().deserialize(d["from_write"] ?? .null)
                            return RelocationError.fromWrite(v)
                        case "to":
                            let v = Files.WriteErrorSerializer().deserialize(d["to"] ?? .null)
                            return RelocationError.to(v)
                        case "cant_copy_shared_folder":
                            return RelocationError.cantCopySharedFolder
                        case "cant_nest_shared_folder":
                            return RelocationError.cantNestSharedFolder
                        case "cant_move_folder_into_itself":
                            return RelocationError.cantMoveFolderIntoItself
                        case "too_many_files":
                            return RelocationError.tooManyFiles
                        case "duplicated_or_nested_paths":
                            return RelocationError.duplicatedOrNestedPaths
                        case "cant_transfer_ownership":
                            return RelocationError.cantTransferOwnership
                        case "insufficient_quota":
                            return RelocationError.insufficientQuota
                        case "internal_error":
                            return RelocationError.internalError
                        case "other":
                            return RelocationError.other
                        default:
                            return RelocationError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The RelocationBatchError union
    public enum RelocationBatchError: CustomStringConvertible {
        /// An unspecified error.
        case fromLookup(Files.LookupError)
        /// An unspecified error.
        case fromWrite(Files.WriteError)
        /// An unspecified error.
        case to(Files.WriteError)
        /// Shared folders can't be copied.
        case cantCopySharedFolder
        /// Your move operation would result in nested shared folders.  This is not allowed.
        case cantNestSharedFolder
        /// You cannot move a folder into itself.
        case cantMoveFolderIntoItself
        /// The operation would involve more than 10,000 files and folders.
        case tooManyFiles
        /// There are duplicated/nested paths among fromPath in RelocationArg and toPath in RelocationArg.
        case duplicatedOrNestedPaths
        /// Your move operation would result in an ownership transfer. You may reissue the request with the field
        /// allowOwnershipTransfer in RelocationArg to true.
        case cantTransferOwnership
        /// The current user does not have enough space to move or copy the files.
        case insufficientQuota
        /// Something went wrong with the job on Dropbox's end. You'll need to verify that the action you were taking
        /// succeeded, and if not, try again. This should happen very rarely.
        case internalError
        /// An unspecified error.
        case other
        /// There are too many write operations in user's Dropbox. Please retry this request.
        case tooManyWriteOperations

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelocationBatchErrorSerializer().serialize(self)))"
        }
    }
    open class RelocationBatchErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelocationBatchError) -> JSON {
            switch value {
                case .fromLookup(let arg):
                    var d = ["from_lookup": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("from_lookup")
                    return .dictionary(d)
                case .fromWrite(let arg):
                    var d = ["from_write": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("from_write")
                    return .dictionary(d)
                case .to(let arg):
                    var d = ["to": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("to")
                    return .dictionary(d)
                case .cantCopySharedFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("cant_copy_shared_folder")
                    return .dictionary(d)
                case .cantNestSharedFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("cant_nest_shared_folder")
                    return .dictionary(d)
                case .cantMoveFolderIntoItself:
                    var d = [String: JSON]()
                    d[".tag"] = .str("cant_move_folder_into_itself")
                    return .dictionary(d)
                case .tooManyFiles:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_files")
                    return .dictionary(d)
                case .duplicatedOrNestedPaths:
                    var d = [String: JSON]()
                    d[".tag"] = .str("duplicated_or_nested_paths")
                    return .dictionary(d)
                case .cantTransferOwnership:
                    var d = [String: JSON]()
                    d[".tag"] = .str("cant_transfer_ownership")
                    return .dictionary(d)
                case .insufficientQuota:
                    var d = [String: JSON]()
                    d[".tag"] = .str("insufficient_quota")
                    return .dictionary(d)
                case .internalError:
                    var d = [String: JSON]()
                    d[".tag"] = .str("internal_error")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .tooManyWriteOperations:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_write_operations")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> RelocationBatchError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "from_lookup":
                            let v = Files.LookupErrorSerializer().deserialize(d["from_lookup"] ?? .null)
                            return RelocationBatchError.fromLookup(v)
                        case "from_write":
                            let v = Files.WriteErrorSerializer().deserialize(d["from_write"] ?? .null)
                            return RelocationBatchError.fromWrite(v)
                        case "to":
                            let v = Files.WriteErrorSerializer().deserialize(d["to"] ?? .null)
                            return RelocationBatchError.to(v)
                        case "cant_copy_shared_folder":
                            return RelocationBatchError.cantCopySharedFolder
                        case "cant_nest_shared_folder":
                            return RelocationBatchError.cantNestSharedFolder
                        case "cant_move_folder_into_itself":
                            return RelocationBatchError.cantMoveFolderIntoItself
                        case "too_many_files":
                            return RelocationBatchError.tooManyFiles
                        case "duplicated_or_nested_paths":
                            return RelocationBatchError.duplicatedOrNestedPaths
                        case "cant_transfer_ownership":
                            return RelocationBatchError.cantTransferOwnership
                        case "insufficient_quota":
                            return RelocationBatchError.insufficientQuota
                        case "internal_error":
                            return RelocationBatchError.internalError
                        case "other":
                            return RelocationBatchError.other
                        case "too_many_write_operations":
                            return RelocationBatchError.tooManyWriteOperations
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The RelocationBatchErrorEntry union
    public enum RelocationBatchErrorEntry: CustomStringConvertible {
        /// User errors that retry won't help.
        case relocationError(Files.RelocationError)
        /// Something went wrong with the job on Dropbox's end. You'll need to verify that the action you were taking
        /// succeeded, and if not, try again. This should happen very rarely.
        case internalError
        /// There are too many write operations in user's Dropbox. Please retry this request.
        case tooManyWriteOperations
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelocationBatchErrorEntrySerializer().serialize(self)))"
        }
    }
    open class RelocationBatchErrorEntrySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelocationBatchErrorEntry) -> JSON {
            switch value {
                case .relocationError(let arg):
                    var d = ["relocation_error": Files.RelocationErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("relocation_error")
                    return .dictionary(d)
                case .internalError:
                    var d = [String: JSON]()
                    d[".tag"] = .str("internal_error")
                    return .dictionary(d)
                case .tooManyWriteOperations:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_write_operations")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> RelocationBatchErrorEntry {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "relocation_error":
                            let v = Files.RelocationErrorSerializer().deserialize(d["relocation_error"] ?? .null)
                            return RelocationBatchErrorEntry.relocationError(v)
                        case "internal_error":
                            return RelocationBatchErrorEntry.internalError
                        case "too_many_write_operations":
                            return RelocationBatchErrorEntry.tooManyWriteOperations
                        case "other":
                            return RelocationBatchErrorEntry.other
                        default:
                            return RelocationBatchErrorEntry.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The RelocationBatchJobStatus union
    public enum RelocationBatchJobStatus: CustomStringConvertible {
        /// The asynchronous job is still in progress.
        case inProgress
        /// The copy or move batch job has finished.
        case complete(Files.RelocationBatchResult)
        /// The copy or move batch job has failed with exception.
        case failed(Files.RelocationBatchError)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelocationBatchJobStatusSerializer().serialize(self)))"
        }
    }
    open class RelocationBatchJobStatusSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelocationBatchJobStatus) -> JSON {
            switch value {
                case .inProgress:
                    var d = [String: JSON]()
                    d[".tag"] = .str("in_progress")
                    return .dictionary(d)
                case .complete(let arg):
                    var d = Serialization.getFields(Files.RelocationBatchResultSerializer().serialize(arg))
                    d[".tag"] = .str("complete")
                    return .dictionary(d)
                case .failed(let arg):
                    var d = ["failed": Files.RelocationBatchErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("failed")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> RelocationBatchJobStatus {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "in_progress":
                            return RelocationBatchJobStatus.inProgress
                        case "complete":
                            let v = Files.RelocationBatchResultSerializer().deserialize(json)
                            return RelocationBatchJobStatus.complete(v)
                        case "failed":
                            let v = Files.RelocationBatchErrorSerializer().deserialize(d["failed"] ?? .null)
                            return RelocationBatchJobStatus.failed(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Result returned by copyBatch or moveBatch that may either launch an asynchronous job or complete synchronously.
    public enum RelocationBatchLaunch: CustomStringConvertible {
        /// This response indicates that the processing is asynchronous. The string is an id that can be used to obtain
        /// the status of the asynchronous job.
        case asyncJobId(String)
        /// An unspecified error.
        case complete(Files.RelocationBatchResult)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelocationBatchLaunchSerializer().serialize(self)))"
        }
    }
    open class RelocationBatchLaunchSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelocationBatchLaunch) -> JSON {
            switch value {
                case .asyncJobId(let arg):
                    var d = ["async_job_id": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("async_job_id")
                    return .dictionary(d)
                case .complete(let arg):
                    var d = Serialization.getFields(Files.RelocationBatchResultSerializer().serialize(arg))
                    d[".tag"] = .str("complete")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> RelocationBatchLaunch {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "async_job_id":
                            let v = Serialization._StringSerializer.deserialize(d["async_job_id"] ?? .null)
                            return RelocationBatchLaunch.asyncJobId(v)
                        case "complete":
                            let v = Files.RelocationBatchResultSerializer().deserialize(json)
                            return RelocationBatchLaunch.complete(v)
                        case "other":
                            return RelocationBatchLaunch.other
                        default:
                            return RelocationBatchLaunch.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The RelocationBatchResult struct
    open class RelocationBatchResult: Files.FileOpsResult {
        /// (no description)
        public let entries: Array<Files.RelocationBatchResultData>
        public init(entries: Array<Files.RelocationBatchResultData>) {
            self.entries = entries
            super.init()
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelocationBatchResultSerializer().serialize(self)))"
        }
    }
    open class RelocationBatchResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelocationBatchResult) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Files.RelocationBatchResultDataSerializer()).serialize(value.entries),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RelocationBatchResult {
            switch json {
                case .dictionary(let dict):
                    let entries = ArraySerializer(Files.RelocationBatchResultDataSerializer()).deserialize(dict["entries"] ?? .null)
                    return RelocationBatchResult(entries: entries)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RelocationBatchResultData struct
    open class RelocationBatchResultData: CustomStringConvertible {
        /// Metadata of the relocated object.
        public let metadata: Files.Metadata
        public init(metadata: Files.Metadata) {
            self.metadata = metadata
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelocationBatchResultDataSerializer().serialize(self)))"
        }
    }
    open class RelocationBatchResultDataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelocationBatchResultData) -> JSON {
            let output = [ 
            "metadata": Files.MetadataSerializer().serialize(value.metadata),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RelocationBatchResultData {
            switch json {
                case .dictionary(let dict):
                    let metadata = Files.MetadataSerializer().deserialize(dict["metadata"] ?? .null)
                    return RelocationBatchResultData(metadata: metadata)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RelocationBatchResultEntry union
    public enum RelocationBatchResultEntry: CustomStringConvertible {
        /// An unspecified error.
        case success(Files.Metadata)
        /// An unspecified error.
        case failure(Files.RelocationBatchErrorEntry)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelocationBatchResultEntrySerializer().serialize(self)))"
        }
    }
    open class RelocationBatchResultEntrySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelocationBatchResultEntry) -> JSON {
            switch value {
                case .success(let arg):
                    var d = ["success": Files.MetadataSerializer().serialize(arg)]
                    d[".tag"] = .str("success")
                    return .dictionary(d)
                case .failure(let arg):
                    var d = ["failure": Files.RelocationBatchErrorEntrySerializer().serialize(arg)]
                    d[".tag"] = .str("failure")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> RelocationBatchResultEntry {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "success":
                            let v = Files.MetadataSerializer().deserialize(d["success"] ?? .null)
                            return RelocationBatchResultEntry.success(v)
                        case "failure":
                            let v = Files.RelocationBatchErrorEntrySerializer().deserialize(d["failure"] ?? .null)
                            return RelocationBatchResultEntry.failure(v)
                        case "other":
                            return RelocationBatchResultEntry.other
                        default:
                            return RelocationBatchResultEntry.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Result returned by copyBatchV2 or moveBatchV2 that may either launch an asynchronous job or complete
    /// synchronously.
    public enum RelocationBatchV2JobStatus: CustomStringConvertible {
        /// The asynchronous job is still in progress.
        case inProgress
        /// The copy or move batch job has finished.
        case complete(Files.RelocationBatchV2Result)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelocationBatchV2JobStatusSerializer().serialize(self)))"
        }
    }
    open class RelocationBatchV2JobStatusSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelocationBatchV2JobStatus) -> JSON {
            switch value {
                case .inProgress:
                    var d = [String: JSON]()
                    d[".tag"] = .str("in_progress")
                    return .dictionary(d)
                case .complete(let arg):
                    var d = Serialization.getFields(Files.RelocationBatchV2ResultSerializer().serialize(arg))
                    d[".tag"] = .str("complete")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> RelocationBatchV2JobStatus {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "in_progress":
                            return RelocationBatchV2JobStatus.inProgress
                        case "complete":
                            let v = Files.RelocationBatchV2ResultSerializer().deserialize(json)
                            return RelocationBatchV2JobStatus.complete(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Result returned by copyBatchV2 or moveBatchV2 that may either launch an asynchronous job or complete
    /// synchronously.
    public enum RelocationBatchV2Launch: CustomStringConvertible {
        /// This response indicates that the processing is asynchronous. The string is an id that can be used to obtain
        /// the status of the asynchronous job.
        case asyncJobId(String)
        /// An unspecified error.
        case complete(Files.RelocationBatchV2Result)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelocationBatchV2LaunchSerializer().serialize(self)))"
        }
    }
    open class RelocationBatchV2LaunchSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelocationBatchV2Launch) -> JSON {
            switch value {
                case .asyncJobId(let arg):
                    var d = ["async_job_id": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("async_job_id")
                    return .dictionary(d)
                case .complete(let arg):
                    var d = Serialization.getFields(Files.RelocationBatchV2ResultSerializer().serialize(arg))
                    d[".tag"] = .str("complete")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> RelocationBatchV2Launch {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "async_job_id":
                            let v = Serialization._StringSerializer.deserialize(d["async_job_id"] ?? .null)
                            return RelocationBatchV2Launch.asyncJobId(v)
                        case "complete":
                            let v = Files.RelocationBatchV2ResultSerializer().deserialize(json)
                            return RelocationBatchV2Launch.complete(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The RelocationBatchV2Result struct
    open class RelocationBatchV2Result: Files.FileOpsResult {
        /// Each entry in CopyBatchArg.entries or entries in MoveBatchArg will appear at the same position inside
        /// entries in RelocationBatchV2Result.
        public let entries: Array<Files.RelocationBatchResultEntry>
        public init(entries: Array<Files.RelocationBatchResultEntry>) {
            self.entries = entries
            super.init()
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelocationBatchV2ResultSerializer().serialize(self)))"
        }
    }
    open class RelocationBatchV2ResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelocationBatchV2Result) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Files.RelocationBatchResultEntrySerializer()).serialize(value.entries),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RelocationBatchV2Result {
            switch json {
                case .dictionary(let dict):
                    let entries = ArraySerializer(Files.RelocationBatchResultEntrySerializer()).deserialize(dict["entries"] ?? .null)
                    return RelocationBatchV2Result(entries: entries)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RelocationResult struct
    open class RelocationResult: Files.FileOpsResult {
        /// Metadata of the relocated object.
        public let metadata: Files.Metadata
        public init(metadata: Files.Metadata) {
            self.metadata = metadata
            super.init()
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelocationResultSerializer().serialize(self)))"
        }
    }
    open class RelocationResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelocationResult) -> JSON {
            let output = [ 
            "metadata": Files.MetadataSerializer().serialize(value.metadata),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RelocationResult {
            switch json {
                case .dictionary(let dict):
                    let metadata = Files.MetadataSerializer().deserialize(dict["metadata"] ?? .null)
                    return RelocationResult(metadata: metadata)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RestoreArg struct
    open class RestoreArg: CustomStringConvertible {
        /// The path to save the restored file.
        public let path: String
        /// The revision to restore.
        public let rev: String
        public init(path: String, rev: String) {
            stringValidator(pattern: "(/(.|[\\r\\n])*)|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            stringValidator(minLength: 9, pattern: "[0-9a-f]+")(rev)
            self.rev = rev
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RestoreArgSerializer().serialize(self)))"
        }
    }
    open class RestoreArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RestoreArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "rev": Serialization._StringSerializer.serialize(value.rev),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RestoreArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let rev = Serialization._StringSerializer.deserialize(dict["rev"] ?? .null)
                    return RestoreArg(path: path, rev: rev)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RestoreError union
    public enum RestoreError: CustomStringConvertible {
        /// An error occurs when downloading metadata for the file.
        case pathLookup(Files.LookupError)
        /// An error occurs when trying to restore the file to that path.
        case pathWrite(Files.WriteError)
        /// The revision is invalid. It may not exist.
        case invalidRevision
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RestoreErrorSerializer().serialize(self)))"
        }
    }
    open class RestoreErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RestoreError) -> JSON {
            switch value {
                case .pathLookup(let arg):
                    var d = ["path_lookup": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path_lookup")
                    return .dictionary(d)
                case .pathWrite(let arg):
                    var d = ["path_write": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path_write")
                    return .dictionary(d)
                case .invalidRevision:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_revision")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> RestoreError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path_lookup":
                            let v = Files.LookupErrorSerializer().deserialize(d["path_lookup"] ?? .null)
                            return RestoreError.pathLookup(v)
                        case "path_write":
                            let v = Files.WriteErrorSerializer().deserialize(d["path_write"] ?? .null)
                            return RestoreError.pathWrite(v)
                        case "invalid_revision":
                            return RestoreError.invalidRevision
                        case "other":
                            return RestoreError.other
                        default:
                            return RestoreError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The SaveCopyReferenceArg struct
    open class SaveCopyReferenceArg: CustomStringConvertible {
        /// A copy reference returned by copyReferenceGet.
        public let copyReference: String
        /// Path in the user's Dropbox that is the destination.
        public let path: String
        public init(copyReference: String, path: String) {
            stringValidator()(copyReference)
            self.copyReference = copyReference
            stringValidator(pattern: "/(.|[\\r\\n])*")(path)
            self.path = path
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SaveCopyReferenceArgSerializer().serialize(self)))"
        }
    }
    open class SaveCopyReferenceArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SaveCopyReferenceArg) -> JSON {
            let output = [ 
            "copy_reference": Serialization._StringSerializer.serialize(value.copyReference),
            "path": Serialization._StringSerializer.serialize(value.path),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SaveCopyReferenceArg {
            switch json {
                case .dictionary(let dict):
                    let copyReference = Serialization._StringSerializer.deserialize(dict["copy_reference"] ?? .null)
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    return SaveCopyReferenceArg(copyReference: copyReference, path: path)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SaveCopyReferenceError union
    public enum SaveCopyReferenceError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.WriteError)
        /// The copy reference is invalid.
        case invalidCopyReference
        /// You don't have permission to save the given copy reference. Please make sure this app is same app which
        /// created the copy reference and the source user is still linked to the app.
        case noPermission
        /// The file referenced by the copy reference cannot be found.
        case notFound
        /// The operation would involve more than 10,000 files and folders.
        case tooManyFiles
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SaveCopyReferenceErrorSerializer().serialize(self)))"
        }
    }
    open class SaveCopyReferenceErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SaveCopyReferenceError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .invalidCopyReference:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_copy_reference")
                    return .dictionary(d)
                case .noPermission:
                    var d = [String: JSON]()
                    d[".tag"] = .str("no_permission")
                    return .dictionary(d)
                case .notFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_found")
                    return .dictionary(d)
                case .tooManyFiles:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_files")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SaveCopyReferenceError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.WriteErrorSerializer().deserialize(d["path"] ?? .null)
                            return SaveCopyReferenceError.path(v)
                        case "invalid_copy_reference":
                            return SaveCopyReferenceError.invalidCopyReference
                        case "no_permission":
                            return SaveCopyReferenceError.noPermission
                        case "not_found":
                            return SaveCopyReferenceError.notFound
                        case "too_many_files":
                            return SaveCopyReferenceError.tooManyFiles
                        case "other":
                            return SaveCopyReferenceError.other
                        default:
                            return SaveCopyReferenceError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The SaveCopyReferenceResult struct
    open class SaveCopyReferenceResult: CustomStringConvertible {
        /// The metadata of the saved file or folder in the user's Dropbox.
        public let metadata: Files.Metadata
        public init(metadata: Files.Metadata) {
            self.metadata = metadata
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SaveCopyReferenceResultSerializer().serialize(self)))"
        }
    }
    open class SaveCopyReferenceResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SaveCopyReferenceResult) -> JSON {
            let output = [ 
            "metadata": Files.MetadataSerializer().serialize(value.metadata),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SaveCopyReferenceResult {
            switch json {
                case .dictionary(let dict):
                    let metadata = Files.MetadataSerializer().deserialize(dict["metadata"] ?? .null)
                    return SaveCopyReferenceResult(metadata: metadata)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SaveUrlArg struct
    open class SaveUrlArg: CustomStringConvertible {
        /// The path in Dropbox where the URL will be saved to.
        public let path: String
        /// The URL to be saved.
        public let url: String
        public init(path: String, url: String) {
            stringValidator(pattern: "/(.|[\\r\\n])*")(path)
            self.path = path
            stringValidator()(url)
            self.url = url
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SaveUrlArgSerializer().serialize(self)))"
        }
    }
    open class SaveUrlArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SaveUrlArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "url": Serialization._StringSerializer.serialize(value.url),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SaveUrlArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .null)
                    return SaveUrlArg(path: path, url: url)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SaveUrlError union
    public enum SaveUrlError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.WriteError)
        /// Failed downloading the given URL.
        case downloadFailed
        /// The given URL is invalid.
        case invalidUrl
        /// The file where the URL is saved to no longer exists.
        case notFound
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SaveUrlErrorSerializer().serialize(self)))"
        }
    }
    open class SaveUrlErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SaveUrlError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .downloadFailed:
                    var d = [String: JSON]()
                    d[".tag"] = .str("download_failed")
                    return .dictionary(d)
                case .invalidUrl:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_url")
                    return .dictionary(d)
                case .notFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_found")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SaveUrlError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.WriteErrorSerializer().deserialize(d["path"] ?? .null)
                            return SaveUrlError.path(v)
                        case "download_failed":
                            return SaveUrlError.downloadFailed
                        case "invalid_url":
                            return SaveUrlError.invalidUrl
                        case "not_found":
                            return SaveUrlError.notFound
                        case "other":
                            return SaveUrlError.other
                        default:
                            return SaveUrlError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The SaveUrlJobStatus union
    public enum SaveUrlJobStatus: CustomStringConvertible {
        /// The asynchronous job is still in progress.
        case inProgress
        /// Metadata of the file where the URL is saved to.
        case complete(Files.FileMetadata)
        /// An unspecified error.
        case failed(Files.SaveUrlError)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SaveUrlJobStatusSerializer().serialize(self)))"
        }
    }
    open class SaveUrlJobStatusSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SaveUrlJobStatus) -> JSON {
            switch value {
                case .inProgress:
                    var d = [String: JSON]()
                    d[".tag"] = .str("in_progress")
                    return .dictionary(d)
                case .complete(let arg):
                    var d = Serialization.getFields(Files.FileMetadataSerializer().serialize(arg))
                    d[".tag"] = .str("complete")
                    return .dictionary(d)
                case .failed(let arg):
                    var d = ["failed": Files.SaveUrlErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("failed")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SaveUrlJobStatus {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "in_progress":
                            return SaveUrlJobStatus.inProgress
                        case "complete":
                            let v = Files.FileMetadataSerializer().deserialize(json)
                            return SaveUrlJobStatus.complete(v)
                        case "failed":
                            let v = Files.SaveUrlErrorSerializer().deserialize(d["failed"] ?? .null)
                            return SaveUrlJobStatus.failed(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The SaveUrlResult union
    public enum SaveUrlResult: CustomStringConvertible {
        /// This response indicates that the processing is asynchronous. The string is an id that can be used to obtain
        /// the status of the asynchronous job.
        case asyncJobId(String)
        /// Metadata of the file where the URL is saved to.
        case complete(Files.FileMetadata)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SaveUrlResultSerializer().serialize(self)))"
        }
    }
    open class SaveUrlResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SaveUrlResult) -> JSON {
            switch value {
                case .asyncJobId(let arg):
                    var d = ["async_job_id": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("async_job_id")
                    return .dictionary(d)
                case .complete(let arg):
                    var d = Serialization.getFields(Files.FileMetadataSerializer().serialize(arg))
                    d[".tag"] = .str("complete")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SaveUrlResult {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "async_job_id":
                            let v = Serialization._StringSerializer.deserialize(d["async_job_id"] ?? .null)
                            return SaveUrlResult.asyncJobId(v)
                        case "complete":
                            let v = Files.FileMetadataSerializer().deserialize(json)
                            return SaveUrlResult.complete(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The SearchArg struct
    open class SearchArg: CustomStringConvertible {
        /// The path in the user's Dropbox to search. Should probably be a folder.
        public let path: String
        /// The string to search for. The search string is split on spaces into multiple tokens. For file name
        /// searching, the last token is used for prefix matching (i.e. "bat c" matches "bat cave" but not "batman
        /// car").
        public let query: String
        /// The starting index within the search results (used for paging).
        public let start: UInt64
        /// The maximum number of search results to return.
        public let maxResults: UInt64
        /// The search mode (filename, filename_and_content, or deleted_filename). Note that searching file content is
        /// only available for Dropbox Business accounts.
        public let mode: Files.SearchMode
        public init(path: String, query: String, start: UInt64 = 0, maxResults: UInt64 = 100, mode: Files.SearchMode = .filename) {
            stringValidator(pattern: "(/(.|[\\r\\n])*)?|id:.*|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            stringValidator()(query)
            self.query = query
            comparableValidator()(start)
            self.start = start
            comparableValidator(minValue: 1, maxValue: 1000)(maxResults)
            self.maxResults = maxResults
            self.mode = mode
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SearchArgSerializer().serialize(self)))"
        }
    }
    open class SearchArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SearchArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "query": Serialization._StringSerializer.serialize(value.query),
            "start": Serialization._UInt64Serializer.serialize(value.start),
            "max_results": Serialization._UInt64Serializer.serialize(value.maxResults),
            "mode": Files.SearchModeSerializer().serialize(value.mode),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SearchArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let query = Serialization._StringSerializer.deserialize(dict["query"] ?? .null)
                    let start = Serialization._UInt64Serializer.deserialize(dict["start"] ?? .number(0))
                    let maxResults = Serialization._UInt64Serializer.deserialize(dict["max_results"] ?? .number(100))
                    let mode = Files.SearchModeSerializer().deserialize(dict["mode"] ?? Files.SearchModeSerializer().serialize(.filename))
                    return SearchArg(path: path, query: query, start: start, maxResults: maxResults, mode: mode)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SearchError union
    public enum SearchError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.LookupError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SearchErrorSerializer().serialize(self)))"
        }
    }
    open class SearchErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SearchError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SearchError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return SearchError.path(v)
                        case "other":
                            return SearchError.other
                        default:
                            return SearchError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The SearchMatch struct
    open class SearchMatch: CustomStringConvertible {
        /// The type of the match.
        public let matchType: Files.SearchMatchType
        /// The metadata for the matched file or folder.
        public let metadata: Files.Metadata
        public init(matchType: Files.SearchMatchType, metadata: Files.Metadata) {
            self.matchType = matchType
            self.metadata = metadata
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SearchMatchSerializer().serialize(self)))"
        }
    }
    open class SearchMatchSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SearchMatch) -> JSON {
            let output = [ 
            "match_type": Files.SearchMatchTypeSerializer().serialize(value.matchType),
            "metadata": Files.MetadataSerializer().serialize(value.metadata),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SearchMatch {
            switch json {
                case .dictionary(let dict):
                    let matchType = Files.SearchMatchTypeSerializer().deserialize(dict["match_type"] ?? .null)
                    let metadata = Files.MetadataSerializer().deserialize(dict["metadata"] ?? .null)
                    return SearchMatch(matchType: matchType, metadata: metadata)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Indicates what type of match was found for a given item.
    public enum SearchMatchType: CustomStringConvertible {
        /// This item was matched on its file or folder name.
        case filename
        /// This item was matched based on its file contents.
        case content
        /// This item was matched based on both its contents and its file name.
        case both

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SearchMatchTypeSerializer().serialize(self)))"
        }
    }
    open class SearchMatchTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SearchMatchType) -> JSON {
            switch value {
                case .filename:
                    var d = [String: JSON]()
                    d[".tag"] = .str("filename")
                    return .dictionary(d)
                case .content:
                    var d = [String: JSON]()
                    d[".tag"] = .str("content")
                    return .dictionary(d)
                case .both:
                    var d = [String: JSON]()
                    d[".tag"] = .str("both")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SearchMatchType {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "filename":
                            return SearchMatchType.filename
                        case "content":
                            return SearchMatchType.content
                        case "both":
                            return SearchMatchType.both
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The SearchMode union
    public enum SearchMode: CustomStringConvertible {
        /// Search file and folder names.
        case filename
        /// Search file and folder names as well as file contents.
        case filenameAndContent
        /// Search for deleted file and folder names.
        case deletedFilename

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SearchModeSerializer().serialize(self)))"
        }
    }
    open class SearchModeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SearchMode) -> JSON {
            switch value {
                case .filename:
                    var d = [String: JSON]()
                    d[".tag"] = .str("filename")
                    return .dictionary(d)
                case .filenameAndContent:
                    var d = [String: JSON]()
                    d[".tag"] = .str("filename_and_content")
                    return .dictionary(d)
                case .deletedFilename:
                    var d = [String: JSON]()
                    d[".tag"] = .str("deleted_filename")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SearchMode {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "filename":
                            return SearchMode.filename
                        case "filename_and_content":
                            return SearchMode.filenameAndContent
                        case "deleted_filename":
                            return SearchMode.deletedFilename
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The SearchResult struct
    open class SearchResult: CustomStringConvertible {
        /// A list (possibly empty) of matches for the query.
        public let matches: Array<Files.SearchMatch>
        /// Used for paging. If true, indicates there is another page of results available that can be fetched by
        /// calling search again.
        public let more: Bool
        /// Used for paging. Value to set the start argument to when calling search to fetch the next page of results.
        public let start: UInt64
        public init(matches: Array<Files.SearchMatch>, more: Bool, start: UInt64) {
            self.matches = matches
            self.more = more
            comparableValidator()(start)
            self.start = start
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SearchResultSerializer().serialize(self)))"
        }
    }
    open class SearchResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SearchResult) -> JSON {
            let output = [ 
            "matches": ArraySerializer(Files.SearchMatchSerializer()).serialize(value.matches),
            "more": Serialization._BoolSerializer.serialize(value.more),
            "start": Serialization._UInt64Serializer.serialize(value.start),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SearchResult {
            switch json {
                case .dictionary(let dict):
                    let matches = ArraySerializer(Files.SearchMatchSerializer()).deserialize(dict["matches"] ?? .null)
                    let more = Serialization._BoolSerializer.deserialize(dict["more"] ?? .null)
                    let start = Serialization._UInt64Serializer.deserialize(dict["start"] ?? .null)
                    return SearchResult(matches: matches, more: more, start: start)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedLink struct
    open class SharedLink: CustomStringConvertible {
        /// Shared link url.
        public let url: String
        /// Password for the shared link.
        public let password: String?
        public init(url: String, password: String? = nil) {
            stringValidator()(url)
            self.url = url
            nullableValidator(stringValidator())(password)
            self.password = password
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedLinkSerializer().serialize(self)))"
        }
    }
    open class SharedLinkSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedLink) -> JSON {
            let output = [ 
            "url": Serialization._StringSerializer.serialize(value.url),
            "password": NullableSerializer(Serialization._StringSerializer).serialize(value.password),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedLink {
            switch json {
                case .dictionary(let dict):
                    let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .null)
                    let password = NullableSerializer(Serialization._StringSerializer).deserialize(dict["password"] ?? .null)
                    return SharedLink(url: url, password: password)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SymlinkInfo struct
    open class SymlinkInfo: CustomStringConvertible {
        /// The target this symlink points to.
        public let target: String
        public init(target: String) {
            stringValidator()(target)
            self.target = target
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SymlinkInfoSerializer().serialize(self)))"
        }
    }
    open class SymlinkInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SymlinkInfo) -> JSON {
            let output = [ 
            "target": Serialization._StringSerializer.serialize(value.target),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SymlinkInfo {
            switch json {
                case .dictionary(let dict):
                    let target = Serialization._StringSerializer.deserialize(dict["target"] ?? .null)
                    return SymlinkInfo(target: target)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SyncSetting union
    public enum SyncSetting: CustomStringConvertible {
        /// On first sync to members' computers, the specified folder will follow its parent folder's setting or
        /// otherwise follow default sync behavior.
        case default_
        /// On first sync to members' computers, the specified folder will be set to not sync with selective sync.
        case notSynced
        /// The specified folder's not_synced setting is inactive due to its location or other configuration changes. It
        /// will follow its parent folder's setting.
        case notSyncedInactive
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SyncSettingSerializer().serialize(self)))"
        }
    }
    open class SyncSettingSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SyncSetting) -> JSON {
            switch value {
                case .default_:
                    var d = [String: JSON]()
                    d[".tag"] = .str("default")
                    return .dictionary(d)
                case .notSynced:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_synced")
                    return .dictionary(d)
                case .notSyncedInactive:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_synced_inactive")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SyncSetting {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "default":
                            return SyncSetting.default_
                        case "not_synced":
                            return SyncSetting.notSynced
                        case "not_synced_inactive":
                            return SyncSetting.notSyncedInactive
                        case "other":
                            return SyncSetting.other
                        default:
                            return SyncSetting.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The SyncSettingArg union
    public enum SyncSettingArg: CustomStringConvertible {
        /// On first sync to members' computers, the specified folder will follow its parent folder's setting or
        /// otherwise follow default sync behavior.
        case default_
        /// On first sync to members' computers, the specified folder will be set to not sync with selective sync.
        case notSynced
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SyncSettingArgSerializer().serialize(self)))"
        }
    }
    open class SyncSettingArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SyncSettingArg) -> JSON {
            switch value {
                case .default_:
                    var d = [String: JSON]()
                    d[".tag"] = .str("default")
                    return .dictionary(d)
                case .notSynced:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_synced")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SyncSettingArg {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "default":
                            return SyncSettingArg.default_
                        case "not_synced":
                            return SyncSettingArg.notSynced
                        case "other":
                            return SyncSettingArg.other
                        default:
                            return SyncSettingArg.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The SyncSettingsError union
    public enum SyncSettingsError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.LookupError)
        /// Setting this combination of sync settings simultaneously is not supported.
        case unsupportedCombination
        /// The specified configuration is not supported.
        case unsupportedConfiguration
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SyncSettingsErrorSerializer().serialize(self)))"
        }
    }
    open class SyncSettingsErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SyncSettingsError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .unsupportedCombination:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unsupported_combination")
                    return .dictionary(d)
                case .unsupportedConfiguration:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unsupported_configuration")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SyncSettingsError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return SyncSettingsError.path(v)
                        case "unsupported_combination":
                            return SyncSettingsError.unsupportedCombination
                        case "unsupported_configuration":
                            return SyncSettingsError.unsupportedConfiguration
                        case "other":
                            return SyncSettingsError.other
                        default:
                            return SyncSettingsError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ThumbnailArg struct
    open class ThumbnailArg: CustomStringConvertible {
        /// The path to the image file you want to thumbnail.
        public let path: String
        /// The format for the thumbnail image, jpeg (default) or png. For  images that are photos, jpeg should be
        /// preferred, while png is  better for screenshots and digital arts.
        public let format: Files.ThumbnailFormat
        /// The size for the thumbnail image.
        public let size: Files.ThumbnailSize
        /// How to resize and crop the image to achieve the desired size.
        public let mode: Files.ThumbnailMode
        public init(path: String, format: Files.ThumbnailFormat = .jpeg, size: Files.ThumbnailSize = .w64h64, mode: Files.ThumbnailMode = .strict) {
            stringValidator(pattern: "(/(.|[\\r\\n])*|id:.*)|(rev:[0-9a-f]{9,})|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            self.format = format
            self.size = size
            self.mode = mode
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ThumbnailArgSerializer().serialize(self)))"
        }
    }
    open class ThumbnailArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ThumbnailArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "format": Files.ThumbnailFormatSerializer().serialize(value.format),
            "size": Files.ThumbnailSizeSerializer().serialize(value.size),
            "mode": Files.ThumbnailModeSerializer().serialize(value.mode),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ThumbnailArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let format = Files.ThumbnailFormatSerializer().deserialize(dict["format"] ?? Files.ThumbnailFormatSerializer().serialize(.jpeg))
                    let size = Files.ThumbnailSizeSerializer().deserialize(dict["size"] ?? Files.ThumbnailSizeSerializer().serialize(.w64h64))
                    let mode = Files.ThumbnailModeSerializer().deserialize(dict["mode"] ?? Files.ThumbnailModeSerializer().serialize(.strict))
                    return ThumbnailArg(path: path, format: format, size: size, mode: mode)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ThumbnailError union
    public enum ThumbnailError: CustomStringConvertible {
        /// An error occurs when downloading metadata for the image.
        case path(Files.LookupError)
        /// The file extension doesn't allow conversion to a thumbnail.
        case unsupportedExtension
        /// The image cannot be converted to a thumbnail.
        case unsupportedImage
        /// An error occurs during thumbnail conversion.
        case conversionError

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ThumbnailErrorSerializer().serialize(self)))"
        }
    }
    open class ThumbnailErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ThumbnailError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .unsupportedExtension:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unsupported_extension")
                    return .dictionary(d)
                case .unsupportedImage:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unsupported_image")
                    return .dictionary(d)
                case .conversionError:
                    var d = [String: JSON]()
                    d[".tag"] = .str("conversion_error")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ThumbnailError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return ThumbnailError.path(v)
                        case "unsupported_extension":
                            return ThumbnailError.unsupportedExtension
                        case "unsupported_image":
                            return ThumbnailError.unsupportedImage
                        case "conversion_error":
                            return ThumbnailError.conversionError
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ThumbnailFormat union
    public enum ThumbnailFormat: CustomStringConvertible {
        /// An unspecified error.
        case jpeg
        /// An unspecified error.
        case png

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ThumbnailFormatSerializer().serialize(self)))"
        }
    }
    open class ThumbnailFormatSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ThumbnailFormat) -> JSON {
            switch value {
                case .jpeg:
                    var d = [String: JSON]()
                    d[".tag"] = .str("jpeg")
                    return .dictionary(d)
                case .png:
                    var d = [String: JSON]()
                    d[".tag"] = .str("png")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ThumbnailFormat {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "jpeg":
                            return ThumbnailFormat.jpeg
                        case "png":
                            return ThumbnailFormat.png
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ThumbnailMode union
    public enum ThumbnailMode: CustomStringConvertible {
        /// Scale down the image to fit within the given size.
        case strict
        /// Scale down the image to fit within the given size or its transpose.
        case bestfit
        /// Scale down the image to completely cover the given size or its transpose.
        case fitoneBestfit

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ThumbnailModeSerializer().serialize(self)))"
        }
    }
    open class ThumbnailModeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ThumbnailMode) -> JSON {
            switch value {
                case .strict:
                    var d = [String: JSON]()
                    d[".tag"] = .str("strict")
                    return .dictionary(d)
                case .bestfit:
                    var d = [String: JSON]()
                    d[".tag"] = .str("bestfit")
                    return .dictionary(d)
                case .fitoneBestfit:
                    var d = [String: JSON]()
                    d[".tag"] = .str("fitone_bestfit")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ThumbnailMode {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "strict":
                            return ThumbnailMode.strict
                        case "bestfit":
                            return ThumbnailMode.bestfit
                        case "fitone_bestfit":
                            return ThumbnailMode.fitoneBestfit
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ThumbnailSize union
    public enum ThumbnailSize: CustomStringConvertible {
        /// 32 by 32 px.
        case w32h32
        /// 64 by 64 px.
        case w64h64
        /// 128 by 128 px.
        case w128h128
        /// 256 by 256 px.
        case w256h256
        /// 480 by 320 px.
        case w480h320
        /// 640 by 480 px.
        case w640h480
        /// 960 by 640 px.
        case w960h640
        /// 1024 by 768 px.
        case w1024h768
        /// 2048 by 1536 px.
        case w2048h1536

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ThumbnailSizeSerializer().serialize(self)))"
        }
    }
    open class ThumbnailSizeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ThumbnailSize) -> JSON {
            switch value {
                case .w32h32:
                    var d = [String: JSON]()
                    d[".tag"] = .str("w32h32")
                    return .dictionary(d)
                case .w64h64:
                    var d = [String: JSON]()
                    d[".tag"] = .str("w64h64")
                    return .dictionary(d)
                case .w128h128:
                    var d = [String: JSON]()
                    d[".tag"] = .str("w128h128")
                    return .dictionary(d)
                case .w256h256:
                    var d = [String: JSON]()
                    d[".tag"] = .str("w256h256")
                    return .dictionary(d)
                case .w480h320:
                    var d = [String: JSON]()
                    d[".tag"] = .str("w480h320")
                    return .dictionary(d)
                case .w640h480:
                    var d = [String: JSON]()
                    d[".tag"] = .str("w640h480")
                    return .dictionary(d)
                case .w960h640:
                    var d = [String: JSON]()
                    d[".tag"] = .str("w960h640")
                    return .dictionary(d)
                case .w1024h768:
                    var d = [String: JSON]()
                    d[".tag"] = .str("w1024h768")
                    return .dictionary(d)
                case .w2048h1536:
                    var d = [String: JSON]()
                    d[".tag"] = .str("w2048h1536")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ThumbnailSize {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "w32h32":
                            return ThumbnailSize.w32h32
                        case "w64h64":
                            return ThumbnailSize.w64h64
                        case "w128h128":
                            return ThumbnailSize.w128h128
                        case "w256h256":
                            return ThumbnailSize.w256h256
                        case "w480h320":
                            return ThumbnailSize.w480h320
                        case "w640h480":
                            return ThumbnailSize.w640h480
                        case "w960h640":
                            return ThumbnailSize.w960h640
                        case "w1024h768":
                            return ThumbnailSize.w1024h768
                        case "w2048h1536":
                            return ThumbnailSize.w2048h1536
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The UploadError union
    public enum UploadError: CustomStringConvertible {
        /// Unable to save the uploaded contents to a file.
        case path(Files.UploadWriteFailed)
        /// The supplied property group is invalid. The file has uploaded without property groups.
        case propertiesError(FileProperties.InvalidPropertyGroupError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadErrorSerializer().serialize(self)))"
        }
    }
    open class UploadErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = Serialization.getFields(Files.UploadWriteFailedSerializer().serialize(arg))
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .propertiesError(let arg):
                    var d = ["properties_error": FileProperties.InvalidPropertyGroupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("properties_error")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> UploadError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.UploadWriteFailedSerializer().deserialize(json)
                            return UploadError.path(v)
                        case "properties_error":
                            let v = FileProperties.InvalidPropertyGroupErrorSerializer().deserialize(d["properties_error"] ?? .null)
                            return UploadError.propertiesError(v)
                        case "other":
                            return UploadError.other
                        default:
                            return UploadError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The UploadErrorWithProperties union
    public enum UploadErrorWithProperties: CustomStringConvertible {
        /// Unable to save the uploaded contents to a file.
        case path(Files.UploadWriteFailed)
        /// The supplied property group is invalid. The file has uploaded without property groups.
        case propertiesError(FileProperties.InvalidPropertyGroupError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadErrorWithPropertiesSerializer().serialize(self)))"
        }
    }
    open class UploadErrorWithPropertiesSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadErrorWithProperties) -> JSON {
            switch value {
                case .path(let arg):
                    var d = Serialization.getFields(Files.UploadWriteFailedSerializer().serialize(arg))
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .propertiesError(let arg):
                    var d = ["properties_error": FileProperties.InvalidPropertyGroupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("properties_error")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> UploadErrorWithProperties {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.UploadWriteFailedSerializer().deserialize(json)
                            return UploadErrorWithProperties.path(v)
                        case "properties_error":
                            let v = FileProperties.InvalidPropertyGroupErrorSerializer().deserialize(d["properties_error"] ?? .null)
                            return UploadErrorWithProperties.propertiesError(v)
                        case "other":
                            return UploadErrorWithProperties.other
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The UploadSessionAppendArg struct
    open class UploadSessionAppendArg: CustomStringConvertible {
        /// Contains the upload session ID and the offset.
        public let cursor: Files.UploadSessionCursor
        /// If true, the current session will be closed, at which point you won't be able to call uploadSessionAppendV2
        /// anymore with the current session.
        public let close: Bool
        public init(cursor: Files.UploadSessionCursor, close: Bool = false) {
            self.cursor = cursor
            self.close = close
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionAppendArgSerializer().serialize(self)))"
        }
    }
    open class UploadSessionAppendArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadSessionAppendArg) -> JSON {
            let output = [ 
            "cursor": Files.UploadSessionCursorSerializer().serialize(value.cursor),
            "close": Serialization._BoolSerializer.serialize(value.close),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UploadSessionAppendArg {
            switch json {
                case .dictionary(let dict):
                    let cursor = Files.UploadSessionCursorSerializer().deserialize(dict["cursor"] ?? .null)
                    let close = Serialization._BoolSerializer.deserialize(dict["close"] ?? .number(0))
                    return UploadSessionAppendArg(cursor: cursor, close: close)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UploadSessionCursor struct
    open class UploadSessionCursor: CustomStringConvertible {
        /// The upload session ID (returned by uploadSessionStart).
        public let sessionId: String
        /// The amount of data that has been uploaded so far. We use this to make sure upload data isn't lost or
        /// duplicated in the event of a network error.
        public let offset: UInt64
        public init(sessionId: String, offset: UInt64) {
            stringValidator()(sessionId)
            self.sessionId = sessionId
            comparableValidator()(offset)
            self.offset = offset
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionCursorSerializer().serialize(self)))"
        }
    }
    open class UploadSessionCursorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadSessionCursor) -> JSON {
            let output = [ 
            "session_id": Serialization._StringSerializer.serialize(value.sessionId),
            "offset": Serialization._UInt64Serializer.serialize(value.offset),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UploadSessionCursor {
            switch json {
                case .dictionary(let dict):
                    let sessionId = Serialization._StringSerializer.deserialize(dict["session_id"] ?? .null)
                    let offset = Serialization._UInt64Serializer.deserialize(dict["offset"] ?? .null)
                    return UploadSessionCursor(sessionId: sessionId, offset: offset)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UploadSessionFinishArg struct
    open class UploadSessionFinishArg: CustomStringConvertible {
        /// Contains the upload session ID and the offset.
        public let cursor: Files.UploadSessionCursor
        /// Contains the path and other optional modifiers for the commit.
        public let commit: Files.CommitInfo
        public init(cursor: Files.UploadSessionCursor, commit: Files.CommitInfo) {
            self.cursor = cursor
            self.commit = commit
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionFinishArgSerializer().serialize(self)))"
        }
    }
    open class UploadSessionFinishArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadSessionFinishArg) -> JSON {
            let output = [ 
            "cursor": Files.UploadSessionCursorSerializer().serialize(value.cursor),
            "commit": Files.CommitInfoSerializer().serialize(value.commit),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UploadSessionFinishArg {
            switch json {
                case .dictionary(let dict):
                    let cursor = Files.UploadSessionCursorSerializer().deserialize(dict["cursor"] ?? .null)
                    let commit = Files.CommitInfoSerializer().deserialize(dict["commit"] ?? .null)
                    return UploadSessionFinishArg(cursor: cursor, commit: commit)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UploadSessionFinishBatchArg struct
    open class UploadSessionFinishBatchArg: CustomStringConvertible {
        /// Commit information for each file in the batch.
        public let entries: Array<Files.UploadSessionFinishArg>
        public init(entries: Array<Files.UploadSessionFinishArg>) {
            self.entries = entries
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionFinishBatchArgSerializer().serialize(self)))"
        }
    }
    open class UploadSessionFinishBatchArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadSessionFinishBatchArg) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Files.UploadSessionFinishArgSerializer()).serialize(value.entries),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UploadSessionFinishBatchArg {
            switch json {
                case .dictionary(let dict):
                    let entries = ArraySerializer(Files.UploadSessionFinishArgSerializer()).deserialize(dict["entries"] ?? .null)
                    return UploadSessionFinishBatchArg(entries: entries)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UploadSessionFinishBatchJobStatus union
    public enum UploadSessionFinishBatchJobStatus: CustomStringConvertible {
        /// The asynchronous job is still in progress.
        case inProgress
        /// The uploadSessionFinishBatch has finished.
        case complete(Files.UploadSessionFinishBatchResult)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionFinishBatchJobStatusSerializer().serialize(self)))"
        }
    }
    open class UploadSessionFinishBatchJobStatusSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadSessionFinishBatchJobStatus) -> JSON {
            switch value {
                case .inProgress:
                    var d = [String: JSON]()
                    d[".tag"] = .str("in_progress")
                    return .dictionary(d)
                case .complete(let arg):
                    var d = Serialization.getFields(Files.UploadSessionFinishBatchResultSerializer().serialize(arg))
                    d[".tag"] = .str("complete")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> UploadSessionFinishBatchJobStatus {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "in_progress":
                            return UploadSessionFinishBatchJobStatus.inProgress
                        case "complete":
                            let v = Files.UploadSessionFinishBatchResultSerializer().deserialize(json)
                            return UploadSessionFinishBatchJobStatus.complete(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Result returned by uploadSessionFinishBatch that may either launch an asynchronous job or complete
    /// synchronously.
    public enum UploadSessionFinishBatchLaunch: CustomStringConvertible {
        /// This response indicates that the processing is asynchronous. The string is an id that can be used to obtain
        /// the status of the asynchronous job.
        case asyncJobId(String)
        /// An unspecified error.
        case complete(Files.UploadSessionFinishBatchResult)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionFinishBatchLaunchSerializer().serialize(self)))"
        }
    }
    open class UploadSessionFinishBatchLaunchSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadSessionFinishBatchLaunch) -> JSON {
            switch value {
                case .asyncJobId(let arg):
                    var d = ["async_job_id": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("async_job_id")
                    return .dictionary(d)
                case .complete(let arg):
                    var d = Serialization.getFields(Files.UploadSessionFinishBatchResultSerializer().serialize(arg))
                    d[".tag"] = .str("complete")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> UploadSessionFinishBatchLaunch {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "async_job_id":
                            let v = Serialization._StringSerializer.deserialize(d["async_job_id"] ?? .null)
                            return UploadSessionFinishBatchLaunch.asyncJobId(v)
                        case "complete":
                            let v = Files.UploadSessionFinishBatchResultSerializer().deserialize(json)
                            return UploadSessionFinishBatchLaunch.complete(v)
                        case "other":
                            return UploadSessionFinishBatchLaunch.other
                        default:
                            return UploadSessionFinishBatchLaunch.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The UploadSessionFinishBatchResult struct
    open class UploadSessionFinishBatchResult: CustomStringConvertible {
        /// Each entry in entries in UploadSessionFinishBatchArg will appear at the same position inside entries in
        /// UploadSessionFinishBatchResult.
        public let entries: Array<Files.UploadSessionFinishBatchResultEntry>
        public init(entries: Array<Files.UploadSessionFinishBatchResultEntry>) {
            self.entries = entries
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionFinishBatchResultSerializer().serialize(self)))"
        }
    }
    open class UploadSessionFinishBatchResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadSessionFinishBatchResult) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Files.UploadSessionFinishBatchResultEntrySerializer()).serialize(value.entries),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UploadSessionFinishBatchResult {
            switch json {
                case .dictionary(let dict):
                    let entries = ArraySerializer(Files.UploadSessionFinishBatchResultEntrySerializer()).deserialize(dict["entries"] ?? .null)
                    return UploadSessionFinishBatchResult(entries: entries)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UploadSessionFinishBatchResultEntry union
    public enum UploadSessionFinishBatchResultEntry: CustomStringConvertible {
        /// An unspecified error.
        case success(Files.FileMetadata)
        /// An unspecified error.
        case failure(Files.UploadSessionFinishError)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionFinishBatchResultEntrySerializer().serialize(self)))"
        }
    }
    open class UploadSessionFinishBatchResultEntrySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadSessionFinishBatchResultEntry) -> JSON {
            switch value {
                case .success(let arg):
                    var d = Serialization.getFields(Files.FileMetadataSerializer().serialize(arg))
                    d[".tag"] = .str("success")
                    return .dictionary(d)
                case .failure(let arg):
                    var d = ["failure": Files.UploadSessionFinishErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("failure")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> UploadSessionFinishBatchResultEntry {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "success":
                            let v = Files.FileMetadataSerializer().deserialize(json)
                            return UploadSessionFinishBatchResultEntry.success(v)
                        case "failure":
                            let v = Files.UploadSessionFinishErrorSerializer().deserialize(d["failure"] ?? .null)
                            return UploadSessionFinishBatchResultEntry.failure(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The UploadSessionFinishError union
    public enum UploadSessionFinishError: CustomStringConvertible {
        /// The session arguments are incorrect; the value explains the reason.
        case lookupFailed(Files.UploadSessionLookupError)
        /// Unable to save the uploaded contents to a file. Data has already been appended to the upload session. Please
        /// retry with empty data body and updated offset.
        case path(Files.WriteError)
        /// The supplied property group is invalid. The file has uploaded without property groups.
        case propertiesError(FileProperties.InvalidPropertyGroupError)
        /// The batch request commits files into too many different shared folders. Please limit your batch request to
        /// files contained in a single shared folder.
        case tooManySharedFolderTargets
        /// There are too many write operations happening in the user's Dropbox. You should retry uploading this file.
        case tooManyWriteOperations
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionFinishErrorSerializer().serialize(self)))"
        }
    }
    open class UploadSessionFinishErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadSessionFinishError) -> JSON {
            switch value {
                case .lookupFailed(let arg):
                    var d = ["lookup_failed": Files.UploadSessionLookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("lookup_failed")
                    return .dictionary(d)
                case .path(let arg):
                    var d = ["path": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .propertiesError(let arg):
                    var d = ["properties_error": FileProperties.InvalidPropertyGroupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("properties_error")
                    return .dictionary(d)
                case .tooManySharedFolderTargets:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_shared_folder_targets")
                    return .dictionary(d)
                case .tooManyWriteOperations:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_write_operations")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> UploadSessionFinishError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "lookup_failed":
                            let v = Files.UploadSessionLookupErrorSerializer().deserialize(d["lookup_failed"] ?? .null)
                            return UploadSessionFinishError.lookupFailed(v)
                        case "path":
                            let v = Files.WriteErrorSerializer().deserialize(d["path"] ?? .null)
                            return UploadSessionFinishError.path(v)
                        case "properties_error":
                            let v = FileProperties.InvalidPropertyGroupErrorSerializer().deserialize(d["properties_error"] ?? .null)
                            return UploadSessionFinishError.propertiesError(v)
                        case "too_many_shared_folder_targets":
                            return UploadSessionFinishError.tooManySharedFolderTargets
                        case "too_many_write_operations":
                            return UploadSessionFinishError.tooManyWriteOperations
                        case "other":
                            return UploadSessionFinishError.other
                        default:
                            return UploadSessionFinishError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The UploadSessionLookupError union
    public enum UploadSessionLookupError: CustomStringConvertible {
        /// The upload session ID was not found or has expired. Upload sessions are valid for 48 hours.
        case notFound
        /// The specified offset was incorrect. See the value for the correct offset. This error may occur when a
        /// previous request was received and processed successfully but the client did not receive the response, e.g.
        /// due to a network error.
        case incorrectOffset(Files.UploadSessionOffsetError)
        /// You are attempting to append data to an upload session that has alread been closed (i.e. committed).
        case closed
        /// The session must be closed before calling upload_session/finish_batch.
        case notClosed
        /// You can not append to the upload session because the size of a file should not reach the max file size limit
        /// (i.e. 350GB).
        case tooLarge
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionLookupErrorSerializer().serialize(self)))"
        }
    }
    open class UploadSessionLookupErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadSessionLookupError) -> JSON {
            switch value {
                case .notFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_found")
                    return .dictionary(d)
                case .incorrectOffset(let arg):
                    var d = Serialization.getFields(Files.UploadSessionOffsetErrorSerializer().serialize(arg))
                    d[".tag"] = .str("incorrect_offset")
                    return .dictionary(d)
                case .closed:
                    var d = [String: JSON]()
                    d[".tag"] = .str("closed")
                    return .dictionary(d)
                case .notClosed:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_closed")
                    return .dictionary(d)
                case .tooLarge:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_large")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> UploadSessionLookupError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "not_found":
                            return UploadSessionLookupError.notFound
                        case "incorrect_offset":
                            let v = Files.UploadSessionOffsetErrorSerializer().deserialize(json)
                            return UploadSessionLookupError.incorrectOffset(v)
                        case "closed":
                            return UploadSessionLookupError.closed
                        case "not_closed":
                            return UploadSessionLookupError.notClosed
                        case "too_large":
                            return UploadSessionLookupError.tooLarge
                        case "other":
                            return UploadSessionLookupError.other
                        default:
                            return UploadSessionLookupError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The UploadSessionOffsetError struct
    open class UploadSessionOffsetError: CustomStringConvertible {
        /// The offset up to which data has been collected.
        public let correctOffset: UInt64
        public init(correctOffset: UInt64) {
            comparableValidator()(correctOffset)
            self.correctOffset = correctOffset
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionOffsetErrorSerializer().serialize(self)))"
        }
    }
    open class UploadSessionOffsetErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadSessionOffsetError) -> JSON {
            let output = [ 
            "correct_offset": Serialization._UInt64Serializer.serialize(value.correctOffset),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UploadSessionOffsetError {
            switch json {
                case .dictionary(let dict):
                    let correctOffset = Serialization._UInt64Serializer.deserialize(dict["correct_offset"] ?? .null)
                    return UploadSessionOffsetError(correctOffset: correctOffset)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UploadSessionStartArg struct
    open class UploadSessionStartArg: CustomStringConvertible {
        /// If true, the current session will be closed, at which point you won't be able to call uploadSessionAppendV2
        /// anymore with the current session.
        public let close: Bool
        public init(close: Bool = false) {
            self.close = close
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionStartArgSerializer().serialize(self)))"
        }
    }
    open class UploadSessionStartArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadSessionStartArg) -> JSON {
            let output = [ 
            "close": Serialization._BoolSerializer.serialize(value.close),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UploadSessionStartArg {
            switch json {
                case .dictionary(let dict):
                    let close = Serialization._BoolSerializer.deserialize(dict["close"] ?? .number(0))
                    return UploadSessionStartArg(close: close)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UploadSessionStartResult struct
    open class UploadSessionStartResult: CustomStringConvertible {
        /// A unique identifier for the upload session. Pass this to uploadSessionAppendV2 and uploadSessionFinish.
        public let sessionId: String
        public init(sessionId: String) {
            stringValidator()(sessionId)
            self.sessionId = sessionId
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionStartResultSerializer().serialize(self)))"
        }
    }
    open class UploadSessionStartResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadSessionStartResult) -> JSON {
            let output = [ 
            "session_id": Serialization._StringSerializer.serialize(value.sessionId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UploadSessionStartResult {
            switch json {
                case .dictionary(let dict):
                    let sessionId = Serialization._StringSerializer.deserialize(dict["session_id"] ?? .null)
                    return UploadSessionStartResult(sessionId: sessionId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UploadWriteFailed struct
    open class UploadWriteFailed: CustomStringConvertible {
        /// The reason why the file couldn't be saved.
        public let reason: Files.WriteError
        /// The upload session ID; data has already been uploaded to the corresponding upload session and this ID may be
        /// used to retry the commit with uploadSessionFinish.
        public let uploadSessionId: String
        public init(reason: Files.WriteError, uploadSessionId: String) {
            self.reason = reason
            stringValidator()(uploadSessionId)
            self.uploadSessionId = uploadSessionId
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadWriteFailedSerializer().serialize(self)))"
        }
    }
    open class UploadWriteFailedSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadWriteFailed) -> JSON {
            let output = [ 
            "reason": Files.WriteErrorSerializer().serialize(value.reason),
            "upload_session_id": Serialization._StringSerializer.serialize(value.uploadSessionId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UploadWriteFailed {
            switch json {
                case .dictionary(let dict):
                    let reason = Files.WriteErrorSerializer().deserialize(dict["reason"] ?? .null)
                    let uploadSessionId = Serialization._StringSerializer.deserialize(dict["upload_session_id"] ?? .null)
                    return UploadWriteFailed(reason: reason, uploadSessionId: uploadSessionId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Metadata for a video.
    open class VideoMetadata: Files.MediaMetadata {
        /// The duration of the video in milliseconds.
        public let duration: UInt64?
        public init(dimensions: Files.Dimensions? = nil, location: Files.GpsCoordinates? = nil, timeTaken: Date? = nil, duration: UInt64? = nil) {
            nullableValidator(comparableValidator())(duration)
            self.duration = duration
            super.init(dimensions: dimensions, location: location, timeTaken: timeTaken)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(VideoMetadataSerializer().serialize(self)))"
        }
    }
    open class VideoMetadataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: VideoMetadata) -> JSON {
            let output = [ 
            "dimensions": NullableSerializer(Files.DimensionsSerializer()).serialize(value.dimensions),
            "location": NullableSerializer(Files.GpsCoordinatesSerializer()).serialize(value.location),
            "time_taken": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.timeTaken),
            "duration": NullableSerializer(Serialization._UInt64Serializer).serialize(value.duration),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> VideoMetadata {
            switch json {
                case .dictionary(let dict):
                    let dimensions = NullableSerializer(Files.DimensionsSerializer()).deserialize(dict["dimensions"] ?? .null)
                    let location = NullableSerializer(Files.GpsCoordinatesSerializer()).deserialize(dict["location"] ?? .null)
                    let timeTaken = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["time_taken"] ?? .null)
                    let duration = NullableSerializer(Serialization._UInt64Serializer).deserialize(dict["duration"] ?? .null)
                    return VideoMetadata(dimensions: dimensions, location: location, timeTaken: timeTaken, duration: duration)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The WriteConflictError union
    public enum WriteConflictError: CustomStringConvertible {
        /// There's a file in the way.
        case file
        /// There's a folder in the way.
        case folder
        /// There's a file at an ancestor path, so we couldn't create the required parent folders.
        case fileAncestor
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(WriteConflictErrorSerializer().serialize(self)))"
        }
    }
    open class WriteConflictErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: WriteConflictError) -> JSON {
            switch value {
                case .file:
                    var d = [String: JSON]()
                    d[".tag"] = .str("file")
                    return .dictionary(d)
                case .folder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("folder")
                    return .dictionary(d)
                case .fileAncestor:
                    var d = [String: JSON]()
                    d[".tag"] = .str("file_ancestor")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> WriteConflictError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "file":
                            return WriteConflictError.file
                        case "folder":
                            return WriteConflictError.folder
                        case "file_ancestor":
                            return WriteConflictError.fileAncestor
                        case "other":
                            return WriteConflictError.other
                        default:
                            return WriteConflictError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The WriteError union
    public enum WriteError: CustomStringConvertible {
        /// The given path does not satisfy the required path format. Please refer to the Path formats documentation
        /// https://www.dropbox.com/developers/documentation/http/documentation#path-formats for more information.
        case malformedPath(String?)
        /// Couldn't write to the target path because there was something in the way.
        case conflict(Files.WriteConflictError)
        /// The user doesn't have permissions to write to the target location.
        case noWritePermission
        /// The user doesn't have enough available space (bytes) to write more data.
        case insufficientSpace
        /// Dropbox will not save the file or folder because of its name.
        case disallowedName
        /// This endpoint cannot move or delete team folders.
        case teamFolder
        /// There are too many write operations in user's Dropbox. Please retry this request.
        case tooManyWriteOperations
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(WriteErrorSerializer().serialize(self)))"
        }
    }
    open class WriteErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: WriteError) -> JSON {
            switch value {
                case .malformedPath(let arg):
                    var d = ["malformed_path": NullableSerializer(Serialization._StringSerializer).serialize(arg)]
                    d[".tag"] = .str("malformed_path")
                    return .dictionary(d)
                case .conflict(let arg):
                    var d = ["conflict": Files.WriteConflictErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("conflict")
                    return .dictionary(d)
                case .noWritePermission:
                    var d = [String: JSON]()
                    d[".tag"] = .str("no_write_permission")
                    return .dictionary(d)
                case .insufficientSpace:
                    var d = [String: JSON]()
                    d[".tag"] = .str("insufficient_space")
                    return .dictionary(d)
                case .disallowedName:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disallowed_name")
                    return .dictionary(d)
                case .teamFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("team_folder")
                    return .dictionary(d)
                case .tooManyWriteOperations:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_write_operations")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> WriteError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "malformed_path":
                            let v = NullableSerializer(Serialization._StringSerializer).deserialize(d["malformed_path"] ?? .null)
                            return WriteError.malformedPath(v)
                        case "conflict":
                            let v = Files.WriteConflictErrorSerializer().deserialize(d["conflict"] ?? .null)
                            return WriteError.conflict(v)
                        case "no_write_permission":
                            return WriteError.noWritePermission
                        case "insufficient_space":
                            return WriteError.insufficientSpace
                        case "disallowed_name":
                            return WriteError.disallowedName
                        case "team_folder":
                            return WriteError.teamFolder
                        case "too_many_write_operations":
                            return WriteError.tooManyWriteOperations
                        case "other":
                            return WriteError.other
                        default:
                            return WriteError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Your intent when writing a file to some path. This is used to determine what constitutes a conflict and what the
    /// autorename strategy is. In some situations, the conflict behavior is identical: (a) If the target path doesn't
    /// refer to anything, the file is always written; no conflict. (b) If the target path refers to a folder, it's
    /// always a conflict. (c) If the target path refers to a file with identical contents, nothing gets written; no
    /// conflict. The conflict checking differs in the case where there's a file at the target path with contents
    /// different from the contents you're trying to write.
    public enum WriteMode: CustomStringConvertible {
        /// Do not overwrite an existing file if there is a conflict. The autorename strategy is to append a number to
        /// the file name. For example, "document.txt" might become "document (2).txt".
        case add
        /// Always overwrite the existing file. The autorename strategy is the same as it is for add.
        case overwrite
        /// Overwrite if the given "rev" matches the existing file's "rev". The autorename strategy is to append the
        /// string "conflicted copy" to the file name. For example, "document.txt" might become "document (conflicted
        /// copy).txt" or "document (Panda's conflicted copy).txt".
        case update(String)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(WriteModeSerializer().serialize(self)))"
        }
    }
    open class WriteModeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: WriteMode) -> JSON {
            switch value {
                case .add:
                    var d = [String: JSON]()
                    d[".tag"] = .str("add")
                    return .dictionary(d)
                case .overwrite:
                    var d = [String: JSON]()
                    d[".tag"] = .str("overwrite")
                    return .dictionary(d)
                case .update(let arg):
                    var d = ["update": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("update")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> WriteMode {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "add":
                            return WriteMode.add
                        case "overwrite":
                            return WriteMode.overwrite
                        case "update":
                            let v = Serialization._StringSerializer.deserialize(d["update"] ?? .null)
                            return WriteMode.update(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }


    /// Stone Route Objects

    static let alphaGetMetadata = Route(
        name: "alpha/get_metadata",
        version: 1,
        namespace: "files",
        deprecated: true,
        argSerializer: Files.AlphaGetMetadataArgSerializer(),
        responseSerializer: Files.MetadataSerializer(),
        errorSerializer: Files.AlphaGetMetadataErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let alphaUpload = Route(
        name: "alpha/upload",
        version: 1,
        namespace: "files",
        deprecated: true,
        argSerializer: Files.CommitInfoWithPropertiesSerializer(),
        responseSerializer: Files.FileMetadataSerializer(),
        errorSerializer: Files.UploadErrorWithPropertiesSerializer(),
        attrs: ["host": "content",
                "style": "upload"]
    )
    static let copyV2 = Route(
        name: "copy",
        version: 2,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.RelocationArgSerializer(),
        responseSerializer: Files.RelocationResultSerializer(),
        errorSerializer: Files.RelocationErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let copy = Route(
        name: "copy",
        version: 1,
        namespace: "files",
        deprecated: true,
        argSerializer: Files.RelocationArgSerializer(),
        responseSerializer: Files.MetadataSerializer(),
        errorSerializer: Files.RelocationErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let copyBatchV2 = Route(
        name: "copy_batch",
        version: 2,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.RelocationBatchArgBaseSerializer(),
        responseSerializer: Files.RelocationBatchV2LaunchSerializer(),
        errorSerializer: Serialization._VoidSerializer,
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let copyBatch = Route(
        name: "copy_batch",
        version: 1,
        namespace: "files",
        deprecated: true,
        argSerializer: Files.RelocationBatchArgSerializer(),
        responseSerializer: Files.RelocationBatchLaunchSerializer(),
        errorSerializer: Serialization._VoidSerializer,
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let copyBatchCheckV2 = Route(
        name: "copy_batch/check",
        version: 2,
        namespace: "files",
        deprecated: false,
        argSerializer: Async.PollArgSerializer(),
        responseSerializer: Files.RelocationBatchV2JobStatusSerializer(),
        errorSerializer: Async.PollErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let copyBatchCheck = Route(
        name: "copy_batch/check",
        version: 1,
        namespace: "files",
        deprecated: true,
        argSerializer: Async.PollArgSerializer(),
        responseSerializer: Files.RelocationBatchJobStatusSerializer(),
        errorSerializer: Async.PollErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let copyReferenceGet = Route(
        name: "copy_reference/get",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.GetCopyReferenceArgSerializer(),
        responseSerializer: Files.GetCopyReferenceResultSerializer(),
        errorSerializer: Files.GetCopyReferenceErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let copyReferenceSave = Route(
        name: "copy_reference/save",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.SaveCopyReferenceArgSerializer(),
        responseSerializer: Files.SaveCopyReferenceResultSerializer(),
        errorSerializer: Files.SaveCopyReferenceErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let createFolderV2 = Route(
        name: "create_folder",
        version: 2,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.CreateFolderArgSerializer(),
        responseSerializer: Files.CreateFolderResultSerializer(),
        errorSerializer: Files.CreateFolderErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let createFolder = Route(
        name: "create_folder",
        version: 1,
        namespace: "files",
        deprecated: true,
        argSerializer: Files.CreateFolderArgSerializer(),
        responseSerializer: Files.FolderMetadataSerializer(),
        errorSerializer: Files.CreateFolderErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let createFolderBatch = Route(
        name: "create_folder_batch",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.CreateFolderBatchArgSerializer(),
        responseSerializer: Files.CreateFolderBatchLaunchSerializer(),
        errorSerializer: Serialization._VoidSerializer,
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let createFolderBatchCheck = Route(
        name: "create_folder_batch/check",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Async.PollArgSerializer(),
        responseSerializer: Files.CreateFolderBatchJobStatusSerializer(),
        errorSerializer: Async.PollErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let deleteV2 = Route(
        name: "delete",
        version: 2,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.DeleteArgSerializer(),
        responseSerializer: Files.DeleteResultSerializer(),
        errorSerializer: Files.DeleteErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let delete = Route(
        name: "delete",
        version: 1,
        namespace: "files",
        deprecated: true,
        argSerializer: Files.DeleteArgSerializer(),
        responseSerializer: Files.MetadataSerializer(),
        errorSerializer: Files.DeleteErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let deleteBatch = Route(
        name: "delete_batch",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.DeleteBatchArgSerializer(),
        responseSerializer: Files.DeleteBatchLaunchSerializer(),
        errorSerializer: Serialization._VoidSerializer,
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let deleteBatchCheck = Route(
        name: "delete_batch/check",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Async.PollArgSerializer(),
        responseSerializer: Files.DeleteBatchJobStatusSerializer(),
        errorSerializer: Async.PollErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let download = Route(
        name: "download",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.DownloadArgSerializer(),
        responseSerializer: Files.FileMetadataSerializer(),
        errorSerializer: Files.DownloadErrorSerializer(),
        attrs: ["host": "content",
                "style": "download"]
    )
    static let downloadZip = Route(
        name: "download_zip",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.DownloadZipArgSerializer(),
        responseSerializer: Files.DownloadZipResultSerializer(),
        errorSerializer: Files.DownloadZipErrorSerializer(),
        attrs: ["host": "content",
                "style": "download"]
    )
    static let getMetadata = Route(
        name: "get_metadata",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.GetMetadataArgSerializer(),
        responseSerializer: Files.MetadataSerializer(),
        errorSerializer: Files.GetMetadataErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let getPreview = Route(
        name: "get_preview",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.PreviewArgSerializer(),
        responseSerializer: Files.FileMetadataSerializer(),
        errorSerializer: Files.PreviewErrorSerializer(),
        attrs: ["host": "content",
                "style": "download"]
    )
    static let getTemporaryLink = Route(
        name: "get_temporary_link",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.GetTemporaryLinkArgSerializer(),
        responseSerializer: Files.GetTemporaryLinkResultSerializer(),
        errorSerializer: Files.GetTemporaryLinkErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let getTemporaryUploadLink = Route(
        name: "get_temporary_upload_link",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.GetTemporaryUploadLinkArgSerializer(),
        responseSerializer: Files.GetTemporaryUploadLinkResultSerializer(),
        errorSerializer: Serialization._VoidSerializer,
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let getThumbnail = Route(
        name: "get_thumbnail",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.ThumbnailArgSerializer(),
        responseSerializer: Files.FileMetadataSerializer(),
        errorSerializer: Files.ThumbnailErrorSerializer(),
        attrs: ["host": "content",
                "style": "download"]
    )
    static let getThumbnailBatch = Route(
        name: "get_thumbnail_batch",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.GetThumbnailBatchArgSerializer(),
        responseSerializer: Files.GetThumbnailBatchResultSerializer(),
        errorSerializer: Files.GetThumbnailBatchErrorSerializer(),
        attrs: ["host": "content",
                "style": "rpc"]
    )
    static let listFolder = Route(
        name: "list_folder",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.ListFolderArgSerializer(),
        responseSerializer: Files.ListFolderResultSerializer(),
        errorSerializer: Files.ListFolderErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let listFolderContinue = Route(
        name: "list_folder/continue",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.ListFolderContinueArgSerializer(),
        responseSerializer: Files.ListFolderResultSerializer(),
        errorSerializer: Files.ListFolderContinueErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let listFolderGetLatestCursor = Route(
        name: "list_folder/get_latest_cursor",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.ListFolderArgSerializer(),
        responseSerializer: Files.ListFolderGetLatestCursorResultSerializer(),
        errorSerializer: Files.ListFolderErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let listFolderLongpoll = Route(
        name: "list_folder/longpoll",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.ListFolderLongpollArgSerializer(),
        responseSerializer: Files.ListFolderLongpollResultSerializer(),
        errorSerializer: Files.ListFolderLongpollErrorSerializer(),
        attrs: ["host": "notify",
                "style": "rpc"]
    )
    static let listRevisions = Route(
        name: "list_revisions",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.ListRevisionsArgSerializer(),
        responseSerializer: Files.ListRevisionsResultSerializer(),
        errorSerializer: Files.ListRevisionsErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let moveV2 = Route(
        name: "move",
        version: 2,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.RelocationArgSerializer(),
        responseSerializer: Files.RelocationResultSerializer(),
        errorSerializer: Files.RelocationErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let move = Route(
        name: "move",
        version: 1,
        namespace: "files",
        deprecated: true,
        argSerializer: Files.RelocationArgSerializer(),
        responseSerializer: Files.MetadataSerializer(),
        errorSerializer: Files.RelocationErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let moveBatchV2 = Route(
        name: "move_batch",
        version: 2,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.MoveBatchArgSerializer(),
        responseSerializer: Files.RelocationBatchV2LaunchSerializer(),
        errorSerializer: Serialization._VoidSerializer,
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let moveBatch = Route(
        name: "move_batch",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.RelocationBatchArgSerializer(),
        responseSerializer: Files.RelocationBatchLaunchSerializer(),
        errorSerializer: Serialization._VoidSerializer,
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let moveBatchCheckV2 = Route(
        name: "move_batch/check",
        version: 2,
        namespace: "files",
        deprecated: false,
        argSerializer: Async.PollArgSerializer(),
        responseSerializer: Files.RelocationBatchV2JobStatusSerializer(),
        errorSerializer: Async.PollErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let moveBatchCheck = Route(
        name: "move_batch/check",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Async.PollArgSerializer(),
        responseSerializer: Files.RelocationBatchJobStatusSerializer(),
        errorSerializer: Async.PollErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let permanentlyDelete = Route(
        name: "permanently_delete",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.DeleteArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Files.DeleteErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let propertiesAdd = Route(
        name: "properties/add",
        version: 1,
        namespace: "files",
        deprecated: true,
        argSerializer: FileProperties.AddPropertiesArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: FileProperties.AddPropertiesErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let propertiesOverwrite = Route(
        name: "properties/overwrite",
        version: 1,
        namespace: "files",
        deprecated: true,
        argSerializer: FileProperties.OverwritePropertyGroupArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: FileProperties.InvalidPropertyGroupErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let propertiesRemove = Route(
        name: "properties/remove",
        version: 1,
        namespace: "files",
        deprecated: true,
        argSerializer: FileProperties.RemovePropertiesArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: FileProperties.RemovePropertiesErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let propertiesTemplateGet = Route(
        name: "properties/template/get",
        version: 1,
        namespace: "files",
        deprecated: true,
        argSerializer: FileProperties.GetTemplateArgSerializer(),
        responseSerializer: FileProperties.GetTemplateResultSerializer(),
        errorSerializer: FileProperties.TemplateErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let propertiesTemplateList = Route(
        name: "properties/template/list",
        version: 1,
        namespace: "files",
        deprecated: true,
        argSerializer: Serialization._VoidSerializer,
        responseSerializer: FileProperties.ListTemplateResultSerializer(),
        errorSerializer: FileProperties.TemplateErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let propertiesUpdate = Route(
        name: "properties/update",
        version: 1,
        namespace: "files",
        deprecated: true,
        argSerializer: FileProperties.UpdatePropertiesArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: FileProperties.UpdatePropertiesErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let restore = Route(
        name: "restore",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.RestoreArgSerializer(),
        responseSerializer: Files.FileMetadataSerializer(),
        errorSerializer: Files.RestoreErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let saveUrl = Route(
        name: "save_url",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.SaveUrlArgSerializer(),
        responseSerializer: Files.SaveUrlResultSerializer(),
        errorSerializer: Files.SaveUrlErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let saveUrlCheckJobStatus = Route(
        name: "save_url/check_job_status",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Async.PollArgSerializer(),
        responseSerializer: Files.SaveUrlJobStatusSerializer(),
        errorSerializer: Async.PollErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let search = Route(
        name: "search",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.SearchArgSerializer(),
        responseSerializer: Files.SearchResultSerializer(),
        errorSerializer: Files.SearchErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let upload = Route(
        name: "upload",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.CommitInfoSerializer(),
        responseSerializer: Files.FileMetadataSerializer(),
        errorSerializer: Files.UploadErrorSerializer(),
        attrs: ["host": "content",
                "style": "upload"]
    )
    static let uploadSessionAppendV2 = Route(
        name: "upload_session/append",
        version: 2,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.UploadSessionAppendArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Files.UploadSessionLookupErrorSerializer(),
        attrs: ["host": "content",
                "style": "upload"]
    )
    static let uploadSessionAppend = Route(
        name: "upload_session/append",
        version: 1,
        namespace: "files",
        deprecated: true,
        argSerializer: Files.UploadSessionCursorSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Files.UploadSessionLookupErrorSerializer(),
        attrs: ["host": "content",
                "style": "upload"]
    )
    static let uploadSessionFinish = Route(
        name: "upload_session/finish",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.UploadSessionFinishArgSerializer(),
        responseSerializer: Files.FileMetadataSerializer(),
        errorSerializer: Files.UploadSessionFinishErrorSerializer(),
        attrs: ["host": "content",
                "style": "upload"]
    )
    static let uploadSessionFinishBatch = Route(
        name: "upload_session/finish_batch",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.UploadSessionFinishBatchArgSerializer(),
        responseSerializer: Files.UploadSessionFinishBatchLaunchSerializer(),
        errorSerializer: Serialization._VoidSerializer,
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let uploadSessionFinishBatchCheck = Route(
        name: "upload_session/finish_batch/check",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Async.PollArgSerializer(),
        responseSerializer: Files.UploadSessionFinishBatchJobStatusSerializer(),
        errorSerializer: Async.PollErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let uploadSessionStart = Route(
        name: "upload_session/start",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.UploadSessionStartArgSerializer(),
        responseSerializer: Files.UploadSessionStartResultSerializer(),
        errorSerializer: Serialization._VoidSerializer,
        attrs: ["host": "content",
                "style": "upload"]
    )
}
