///
/// Copyright (c) 2016 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

/// Routes for the team namespace
open class TeamRoutes {
    public let client: DropboxTransportClient
    init(client: DropboxTransportClient) {
        self.client = client
    }

    /// List all device sessions of a team's member.
    ///
    /// - parameter teamMemberId: The team's member id.
    /// - parameter includeWebSessions: Whether to list web sessions of the team's member.
    /// - parameter includeDesktopClients: Whether to list linked desktop devices of the team's member.
    /// - parameter includeMobileClients: Whether to list linked mobile devices of the team's member.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.ListMemberDevicesResult` object on
    /// success or a `Team.ListMemberDevicesError` object on failure.
    @discardableResult open func devicesListMemberDevices(teamMemberId: String, includeWebSessions: Bool = true, includeDesktopClients: Bool = true, includeMobileClients: Bool = true) -> RpcRequest<Team.ListMemberDevicesResultSerializer, Team.ListMemberDevicesErrorSerializer> {
        let route = Team.devicesListMemberDevices
        let serverArgs = Team.ListMemberDevicesArg(teamMemberId: teamMemberId, includeWebSessions: includeWebSessions, includeDesktopClients: includeDesktopClients, includeMobileClients: includeMobileClients)
        return client.request(route, serverArgs: serverArgs)
    }

    /// List all device sessions of a team. Permission : Team member file access.
    ///
    /// - parameter cursor: At the first call to the devicesListMembersDevices the cursor shouldn't be passed. Then, if
    /// the result of the call includes a cursor, the following requests should include the received cursors in order to
    /// receive the next sub list of team devices.
    /// - parameter includeWebSessions: Whether to list web sessions of the team members.
    /// - parameter includeDesktopClients: Whether to list desktop clients of the team members.
    /// - parameter includeMobileClients: Whether to list mobile clients of the team members.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.ListMembersDevicesResult` object on
    /// success or a `Team.ListMembersDevicesError` object on failure.
    @discardableResult open func devicesListMembersDevices(cursor: String? = nil, includeWebSessions: Bool = true, includeDesktopClients: Bool = true, includeMobileClients: Bool = true) -> RpcRequest<Team.ListMembersDevicesResultSerializer, Team.ListMembersDevicesErrorSerializer> {
        let route = Team.devicesListMembersDevices
        let serverArgs = Team.ListMembersDevicesArg(cursor: cursor, includeWebSessions: includeWebSessions, includeDesktopClients: includeDesktopClients, includeMobileClients: includeMobileClients)
        return client.request(route, serverArgs: serverArgs)
    }

    /// List all device sessions of a team. Permission : Team member file access.
    ///
    /// - parameter cursor: At the first call to the devicesListTeamDevices the cursor shouldn't be passed. Then, if the
    /// result of the call includes a cursor, the following requests should include the received cursors in order to
    /// receive the next sub list of team devices.
    /// - parameter includeWebSessions: Whether to list web sessions of the team members.
    /// - parameter includeDesktopClients: Whether to list desktop clients of the team members.
    /// - parameter includeMobileClients: Whether to list mobile clients of the team members.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.ListTeamDevicesResult` object on
    /// success or a `Team.ListTeamDevicesError` object on failure.
    @available(*, unavailable, message:"devicesListTeamDevices is deprecated. Use devicesListMembersDevices.")
    @discardableResult open func devicesListTeamDevices(cursor: String? = nil, includeWebSessions: Bool = true, includeDesktopClients: Bool = true, includeMobileClients: Bool = true) -> RpcRequest<Team.ListTeamDevicesResultSerializer, Team.ListTeamDevicesErrorSerializer> {
        let route = Team.devicesListTeamDevices
        let serverArgs = Team.ListTeamDevicesArg(cursor: cursor, includeWebSessions: includeWebSessions, includeDesktopClients: includeDesktopClients, includeMobileClients: includeMobileClients)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Revoke a device session of a team's member.
    ///
    /// - parameter revokeDeviceSessionArg: The RevokeDeviceSessionArg union
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Team.RevokeDeviceSessionError` object on failure.
    @discardableResult open func devicesRevokeDeviceSession(revokeDeviceSessionArg: Team.RevokeDeviceSessionArg) -> RpcRequest<VoidSerializer, Team.RevokeDeviceSessionErrorSerializer> {
        let route = Team.devicesRevokeDeviceSession
        let serverArgs = revokeDeviceSessionArg
        return client.request(route, serverArgs: serverArgs)
    }

    /// Revoke a list of device sessions of team members.
    ///
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.RevokeDeviceSessionBatchResult`
    /// object on success or a `Team.RevokeDeviceSessionBatchError` object on failure.
    @discardableResult open func devicesRevokeDeviceSessionBatch(revokeDevices: Array<Team.RevokeDeviceSessionArg>) -> RpcRequest<Team.RevokeDeviceSessionBatchResultSerializer, Team.RevokeDeviceSessionBatchErrorSerializer> {
        let route = Team.devicesRevokeDeviceSessionBatch
        let serverArgs = Team.RevokeDeviceSessionBatchArg(revokeDevices: revokeDevices)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Get the values for one or more featues. This route allows you to check your account's capability for what
    /// feature you can access or what value you have for certain features. Permission : Team information.
    ///
    /// - parameter features: A list of features in Feature. If the list is empty, this route will return
    /// FeaturesGetValuesBatchError.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.FeaturesGetValuesBatchResult` object
    /// on success or a `Team.FeaturesGetValuesBatchError` object on failure.
    @discardableResult open func featuresGetValues(features: Array<Team.Feature>) -> RpcRequest<Team.FeaturesGetValuesBatchResultSerializer, Team.FeaturesGetValuesBatchErrorSerializer> {
        let route = Team.featuresGetValues
        let serverArgs = Team.FeaturesGetValuesBatchArg(features: features)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Retrieves information about a team.
    ///
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.TeamGetInfoResult` object on success
    /// or a `Void` object on failure.
    @discardableResult open func getInfo() -> RpcRequest<Team.TeamGetInfoResultSerializer, VoidSerializer> {
        let route = Team.getInfo
        return client.request(route)
    }

    /// Creates a new, empty group, with a requested name. Permission : Team member management.
    ///
    /// - parameter groupName: Group name.
    /// - parameter groupExternalId: The creator of a team can associate an arbitrary external ID to the group.
    /// - parameter groupManagementType: Whether the team can be managed by selected users, or only by team admins.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.GroupFullInfo` object on success or a
    /// `Team.GroupCreateError` object on failure.
    @discardableResult open func groupsCreate(groupName: String, groupExternalId: String? = nil, groupManagementType: TeamCommon.GroupManagementType? = nil) -> RpcRequest<Team.GroupFullInfoSerializer, Team.GroupCreateErrorSerializer> {
        let route = Team.groupsCreate
        let serverArgs = Team.GroupCreateArg(groupName: groupName, groupExternalId: groupExternalId, groupManagementType: groupManagementType)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Deletes a group. The group is deleted immediately. However the revoking of group-owned resources may take
    /// additional time. Use the groupsJobStatusGet to determine whether this process has completed. Permission : Team
    /// member management.
    ///
    /// - parameter groupSelector: Argument for selecting a single group, either by group_id or by external group ID.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Async.LaunchEmptyResult` object on success
    /// or a `Team.GroupDeleteError` object on failure.
    @discardableResult open func groupsDelete(groupSelector: Team.GroupSelector) -> RpcRequest<Async.LaunchEmptyResultSerializer, Team.GroupDeleteErrorSerializer> {
        let route = Team.groupsDelete
        let serverArgs = groupSelector
        return client.request(route, serverArgs: serverArgs)
    }

    /// Retrieves information about one or more groups. Note that the optional field  members in GroupFullInfo is not
    /// returned for system-managed groups. Permission : Team Information.
    ///
    /// - parameter groupsSelector: Argument for selecting a list of groups, either by group_ids, or external group IDs.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Array<Team.GroupsGetInfoItem>` object on
    /// success or a `Team.GroupsGetInfoError` object on failure.
    @discardableResult open func groupsGetInfo(groupsSelector: Team.GroupsSelector) -> RpcRequest<ArraySerializer<Team.GroupsGetInfoItemSerializer>, Team.GroupsGetInfoErrorSerializer> {
        let route = Team.groupsGetInfo
        let serverArgs = groupsSelector
        return client.request(route, serverArgs: serverArgs)
    }

    /// Once an async_job_id is returned from groupsDelete, groupsMembersAdd , or groupsMembersRemove use this method to
    /// poll the status of granting/revoking group members' access to group-owned resources. Permission : Team member
    /// management.
    ///
    /// - parameter asyncJobId: Id of the asynchronous job. This is the value of a response returned from the method
    /// that launched the job.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Async.PollEmptyResult` object on success
    /// or a `Team.GroupsPollError` object on failure.
    @discardableResult open func groupsJobStatusGet(asyncJobId: String) -> RpcRequest<Async.PollEmptyResultSerializer, Team.GroupsPollErrorSerializer> {
        let route = Team.groupsJobStatusGet
        let serverArgs = Async.PollArg(asyncJobId: asyncJobId)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Lists groups on a team. Permission : Team Information.
    ///
    /// - parameter limit: Number of results to return per call.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.GroupsListResult` object on success
    /// or a `Void` object on failure.
    @discardableResult open func groupsList(limit: UInt32 = 1000) -> RpcRequest<Team.GroupsListResultSerializer, VoidSerializer> {
        let route = Team.groupsList
        let serverArgs = Team.GroupsListArg(limit: limit)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Once a cursor has been retrieved from groupsList, use this to paginate through all groups. Permission : Team
    /// Information.
    ///
    /// - parameter cursor: Indicates from what point to get the next set of groups.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.GroupsListResult` object on success
    /// or a `Team.GroupsListContinueError` object on failure.
    @discardableResult open func groupsListContinue(cursor: String) -> RpcRequest<Team.GroupsListResultSerializer, Team.GroupsListContinueErrorSerializer> {
        let route = Team.groupsListContinue
        let serverArgs = Team.GroupsListContinueArg(cursor: cursor)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Adds members to a group. The members are added immediately. However the granting of group-owned resources may
    /// take additional time. Use the groupsJobStatusGet to determine whether this process has completed. Permission :
    /// Team member management.
    ///
    /// - parameter group: Group to which users will be added.
    /// - parameter members: List of users to be added to the group.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.GroupMembersChangeResult` object on
    /// success or a `Team.GroupMembersAddError` object on failure.
    @discardableResult open func groupsMembersAdd(group: Team.GroupSelector, members: Array<Team.MemberAccess>, returnMembers: Bool = true) -> RpcRequest<Team.GroupMembersChangeResultSerializer, Team.GroupMembersAddErrorSerializer> {
        let route = Team.groupsMembersAdd
        let serverArgs = Team.GroupMembersAddArg(group: group, members: members, returnMembers: returnMembers)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Lists members of a group. Permission : Team Information.
    ///
    /// - parameter group: The group whose members are to be listed.
    /// - parameter limit: Number of results to return per call.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.GroupsMembersListResult` object on
    /// success or a `Team.GroupSelectorError` object on failure.
    @discardableResult open func groupsMembersList(group: Team.GroupSelector, limit: UInt32 = 1000) -> RpcRequest<Team.GroupsMembersListResultSerializer, Team.GroupSelectorErrorSerializer> {
        let route = Team.groupsMembersList
        let serverArgs = Team.GroupsMembersListArg(group: group, limit: limit)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Once a cursor has been retrieved from groupsMembersList, use this to paginate through all members of the group.
    /// Permission : Team information.
    ///
    /// - parameter cursor: Indicates from what point to get the next set of groups.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.GroupsMembersListResult` object on
    /// success or a `Team.GroupsMembersListContinueError` object on failure.
    @discardableResult open func groupsMembersListContinue(cursor: String) -> RpcRequest<Team.GroupsMembersListResultSerializer, Team.GroupsMembersListContinueErrorSerializer> {
        let route = Team.groupsMembersListContinue
        let serverArgs = Team.GroupsMembersListContinueArg(cursor: cursor)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Removes members from a group. The members are removed immediately. However the revoking of group-owned resources
    /// may take additional time. Use the groupsJobStatusGet to determine whether this process has completed. This
    /// method permits removing the only owner of a group, even in cases where this is not possible via the web client.
    /// Permission : Team member management.
    ///
    /// - parameter group: Group from which users will be removed.
    /// - parameter users: List of users to be removed from the group.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.GroupMembersChangeResult` object on
    /// success or a `Team.GroupMembersRemoveError` object on failure.
    @discardableResult open func groupsMembersRemove(group: Team.GroupSelector, users: Array<Team.UserSelectorArg>, returnMembers: Bool = true) -> RpcRequest<Team.GroupMembersChangeResultSerializer, Team.GroupMembersRemoveErrorSerializer> {
        let route = Team.groupsMembersRemove
        let serverArgs = Team.GroupMembersRemoveArg(group: group, users: users, returnMembers: returnMembers)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Sets a member's access type in a group. Permission : Team member management.
    ///
    /// - parameter accessType: New group access type the user will have.
    /// - parameter returnMembers: Whether to return the list of members in the group.  Note that the default value will
    /// cause all the group members  to be returned in the response. This may take a long time for large groups.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Array<Team.GroupsGetInfoItem>` object on
    /// success or a `Team.GroupMemberSetAccessTypeError` object on failure.
    @discardableResult open func groupsMembersSetAccessType(group: Team.GroupSelector, user: Team.UserSelectorArg, accessType: Team.GroupAccessType, returnMembers: Bool = true) -> RpcRequest<ArraySerializer<Team.GroupsGetInfoItemSerializer>, Team.GroupMemberSetAccessTypeErrorSerializer> {
        let route = Team.groupsMembersSetAccessType
        let serverArgs = Team.GroupMembersSetAccessTypeArg(group: group, user: user, accessType: accessType, returnMembers: returnMembers)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Updates a group's name and/or external ID. Permission : Team member management.
    ///
    /// - parameter group: Specify a group.
    /// - parameter newGroupName: Optional argument. Set group name to this if provided.
    /// - parameter newGroupExternalId: Optional argument. New group external ID. If the argument is None, the group's
    /// external_id won't be updated. If the argument is empty string, the group's external id will be cleared.
    /// - parameter newGroupManagementType: Set new group management type, if provided.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.GroupFullInfo` object on success or a
    /// `Team.GroupUpdateError` object on failure.
    @discardableResult open func groupsUpdate(group: Team.GroupSelector, returnMembers: Bool = true, newGroupName: String? = nil, newGroupExternalId: String? = nil, newGroupManagementType: TeamCommon.GroupManagementType? = nil) -> RpcRequest<Team.GroupFullInfoSerializer, Team.GroupUpdateErrorSerializer> {
        let route = Team.groupsUpdate
        let serverArgs = Team.GroupUpdateArgs(group: group, returnMembers: returnMembers, newGroupName: newGroupName, newGroupExternalId: newGroupExternalId, newGroupManagementType: newGroupManagementType)
        return client.request(route, serverArgs: serverArgs)
    }

    /// List all linked applications of the team member. Note, this endpoint does not list any team-linked applications.
    ///
    /// - parameter teamMemberId: The team member id.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.ListMemberAppsResult` object on
    /// success or a `Team.ListMemberAppsError` object on failure.
    @discardableResult open func linkedAppsListMemberLinkedApps(teamMemberId: String) -> RpcRequest<Team.ListMemberAppsResultSerializer, Team.ListMemberAppsErrorSerializer> {
        let route = Team.linkedAppsListMemberLinkedApps
        let serverArgs = Team.ListMemberAppsArg(teamMemberId: teamMemberId)
        return client.request(route, serverArgs: serverArgs)
    }

    /// List all applications linked to the team members' accounts. Note, this endpoint does not list any team-linked
    /// applications.
    ///
    /// - parameter cursor: At the first call to the linkedAppsListMembersLinkedApps the cursor shouldn't be passed.
    /// Then, if the result of the call includes a cursor, the following requests should include the received cursors in
    /// order to receive the next sub list of the team applications.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.ListMembersAppsResult` object on
    /// success or a `Team.ListMembersAppsError` object on failure.
    @discardableResult open func linkedAppsListMembersLinkedApps(cursor: String? = nil) -> RpcRequest<Team.ListMembersAppsResultSerializer, Team.ListMembersAppsErrorSerializer> {
        let route = Team.linkedAppsListMembersLinkedApps
        let serverArgs = Team.ListMembersAppsArg(cursor: cursor)
        return client.request(route, serverArgs: serverArgs)
    }

    /// List all applications linked to the team members' accounts. Note, this endpoint doesn't list any team-linked
    /// applications.
    ///
    /// - parameter cursor: At the first call to the linkedAppsListTeamLinkedApps the cursor shouldn't be passed. Then,
    /// if the result of the call includes a cursor, the following requests should include the received cursors in order
    /// to receive the next sub list of the team applications.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.ListTeamAppsResult` object on success
    /// or a `Team.ListTeamAppsError` object on failure.
    @available(*, unavailable, message:"linkedAppsListTeamLinkedApps is deprecated. Use linkedAppsListMembersLinkedApps.")
    @discardableResult open func linkedAppsListTeamLinkedApps(cursor: String? = nil) -> RpcRequest<Team.ListTeamAppsResultSerializer, Team.ListTeamAppsErrorSerializer> {
        let route = Team.linkedAppsListTeamLinkedApps
        let serverArgs = Team.ListTeamAppsArg(cursor: cursor)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Revoke a linked application of the team member.
    ///
    /// - parameter appId: The application's unique id.
    /// - parameter teamMemberId: The unique id of the member owning the device.
    /// - parameter keepAppFolder: Whether to keep the application dedicated folder (in case the application uses  one).
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Team.RevokeLinkedAppError` object on failure.
    @discardableResult open func linkedAppsRevokeLinkedApp(appId: String, teamMemberId: String, keepAppFolder: Bool = true) -> RpcRequest<VoidSerializer, Team.RevokeLinkedAppErrorSerializer> {
        let route = Team.linkedAppsRevokeLinkedApp
        let serverArgs = Team.RevokeLinkedApiAppArg(appId: appId, teamMemberId: teamMemberId, keepAppFolder: keepAppFolder)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Revoke a list of linked applications of the team members.
    ///
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.RevokeLinkedAppBatchResult` object on
    /// success or a `Team.RevokeLinkedAppBatchError` object on failure.
    @discardableResult open func linkedAppsRevokeLinkedAppBatch(revokeLinkedApp: Array<Team.RevokeLinkedApiAppArg>) -> RpcRequest<Team.RevokeLinkedAppBatchResultSerializer, Team.RevokeLinkedAppBatchErrorSerializer> {
        let route = Team.linkedAppsRevokeLinkedAppBatch
        let serverArgs = Team.RevokeLinkedApiAppBatchArg(revokeLinkedApp: revokeLinkedApp)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Add users to member space limits excluded users list.
    ///
    /// - parameter users: List of users to be added/removed.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.ExcludedUsersUpdateResult` object on
    /// success or a `Team.ExcludedUsersUpdateError` object on failure.
    @discardableResult open func memberSpaceLimitsExcludedUsersAdd(users: Array<Team.UserSelectorArg>? = nil) -> RpcRequest<Team.ExcludedUsersUpdateResultSerializer, Team.ExcludedUsersUpdateErrorSerializer> {
        let route = Team.memberSpaceLimitsExcludedUsersAdd
        let serverArgs = Team.ExcludedUsersUpdateArg(users: users)
        return client.request(route, serverArgs: serverArgs)
    }

    /// List member space limits excluded users.
    ///
    /// - parameter limit: Number of results to return per call.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.ExcludedUsersListResult` object on
    /// success or a `Team.ExcludedUsersListError` object on failure.
    @discardableResult open func memberSpaceLimitsExcludedUsersList(limit: UInt32 = 1000) -> RpcRequest<Team.ExcludedUsersListResultSerializer, Team.ExcludedUsersListErrorSerializer> {
        let route = Team.memberSpaceLimitsExcludedUsersList
        let serverArgs = Team.ExcludedUsersListArg(limit: limit)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Continue listing member space limits excluded users.
    ///
    /// - parameter cursor: Indicates from what point to get the next set of users.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.ExcludedUsersListResult` object on
    /// success or a `Team.ExcludedUsersListContinueError` object on failure.
    @discardableResult open func memberSpaceLimitsExcludedUsersListContinue(cursor: String) -> RpcRequest<Team.ExcludedUsersListResultSerializer, Team.ExcludedUsersListContinueErrorSerializer> {
        let route = Team.memberSpaceLimitsExcludedUsersListContinue
        let serverArgs = Team.ExcludedUsersListContinueArg(cursor: cursor)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Remove users from member space limits excluded users list.
    ///
    /// - parameter users: List of users to be added/removed.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.ExcludedUsersUpdateResult` object on
    /// success or a `Team.ExcludedUsersUpdateError` object on failure.
    @discardableResult open func memberSpaceLimitsExcludedUsersRemove(users: Array<Team.UserSelectorArg>? = nil) -> RpcRequest<Team.ExcludedUsersUpdateResultSerializer, Team.ExcludedUsersUpdateErrorSerializer> {
        let route = Team.memberSpaceLimitsExcludedUsersRemove
        let serverArgs = Team.ExcludedUsersUpdateArg(users: users)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Get users custom quota. Returns none as the custom quota if none was set. A maximum of 1000 members can be
    /// specified in a single call.
    ///
    /// - parameter users: List of users.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Array<Team.CustomQuotaResult>` object on
    /// success or a `Team.CustomQuotaError` object on failure.
    @discardableResult open func memberSpaceLimitsGetCustomQuota(users: Array<Team.UserSelectorArg>) -> RpcRequest<ArraySerializer<Team.CustomQuotaResultSerializer>, Team.CustomQuotaErrorSerializer> {
        let route = Team.memberSpaceLimitsGetCustomQuota
        let serverArgs = Team.CustomQuotaUsersArg(users: users)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Remove users custom quota. A maximum of 1000 members can be specified in a single call.
    ///
    /// - parameter users: List of users.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Array<Team.RemoveCustomQuotaResult>`
    /// object on success or a `Team.CustomQuotaError` object on failure.
    @discardableResult open func memberSpaceLimitsRemoveCustomQuota(users: Array<Team.UserSelectorArg>) -> RpcRequest<ArraySerializer<Team.RemoveCustomQuotaResultSerializer>, Team.CustomQuotaErrorSerializer> {
        let route = Team.memberSpaceLimitsRemoveCustomQuota
        let serverArgs = Team.CustomQuotaUsersArg(users: users)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Set users custom quota. Custom quota has to be at least 15GB. A maximum of 1000 members can be specified in a
    /// single call.
    ///
    /// - parameter usersAndQuotas: List of users and their custom quotas.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Array<Team.CustomQuotaResult>` object on
    /// success or a `Team.SetCustomQuotaError` object on failure.
    @discardableResult open func memberSpaceLimitsSetCustomQuota(usersAndQuotas: Array<Team.UserCustomQuotaArg>) -> RpcRequest<ArraySerializer<Team.CustomQuotaResultSerializer>, Team.SetCustomQuotaErrorSerializer> {
        let route = Team.memberSpaceLimitsSetCustomQuota
        let serverArgs = Team.SetCustomQuotaArg(usersAndQuotas: usersAndQuotas)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Adds members to a team. Permission : Team member management A maximum of 20 members can be specified in a single
    /// call. If no Dropbox account exists with the email address specified, a new Dropbox account will be created with
    /// the given email address, and that account will be invited to the team. If a personal Dropbox account exists with
    /// the email address specified in the call, this call will create a placeholder Dropbox account for the user on the
    /// team and send an email inviting the user to migrate their existing personal account onto the team. Team member
    /// management apps are required to set an initial given_name and surname for a user to use in the team invitation
    /// and for 'Perform as team member' actions taken on the user before they become 'active'.
    ///
    /// - parameter newMembers: Details of new members to be added to the team.
    /// - parameter forceAsync: Whether to force the add to happen asynchronously.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.MembersAddLaunch` object on success
    /// or a `Void` object on failure.
    @discardableResult open func membersAdd(newMembers: Array<Team.MemberAddArg>, forceAsync: Bool = false) -> RpcRequest<Team.MembersAddLaunchSerializer, VoidSerializer> {
        let route = Team.membersAdd
        let serverArgs = Team.MembersAddArg(newMembers: newMembers, forceAsync: forceAsync)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Once an async_job_id is returned from membersAdd , use this to poll the status of the asynchronous request.
    /// Permission : Team member management.
    ///
    /// - parameter asyncJobId: Id of the asynchronous job. This is the value of a response returned from the method
    /// that launched the job.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.MembersAddJobStatus` object on
    /// success or a `Async.PollError` object on failure.
    @discardableResult open func membersAddJobStatusGet(asyncJobId: String) -> RpcRequest<Team.MembersAddJobStatusSerializer, Async.PollErrorSerializer> {
        let route = Team.membersAddJobStatusGet
        let serverArgs = Async.PollArg(asyncJobId: asyncJobId)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Returns information about multiple team members. Permission : Team information This endpoint will return
    /// idNotFound in MembersGetInfoItem, for IDs (or emails) that cannot be matched to a valid team member.
    ///
    /// - parameter members: List of team members.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Array<Team.MembersGetInfoItem>` object on
    /// success or a `Team.MembersGetInfoError` object on failure.
    @discardableResult open func membersGetInfo(members: Array<Team.UserSelectorArg>) -> RpcRequest<ArraySerializer<Team.MembersGetInfoItemSerializer>, Team.MembersGetInfoErrorSerializer> {
        let route = Team.membersGetInfo
        let serverArgs = Team.MembersGetInfoArgs(members: members)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Lists members of a team. Permission : Team information.
    ///
    /// - parameter limit: Number of results to return per call.
    /// - parameter includeRemoved: Whether to return removed members.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.MembersListResult` object on success
    /// or a `Team.MembersListError` object on failure.
    @discardableResult open func membersList(limit: UInt32 = 1000, includeRemoved: Bool = false) -> RpcRequest<Team.MembersListResultSerializer, Team.MembersListErrorSerializer> {
        let route = Team.membersList
        let serverArgs = Team.MembersListArg(limit: limit, includeRemoved: includeRemoved)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Once a cursor has been retrieved from membersList, use this to paginate through all team members. Permission :
    /// Team information.
    ///
    /// - parameter cursor: Indicates from what point to get the next set of members.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.MembersListResult` object on success
    /// or a `Team.MembersListContinueError` object on failure.
    @discardableResult open func membersListContinue(cursor: String) -> RpcRequest<Team.MembersListResultSerializer, Team.MembersListContinueErrorSerializer> {
        let route = Team.membersListContinue
        let serverArgs = Team.MembersListContinueArg(cursor: cursor)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Moves removed member's files to a different member. This endpoint initiates an asynchronous job. To obtain the
    /// final result of the job, the client should periodically poll membersMoveFormerMemberFilesJobStatusCheck.
    /// Permission : Team member management.
    ///
    /// - parameter transferDestId: Files from the deleted member account will be transferred to this user.
    /// - parameter transferAdminId: Errors during the transfer process will be sent via email to this user.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Async.LaunchEmptyResult` object on success
    /// or a `Team.MembersTransferFormerMembersFilesError` object on failure.
    @discardableResult open func membersMoveFormerMemberFiles(user: Team.UserSelectorArg, transferDestId: Team.UserSelectorArg, transferAdminId: Team.UserSelectorArg) -> RpcRequest<Async.LaunchEmptyResultSerializer, Team.MembersTransferFormerMembersFilesErrorSerializer> {
        let route = Team.membersMoveFormerMemberFiles
        let serverArgs = Team.MembersDataTransferArg(user: user, transferDestId: transferDestId, transferAdminId: transferAdminId)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Once an async_job_id is returned from membersMoveFormerMemberFiles , use this to poll the status of the
    /// asynchronous request. Permission : Team member management.
    ///
    /// - parameter asyncJobId: Id of the asynchronous job. This is the value of a response returned from the method
    /// that launched the job.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Async.PollEmptyResult` object on success
    /// or a `Async.PollError` object on failure.
    @discardableResult open func membersMoveFormerMemberFilesJobStatusCheck(asyncJobId: String) -> RpcRequest<Async.PollEmptyResultSerializer, Async.PollErrorSerializer> {
        let route = Team.membersMoveFormerMemberFilesJobStatusCheck
        let serverArgs = Async.PollArg(asyncJobId: asyncJobId)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Recover a deleted member. Permission : Team member management Exactly one of team_member_id, email, or
    /// external_id must be provided to identify the user account.
    ///
    /// - parameter user: Identity of user to recover.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Team.MembersRecoverError` object on failure.
    @discardableResult open func membersRecover(user: Team.UserSelectorArg) -> RpcRequest<VoidSerializer, Team.MembersRecoverErrorSerializer> {
        let route = Team.membersRecover
        let serverArgs = Team.MembersRecoverArg(user: user)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Removes a member from a team. Permission : Team member management Exactly one of team_member_id, email, or
    /// external_id must be provided to identify the user account. Accounts can be recovered via membersRecover for a 7
    /// day period or until the account has been permanently deleted or transferred to another account (whichever comes
    /// first). Calling membersAdd while a user is still recoverable on your team will return with userAlreadyOnTeam in
    /// MemberAddResult. Accounts can have their files transferred via the admin console for a limited time, based on
    /// the version history length associated with the team (120 days for most teams). This endpoint may initiate an
    /// asynchronous job. To obtain the final result of the job, the client should periodically poll
    /// membersRemoveJobStatusGet.
    ///
    /// - parameter transferDestId: If provided, files from the deleted member account will be transferred to this user.
    /// - parameter transferAdminId: If provided, errors during the transfer process will be sent via email to this
    /// user. If the transfer_dest_id argument was provided, then this argument must be provided as well.
    /// - parameter keepAccount: Downgrade the member to a Basic account. The user will retain the email address
    /// associated with their Dropbox  account and data in their account that is not restricted to team members. In
    /// order to keep the account the argument wipe_data should be set to False.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Async.LaunchEmptyResult` object on success
    /// or a `Team.MembersRemoveError` object on failure.
    @discardableResult open func membersRemove(user: Team.UserSelectorArg, wipeData: Bool = true, transferDestId: Team.UserSelectorArg? = nil, transferAdminId: Team.UserSelectorArg? = nil, keepAccount: Bool = false) -> RpcRequest<Async.LaunchEmptyResultSerializer, Team.MembersRemoveErrorSerializer> {
        let route = Team.membersRemove
        let serverArgs = Team.MembersRemoveArg(user: user, wipeData: wipeData, transferDestId: transferDestId, transferAdminId: transferAdminId, keepAccount: keepAccount)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Once an async_job_id is returned from membersRemove , use this to poll the status of the asynchronous request.
    /// Permission : Team member management.
    ///
    /// - parameter asyncJobId: Id of the asynchronous job. This is the value of a response returned from the method
    /// that launched the job.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Async.PollEmptyResult` object on success
    /// or a `Async.PollError` object on failure.
    @discardableResult open func membersRemoveJobStatusGet(asyncJobId: String) -> RpcRequest<Async.PollEmptyResultSerializer, Async.PollErrorSerializer> {
        let route = Team.membersRemoveJobStatusGet
        let serverArgs = Async.PollArg(asyncJobId: asyncJobId)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Sends welcome email to pending team member. Permission : Team member management Exactly one of team_member_id,
    /// email, or external_id must be provided to identify the user account. No-op if team member is not pending.
    ///
    /// - parameter userSelectorArg: Argument for selecting a single user, either by team_member_id, external_id or
    /// email.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Team.MembersSendWelcomeError` object on failure.
    @discardableResult open func membersSendWelcomeEmail(userSelectorArg: Team.UserSelectorArg) -> RpcRequest<VoidSerializer, Team.MembersSendWelcomeErrorSerializer> {
        let route = Team.membersSendWelcomeEmail
        let serverArgs = userSelectorArg
        return client.request(route, serverArgs: serverArgs)
    }

    /// Updates a team member's permissions. Permission : Team member management.
    ///
    /// - parameter user: Identity of user whose role will be set.
    /// - parameter newRole: The new role of the member.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.MembersSetPermissionsResult` object
    /// on success or a `Team.MembersSetPermissionsError` object on failure.
    @discardableResult open func membersSetAdminPermissions(user: Team.UserSelectorArg, newRole: Team.AdminTier) -> RpcRequest<Team.MembersSetPermissionsResultSerializer, Team.MembersSetPermissionsErrorSerializer> {
        let route = Team.membersSetAdminPermissions
        let serverArgs = Team.MembersSetPermissionsArg(user: user, newRole: newRole)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Updates a team member's profile. Permission : Team member management.
    ///
    /// - parameter user: Identity of user whose profile will be set.
    /// - parameter newEmail: New email for member.
    /// - parameter newExternalId: New external ID for member.
    /// - parameter newGivenName: New given name for member.
    /// - parameter newSurname: New surname for member.
    /// - parameter newPersistentId: New persistent ID. This field only available to teams using persistent ID SAML
    /// configuration.
    /// - parameter newIsDirectoryRestricted: New value for whether the user is a directory restricted user.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.TeamMemberInfo` object on success or
    /// a `Team.MembersSetProfileError` object on failure.
    @discardableResult open func membersSetProfile(user: Team.UserSelectorArg, newEmail: String? = nil, newExternalId: String? = nil, newGivenName: String? = nil, newSurname: String? = nil, newPersistentId: String? = nil, newIsDirectoryRestricted: Bool? = nil) -> RpcRequest<Team.TeamMemberInfoSerializer, Team.MembersSetProfileErrorSerializer> {
        let route = Team.membersSetProfile
        let serverArgs = Team.MembersSetProfileArg(user: user, newEmail: newEmail, newExternalId: newExternalId, newGivenName: newGivenName, newSurname: newSurname, newPersistentId: newPersistentId, newIsDirectoryRestricted: newIsDirectoryRestricted)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Suspend a member from a team. Permission : Team member management Exactly one of team_member_id, email, or
    /// external_id must be provided to identify the user account.
    ///
    /// - parameter wipeData: If provided, controls if the user's data will be deleted on their linked devices.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Team.MembersSuspendError` object on failure.
    @discardableResult open func membersSuspend(user: Team.UserSelectorArg, wipeData: Bool = true) -> RpcRequest<VoidSerializer, Team.MembersSuspendErrorSerializer> {
        let route = Team.membersSuspend
        let serverArgs = Team.MembersDeactivateArg(user: user, wipeData: wipeData)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Unsuspend a member from a team. Permission : Team member management Exactly one of team_member_id, email, or
    /// external_id must be provided to identify the user account.
    ///
    /// - parameter user: Identity of user to unsuspend.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Team.MembersUnsuspendError` object on failure.
    @discardableResult open func membersUnsuspend(user: Team.UserSelectorArg) -> RpcRequest<VoidSerializer, Team.MembersUnsuspendErrorSerializer> {
        let route = Team.membersUnsuspend
        let serverArgs = Team.MembersUnsuspendArg(user: user)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Returns a list of all team-accessible namespaces. This list includes team folders, shared folders containing
    /// team members, team members' home namespaces, and team members' app folders. Home namespaces and app folders are
    /// always owned by this team or members of the team, but shared folders may be owned by other users or other teams.
    /// Duplicates may occur in the list.
    ///
    /// - parameter limit: Specifying a value here has no effect.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.TeamNamespacesListResult` object on
    /// success or a `Team.TeamNamespacesListError` object on failure.
    @discardableResult open func namespacesList(limit: UInt32 = 1000) -> RpcRequest<Team.TeamNamespacesListResultSerializer, Team.TeamNamespacesListErrorSerializer> {
        let route = Team.namespacesList
        let serverArgs = Team.TeamNamespacesListArg(limit: limit)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Once a cursor has been retrieved from namespacesList, use this to paginate through all team-accessible
    /// namespaces. Duplicates may occur in the list.
    ///
    /// - parameter cursor: Indicates from what point to get the next set of team-accessible namespaces.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.TeamNamespacesListResult` object on
    /// success or a `Team.TeamNamespacesListContinueError` object on failure.
    @discardableResult open func namespacesListContinue(cursor: String) -> RpcRequest<Team.TeamNamespacesListResultSerializer, Team.TeamNamespacesListContinueErrorSerializer> {
        let route = Team.namespacesListContinue
        let serverArgs = Team.TeamNamespacesListContinueArg(cursor: cursor)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Permission : Team member file access.
    ///
    ///
    ///  - returns: Through the response callback, the caller will receive a `FileProperties.AddTemplateResult` object
    /// on success or a `FileProperties.ModifyTemplateError` object on failure.
    @available(*, unavailable, message:"propertiesTemplateAdd is deprecated.")
    @discardableResult open func propertiesTemplateAdd(name: String, description_: String, fields: Array<FileProperties.PropertyFieldTemplate>) -> RpcRequest<FileProperties.AddTemplateResultSerializer, FileProperties.ModifyTemplateErrorSerializer> {
        let route = Team.propertiesTemplateAdd
        let serverArgs = FileProperties.AddTemplateArg(name: name, description_: description_, fields: fields)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Permission : Team member file access.
    ///
    /// - parameter templateId: An identifier for template added by route  See templatesAddForUser or
    /// templatesAddForTeam.
    ///
    ///  - returns: Through the response callback, the caller will receive a `FileProperties.GetTemplateResult` object
    /// on success or a `FileProperties.TemplateError` object on failure.
    @available(*, unavailable, message:"propertiesTemplateGet is deprecated.")
    @discardableResult open func propertiesTemplateGet(templateId: String) -> RpcRequest<FileProperties.GetTemplateResultSerializer, FileProperties.TemplateErrorSerializer> {
        let route = Team.propertiesTemplateGet
        let serverArgs = FileProperties.GetTemplateArg(templateId: templateId)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Permission : Team member file access.
    ///
    ///
    ///  - returns: Through the response callback, the caller will receive a `FileProperties.ListTemplateResult` object
    /// on success or a `FileProperties.TemplateError` object on failure.
    @available(*, unavailable, message:"propertiesTemplateList is deprecated.")
    @discardableResult open func propertiesTemplateList() -> RpcRequest<FileProperties.ListTemplateResultSerializer, FileProperties.TemplateErrorSerializer> {
        let route = Team.propertiesTemplateList
        return client.request(route)
    }

    /// Permission : Team member file access.
    ///
    /// - parameter templateId: An identifier for template added by  See templatesAddForUser or templatesAddForTeam.
    /// - parameter name: A display name for the template. template names can be up to 256 bytes.
    /// - parameter description_: Description for the new template. Template descriptions can be up to 1024 bytes.
    /// - parameter addFields: Property field templates to be added to the group template. There can be up to 32
    /// properties in a single template.
    ///
    ///  - returns: Through the response callback, the caller will receive a `FileProperties.UpdateTemplateResult`
    /// object on success or a `FileProperties.ModifyTemplateError` object on failure.
    @available(*, unavailable, message:"propertiesTemplateUpdate is deprecated.")
    @discardableResult open func propertiesTemplateUpdate(templateId: String, name: String? = nil, description_: String? = nil, addFields: Array<FileProperties.PropertyFieldTemplate>? = nil) -> RpcRequest<FileProperties.UpdateTemplateResultSerializer, FileProperties.ModifyTemplateErrorSerializer> {
        let route = Team.propertiesTemplateUpdate
        let serverArgs = FileProperties.UpdateTemplateArg(templateId: templateId, name: name, description_: description_, addFields: addFields)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Retrieves reporting data about a team's user activity.
    ///
    /// - parameter startDate: Optional starting date (inclusive).
    /// - parameter endDate: Optional ending date (exclusive).
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.GetActivityReport` object on success
    /// or a `Team.DateRangeError` object on failure.
    @discardableResult open func reportsGetActivity(startDate: Date? = nil, endDate: Date? = nil) -> RpcRequest<Team.GetActivityReportSerializer, Team.DateRangeErrorSerializer> {
        let route = Team.reportsGetActivity
        let serverArgs = Team.DateRange(startDate: startDate, endDate: endDate)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Retrieves reporting data about a team's linked devices.
    ///
    /// - parameter startDate: Optional starting date (inclusive).
    /// - parameter endDate: Optional ending date (exclusive).
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.GetDevicesReport` object on success
    /// or a `Team.DateRangeError` object on failure.
    @discardableResult open func reportsGetDevices(startDate: Date? = nil, endDate: Date? = nil) -> RpcRequest<Team.GetDevicesReportSerializer, Team.DateRangeErrorSerializer> {
        let route = Team.reportsGetDevices
        let serverArgs = Team.DateRange(startDate: startDate, endDate: endDate)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Retrieves reporting data about a team's membership.
    ///
    /// - parameter startDate: Optional starting date (inclusive).
    /// - parameter endDate: Optional ending date (exclusive).
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.GetMembershipReport` object on
    /// success or a `Team.DateRangeError` object on failure.
    @discardableResult open func reportsGetMembership(startDate: Date? = nil, endDate: Date? = nil) -> RpcRequest<Team.GetMembershipReportSerializer, Team.DateRangeErrorSerializer> {
        let route = Team.reportsGetMembership
        let serverArgs = Team.DateRange(startDate: startDate, endDate: endDate)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Retrieves reporting data about a team's storage usage.
    ///
    /// - parameter startDate: Optional starting date (inclusive).
    /// - parameter endDate: Optional ending date (exclusive).
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.GetStorageReport` object on success
    /// or a `Team.DateRangeError` object on failure.
    @discardableResult open func reportsGetStorage(startDate: Date? = nil, endDate: Date? = nil) -> RpcRequest<Team.GetStorageReportSerializer, Team.DateRangeErrorSerializer> {
        let route = Team.reportsGetStorage
        let serverArgs = Team.DateRange(startDate: startDate, endDate: endDate)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Sets an archived team folder's status to active. Permission : Team member file access.
    ///
    /// - parameter teamFolderId: The ID of the team folder.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.TeamFolderMetadata` object on success
    /// or a `Team.TeamFolderActivateError` object on failure.
    @discardableResult open func teamFolderActivate(teamFolderId: String) -> RpcRequest<Team.TeamFolderMetadataSerializer, Team.TeamFolderActivateErrorSerializer> {
        let route = Team.teamFolderActivate
        let serverArgs = Team.TeamFolderIdArg(teamFolderId: teamFolderId)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Sets an active team folder's status to archived and removes all folder and file members. Permission : Team
    /// member file access.
    ///
    /// - parameter forceAsyncOff: Whether to force the archive to happen synchronously.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.TeamFolderArchiveLaunch` object on
    /// success or a `Team.TeamFolderArchiveError` object on failure.
    @discardableResult open func teamFolderArchive(teamFolderId: String, forceAsyncOff: Bool = false) -> RpcRequest<Team.TeamFolderArchiveLaunchSerializer, Team.TeamFolderArchiveErrorSerializer> {
        let route = Team.teamFolderArchive
        let serverArgs = Team.TeamFolderArchiveArg(teamFolderId: teamFolderId, forceAsyncOff: forceAsyncOff)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Returns the status of an asynchronous job for archiving a team folder. Permission : Team member file access.
    ///
    /// - parameter asyncJobId: Id of the asynchronous job. This is the value of a response returned from the method
    /// that launched the job.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.TeamFolderArchiveJobStatus` object on
    /// success or a `Async.PollError` object on failure.
    @discardableResult open func teamFolderArchiveCheck(asyncJobId: String) -> RpcRequest<Team.TeamFolderArchiveJobStatusSerializer, Async.PollErrorSerializer> {
        let route = Team.teamFolderArchiveCheck
        let serverArgs = Async.PollArg(asyncJobId: asyncJobId)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Creates a new, active, team folder with no members. Permission : Team member file access.
    ///
    /// - parameter name: Name for the new team folder.
    /// - parameter syncSetting: The sync setting to apply to this team folder. Only permitted if the team has team
    /// selective sync enabled.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.TeamFolderMetadata` object on success
    /// or a `Team.TeamFolderCreateError` object on failure.
    @discardableResult open func teamFolderCreate(name: String, syncSetting: Files.SyncSettingArg? = nil) -> RpcRequest<Team.TeamFolderMetadataSerializer, Team.TeamFolderCreateErrorSerializer> {
        let route = Team.teamFolderCreate
        let serverArgs = Team.TeamFolderCreateArg(name: name, syncSetting: syncSetting)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Retrieves metadata for team folders. Permission : Team member file access.
    ///
    /// - parameter teamFolderIds: The list of team folder IDs.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Array<Team.TeamFolderGetInfoItem>` object
    /// on success or a `Void` object on failure.
    @discardableResult open func teamFolderGetInfo(teamFolderIds: Array<String>) -> RpcRequest<ArraySerializer<Team.TeamFolderGetInfoItemSerializer>, VoidSerializer> {
        let route = Team.teamFolderGetInfo
        let serverArgs = Team.TeamFolderIdListArg(teamFolderIds: teamFolderIds)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Lists all team folders. Permission : Team member file access.
    ///
    /// - parameter limit: The maximum number of results to return per request.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.TeamFolderListResult` object on
    /// success or a `Team.TeamFolderListError` object on failure.
    @discardableResult open func teamFolderList(limit: UInt32 = 1000) -> RpcRequest<Team.TeamFolderListResultSerializer, Team.TeamFolderListErrorSerializer> {
        let route = Team.teamFolderList
        let serverArgs = Team.TeamFolderListArg(limit: limit)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Once a cursor has been retrieved from teamFolderList, use this to paginate through all team folders. Permission
    /// : Team member file access.
    ///
    /// - parameter cursor: Indicates from what point to get the next set of team folders.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.TeamFolderListResult` object on
    /// success or a `Team.TeamFolderListContinueError` object on failure.
    @discardableResult open func teamFolderListContinue(cursor: String) -> RpcRequest<Team.TeamFolderListResultSerializer, Team.TeamFolderListContinueErrorSerializer> {
        let route = Team.teamFolderListContinue
        let serverArgs = Team.TeamFolderListContinueArg(cursor: cursor)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Permanently deletes an archived team folder. Permission : Team member file access.
    ///
    /// - parameter teamFolderId: The ID of the team folder.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Team.TeamFolderPermanentlyDeleteError` object on failure.
    @discardableResult open func teamFolderPermanentlyDelete(teamFolderId: String) -> RpcRequest<VoidSerializer, Team.TeamFolderPermanentlyDeleteErrorSerializer> {
        let route = Team.teamFolderPermanentlyDelete
        let serverArgs = Team.TeamFolderIdArg(teamFolderId: teamFolderId)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Changes an active team folder's name. Permission : Team member file access.
    ///
    /// - parameter name: New team folder name.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.TeamFolderMetadata` object on success
    /// or a `Team.TeamFolderRenameError` object on failure.
    @discardableResult open func teamFolderRename(teamFolderId: String, name: String) -> RpcRequest<Team.TeamFolderMetadataSerializer, Team.TeamFolderRenameErrorSerializer> {
        let route = Team.teamFolderRename
        let serverArgs = Team.TeamFolderRenameArg(teamFolderId: teamFolderId, name: name)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Updates the sync settings on a team folder or its contents.  Use of this endpoint requires that the team has
    /// team selective sync enabled.
    ///
    /// - parameter syncSetting: Sync setting to apply to the team folder itself. Only meaningful if the team folder is
    /// not a shared team root.
    /// - parameter contentSyncSettings: Sync settings to apply to contents of this team folder.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.TeamFolderMetadata` object on success
    /// or a `Team.TeamFolderUpdateSyncSettingsError` object on failure.
    @discardableResult open func teamFolderUpdateSyncSettings(teamFolderId: String, syncSetting: Files.SyncSettingArg? = nil, contentSyncSettings: Array<Files.ContentSyncSettingArg>? = nil) -> RpcRequest<Team.TeamFolderMetadataSerializer, Team.TeamFolderUpdateSyncSettingsErrorSerializer> {
        let route = Team.teamFolderUpdateSyncSettings
        let serverArgs = Team.TeamFolderUpdateSyncSettingsArg(teamFolderId: teamFolderId, syncSetting: syncSetting, contentSyncSettings: contentSyncSettings)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Returns the member profile of the admin who generated the team access token used to make the call.
    ///
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.TokenGetAuthenticatedAdminResult`
    /// object on success or a `Team.TokenGetAuthenticatedAdminError` object on failure.
    @discardableResult open func tokenGetAuthenticatedAdmin() -> RpcRequest<Team.TokenGetAuthenticatedAdminResultSerializer, Team.TokenGetAuthenticatedAdminErrorSerializer> {
        let route = Team.tokenGetAuthenticatedAdmin
        return client.request(route)
    }

}
